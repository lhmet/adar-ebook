[
["index.html", "Análise de Dados Ambientais com R Apresentação", " Análise de Dados Ambientais com R Jônatan Tatsch 2018-04-23 Apresentação Este material é uma composição das notas de aula da disciplina Análise de Dados Ambientais com do curso de Graduação em meteorologia oferecido no Departamento de Física da Universidade Federal de Santa Maria (UFSM). O livro é designado para quem não tem experiência em programação, ou qualquer um com interesse em aprender o para manipular dados ambientais. O objetivo é prover uma material para ensinar os conceitos básicos de programação necessários para o processamento, a visualização e a análise de dados ambientais com o sistema computacional . Estes procedimentos são potencializados com o uso do software RStudio, uma interface de desenvolvimento integrado (IDE) para o . Neste livro o leitor aprenderá a sintaxe básica da linguagem (R Core Team 2017), a importação e exportação de dados, a criação de gráficos, funções, a padronização e organização de conjunto de dados ambientais; e finalmente, a confecção de relatórios dinâmicos e reproduzíveis. O material do livro inclui o uso de dados ambientais de diferentes áreas (meteorologia, climatologia, hidrologia, sensoriamento remoto) em exemplos práticos e em exercícios, para estimular a prática da programação. O texto é intercalado com trechos de códigos que podem ser reproduzidos e os resultados visualizados no computador do leitor. Após a introdução ao apresenta-se as capacidades específicas do para manipulação de dados. Baseado na experiência do autor são empregados os pacotes mais adequados para cada finalidade, como dplyr e tidyr para o processamento de dados e o ggplot2 para visualização de dados. A intenção do livro é que após a leitura, o leitor tenha o conhecimento suficiente para desenvolver códigos que automatizem tarefas repetitivas, assim reduzindo o tempo gasto na etapa de preparação de dados. Esta programação mais efetiva permitirá focar mais na análise de dados e na comunicação dos resultados, seja ela na forma de documentos acadêmicos, ou relatórios técnicos em empresas públicas e privadas. O texto está em formato html para tirar o melhor proveito de recursos de multimídia, da capacidade de busca de texto e links para websites. O texto é organizado em 5 capítulos: 1 Introdução 2 Instalação do e Rstudio 3 Interface do Usuário 4 Rstudio 5 Operações Básicas 6 Tipos de dados Referências "],
["intro.html", "1 Introdução", " 1 Introdução Breve intro. "],
["analise-de-dados-meteorologicos.html", "1.1 Análise de dados meteorológicos", " 1.1 Análise de dados meteorológicos Processo pelo qual adquire-se conhecimento, compreensão e percepção dos fenômenos meteorológicos a partir de observações (dados) qualitativas e quantitativas. "],
["ciencia-de-dados.html", "1.2 Ciência de dados", " 1.2 Ciência de dados "],
["etapas-para-abordagem-de-um-problema.html", "1.3 Etapas para abordagem de um problema", " 1.3 Etapas para abordagem de um problema Questão científica/problema Obtenção de dados: coleta/medida do(as) estado/condições da atmosfera Instrumentos e sensores Processamento de dados: download —&gt; limpeza —&gt; formatação —&gt; transformação —&gt; controle de qualidade ferramenta/software conhecimento em programação Análise de dados ferramenta/software conhecimento em programação Solução para o problema Proposta de um modelo estatístico, empírico, ou fisicamente baseado conhecimento em programação Apresentação/divulgação/publicação "],
["programacao-computacional.html", "1.4 Programação computacional", " 1.4 Programação computacional "],
["section.html", "1.5 ", " 1.5 R é o termo usado para se referir a linguagem de programação e ao software que interpreta os scripts escritos usando esta linguagem. Comunidade fantástica Contribuidores (R-core Team) milhares de pessoas usam o R diariamente e ajudam outras pessoas Software Livre (GPL), Código aberto e multiplataforma Ambiente para Análise de dados interativa "],
["por-que-o-r.html", "1.6 Por que o R?", " 1.6 Por que o R? R não é uma GUI (Interface gráfica do usuário) e isso é bom há uma natural resistência e dificuldade ao uso de códigos e scripts scripts favorecem a automatização e reprodutibilidade força você a ter um conhecimneto mais aprofundado do que está fazendo Reprodutibilidade qualquer pessoa (inclusive você mesmo no futuro) pode obter os mesmos resultados do mesmo conjunto de dados R é integrado com outras ferramentas de que permitem atualizar seus resultados, figuras e análises automaticamente Relatório dinâmicos e interativos Acesso ao estado da arte da ciência de dados (Big Data, Data Mining, Machine Leraning) é um software livre, de código fonte aberto e funciona em diversos sistemas operacionais (Linux, Windows e MacOS). Interface com Fortran, C, C++, Python Visualização de dados R produz gráficos de alta qualidade R trabalha com dados de todas formas e tamanhos Extensões para Manipulação de dados "],
["pacotes-da-comunidade-do-r.html", "1.7 Pacotes da comunidade do R", " 1.7 Pacotes da comunidade do R Evolução do nº de pacotes disponíveis no CRAN "],
["por-que-um-meteorologista-usaria-o-r.html", "1.8 Por que um meteorologista usaria o R?", " 1.8 Por que um meteorologista usaria o R? A meteorologia é 4D: meteorologia &lt;- function(x, y, z, t){ ...muita coisa para caber em um slide... } Logo, requer ferramentas específicas para: manipulação de dados espacias análise de séries temporais importação e ferramentas de SIG leitura de dados em formatos específicos (netcdf, binários, grib2, …) "],
["r-nao-e-perfeito.html", "1.9 R não é perfeito!", " 1.9 R não é perfeito! Muitos códigos em R são escritos para resolver um problema; foco nos resultados e não no processo usuários não são programadores códigos deselegantes, lentos e difíceis de entender Como o nosso idioma, há muitas exceções para serem lembradas R não é muito rápido e códigos mal escritos serão lentos São apenas ~20 anos de evolução Há muito o que melhorar "],
["para-saber-mais-sobre-o-r.html", "1.10 Para saber mais sobre o R", " 1.10 Para saber mais sobre o R Documentação oficial - Manuais do R traduzidos Lista de Livros relacionados ao R Livros gratuitos (em inglês) Fóruns: lista Brasileira de discussão do programa R: R-br stackoverflow "],
["install.html", "2 Instalação do R e RStudio", " 2 Instalação do R e RStudio A interação do usuário com o é por meio da linha de comando. Essa interação pode ser facilitada com o uso do software RStudio Desktop. A seguir descreve-se como: instalar o no Windows e no Linux Ubuntu manter o sempre atualizado no Linux Ubuntu configurar um diretório para armazenar os pacotes do R instalados instalar o Rstudio Desktop Neste livro, o maior foco na instalação do é dada para o SO Linux Ubuntu, pelo fato de assim como o R, ser um software livre e de código aberto. Como o Linux Ubuntu é baseado no Debian o procedimento de instalação também se estende a essa distribuição Linux e as versões derivadas do Ubuntu que são oficialmente reconhecidas. A instalação no SO Windows é igual a instalação de qualquer outro software e pode ser facilmente encontrada na internet. Por esta razão, somente indicou-se o caminho de instalação, sem as instruções detalhadas de instalação para este SO. Ao instalar R e RStudio recomenda-se optar por instalar na língua inglesa. Assim quando surgir uma mensagem de erro durante o uso do software, basta usá-la numa pesquisa na internet para solucionar o problema. As chances de resolver o problema serão muito maiores se sua pesquisa for realizada em inglês. "],
["instalando-o.html", "2.1 Instalando o ", " 2.1 Instalando o O pode ser instalado a partir dos binários pré-compilados ou do código fonte. Aqui, descreve-se a instalação do a partir dos arquivos binários. 2.1.1 Windows O binário executável do para o Windows está disponível na Rede Abrangente de Arquivos do (CRAN) e pode ser baixado aqui. Abra o executável e siga instruções de instalação do R mantendo todas as opções padrões. No Windows a instalação do inclui uma Interface Gráfica do Usuário (GUI) acessível pelo executável RGui.exe (Figura 2.1). Um atalho para esse executável é gerado por default na área de trabalho com o símbolo do . Figure 2.1: Interface gráfica do usuário no R para Windows. 2.1.1.1 Atualização do no Windows Novas versões do R são disponibilizadas em geral com frequência de 5 vezes por ano. Recomenda-se manter o R atualizado, pois as novas versões incluem aperfeiçoamentos e a correção de bugs. As novas versões do vem com os pacotes padrões do R. Os demais pacotes instalados pelo usuário na versão anterior precisam ser reinstalados na nova versão do . Para atualizar o no Windows, ao invés de baixar o executável a cada nova versão e repetir o processo da seção anterior, você pode utilizar o pacote installr. A instalação de pacotes no será vista na seção 2.2. 2.1.2 Linux 2.1.2.1 Ubuntu Há várias formas de instalar o no Ubuntu, mas geralmente a versão compilada no repositório default do Ubuntu não é a última. Se isso não for problema para você então basta executar: sudo apt-get install r-base Entretanto, os pacotes do recém lançados são compilados para última versão do . Então você pode ter restrições ao uso de pacotes novos, os quais geralmente incluem o estado da arte de análise de dados. Por esta razão, abaixo mostra-se como instalar o de forma que seja atualizado automaticamente pelo sistema. 2.1.2.2 R sempre atualizado Se você quer trabalhar sempre com a última versão estável do , é possível configurar o Linux Ubuntu para atualizar automaticamente o . O procedimento de instalação requer senha de superusuário do sistema ou de privilégios sudo. Caso não tenha, consulte o administrador do sistema. Ao utilizar distribuições Linux Ubuntu é importante optar por versões estáveis1. As versões de Suporte de longo prazo (LTS) mais recentes são: 14.04 (abril de 2014, codename trusty) 16.04 (abril de 2016, codename xenial) A versão mais atual é a R version 3.4.4 (2017-01-27). Para que ele seja atualizado automaticamente no Ubuntu você precisa adicionar o endereço do repósitório do R mais próximo de sua região à lista de repositórios do Linux. No exemplo deste livro, o repositório mais próximo é o da UFPR (http://cran-r.c3sl.ufpr.br/). 2.1.2.2.1 Incluindo repositório do na Lista de repositórios do Ubuntu A lista de repositórios do sistema é armazenada no arquivo /etc/apt/sources.list. Mas primeiro, você precisa descobrir ou verificar o nome da versão do sistema operacional. Para isso, você pode utilizar o seguinte comando2 : $ lsb_release --codename | cut -f2 trusty Precisamos incluir no arquivo sources.list o espelho do repositório do R mais próximo. Veja a lista de espelhos de repositórios do aqui. Assim o gerenciador de pacotes apt3 fará a atualização do quando uma nova versão estiver disponível. Ou seja, você estará utilizando sempre versão mais atual do . O endereço do repositório da UFPR será inserido na última linha do arquivo sources.list usando alguns comandos linux. Essa tarefa requer privilégios de superusuário. Vamos trocar do seu usuário para o superusuário. $ sudo su Vamos definir no terminal uma variável com o endereço do repositório (da UFPR nesse caso) e o nome de versão do Ubuntu. # repos=&quot;deb http://cran-r.c3sl.ufpr.br/bin/linux/ubuntu `lsb_release --codename | cut -f2`/&quot; Note que a variável repos é uma sequência de caracteres com as seguintes informações: deb `linkRepositorioSelecionado`/bin/linux/ubuntu `versaoUbuntu`/ O valor da variável repos é mostrado pelo comando: echo $repos. Certifique-se de que a última palavra corresponde ao nome da sua versão Ubuntu. Para acrescentar essa informação no final do arquivo sources.list digite no terminal linux: # echo $repos &gt;&gt; /etc/apt/sources.list Feito isso, você pode retornar a sessão de usuário comum, usando o comando abaixo: # exit 2.1.2.2.2 APT protegido Os arquivos binários do para Ubuntu na CRAN são assinados com uma chave pública4 Para adicionar essa chave ao seu sistema digite os seguintes comandos: $ gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys E084DAB9 e então use essa informação como entrada no apt-key com $ gpg -a --export E084DAB9 | sudo apt-key add - Se aparecer a mensagem de que a chave pública foi importada, então não há necessidade de executar os comandos abaixo. Mas caso seja impresso alguma mensagem de erro, outra alternativa pode ser usada para obter a chave, via os comandos: $ gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9 $ gpg -a --export E084DAB9 | sudo apt-key add - 2.1.2.2.3 Atualização da lista de repositórios do Ubuntu e instalação do Após fazer as configurações da lista de repositórios e adicionar a chave é necessário fazer a atualização dessa lista (requer poderes de super usuário): $ sudo apt-get update Agora, pode instalar o binário do R: $ sudo apt-get install r-base 2.1.2.2.4 Testando o Para iniciar o no Ubuntu, digite R no cursor do terminal: $ R A partir desse momento já começamos uma sessão no . Vamos gerar uma sequência numérica de 1 a 10 e plotá-la. &gt; 1:10 [1] 1 2 3 4 5 6 7 8 9 10 &gt; plot(1:10) Figure 2.2: Gráfico da sequência de 10 números. Você pode sair do , sem salvar os dados da seção, com o código a seguir: &gt; q(save = &quot;no&quot;) 2.1.2.3 Diretório para instalação de pacotes Uma boa prática é definir um diretório para armazenamento dos pacotes utilizados. Isso lhe dá mais controle sobre os pacotes do instalados no sistema. Um local sugerido é o /home/usuario/.R/libs. O seu home ou pasta pessoal pode ser obtido com o comando echo $HOME. Para criar o diretório você pode digitar o comando abaixo: $ mkdir -p `echo $HOME`/.R/libs/ Para informar ao onde procurar os pacotes instalados, você precisa criar um arquivo chamado .Renviron, no diretório $HOME, contendo a expressão R_LIBS=/home/usuario/.R/libs/. Você pode fazer isso em um terminal com os comandos: $ R_LIBS=`echo $HOME/.R/libs/` $ echo $R_LIBS &gt;&gt; `echo $HOME/.Renviron` Esse caminho fica então visível ao , o que pode ser verificado executando a função .libPaths() na linha de comando do . Abra o : $ R e ao digitar: &gt; .libPaths() [1] &quot;/home/travis/R/Library&quot; &quot;/usr/local/lib/R/site-library&quot; [3] &quot;/home/travis/R-bin/lib/R/library&quot; o seu diretório /home/usuario/.R/libs5 deve aparecer em primeiro lugar. Indicando que este local tem prioridade para instalação dos pacotes. Caso o diretório deixe de existir os seguintes diretórios serão usados. Clique aqui para saber mais sobre as versões do Ubuntu.↩ Se o comando lsb_release não funcionar você precisa instalar o pacote lsb-release no sistema. Para isso, digite no terminal Linux sudo apt-get install lsb-release.↩ o gerenciador de pacotes apt é usado para instalação, atualização e remoção de pacotes em distribuições Debian GNU/Linux.↩ Chave pública de autenticação é um meio alternativo de se logar em um servidor ao invés de digitar uma senha. É uma forma mais segura e flexível, mas mais difícil de ser configurada. Esse meio alternativo de fazer login é importante se o computador está visível na internet. Para saber mais veja aqui.↩ Diretórios precedidos por “.” no Linux são diretórios ocultos. O diretório /home/usuario/.R é um diretório oculto, para visualizá-lo no Ubuntu, na interface gráfica do sistema, acesse View &gt; Show Hidden Files (ou Visualizar &gt; Mostrar arquivos ocultos). No terminal utilize ls -a para listar os arquivos ocultos.↩ "],
["install-pck.html", "2.2 Pacotes do R", " 2.2 Pacotes do R 2.2.1 Da internet 2.2.1.1 CRAN A forma mais fácil de instalar uma pacote do R é através da função install.packages(&quot;nome_do_pacote&quot;). Por default o pacote informado é instalado a partir da (CRAN) Por exemplo, para instalar o pacote devtools: install.packages(&quot;devtools&quot;) A função automaticamente resolverá as dependências do pacote, de forma que qualquer pacote dependente também será instalado. Para ter acesso as funções disponibilizadas com o pacote você precisa carregar o pacote: library(devtools) Para desinstalar um pacote você pode usar a função remove.packages(&quot;nome_do_pacote&quot;). 2.2.1.2 GitHub e R-forge Nem todos pacotes são disponíveis na CRAN. Muitos desenvolvedores disponibilizam seus pacotes em plataormas como o GitHub e R-forge. As vezes um pacote pode estar em ambos CRAN e GitHub (ou R-forge), mas a última versão - a de desenvolvimento - é somente disponibilizada no GitHub (ou R-forge). Para instalar um pacote de um repositório do GitHub usa-se a função install_github() do pacote devtools. Portanto, o pacote devtools precisa ser instalado primeiro. Antes de instalar o pacote devtools, usuários Windows precisam instalar o programa Rtools. A função para instalar um pacote do GitHub requer como argumento o nome do usuário e do repositório. Por exemplo, para instalar o pacote inmetr do repositório mantido pelo autor deste livro, usa-se: # install.packages(&quot;devtools&quot;) # carrega o pacote devtools library(devtools) # instala o pacote inmetr do repositório # https://github.com/lhmet/inmetr install_github(&quot;lhmet/inmetr&quot;) Para um repositório do R-forge, por exemplo o repositório do pacote raster, usa-se: install.packages(&quot;raster&quot;, repos = &quot;http://R-Forge.R-project.org&quot;) 2.2.1.3 Arquivo fonte local Códigos fonte de pacotes do R são armazenados como arquivos com a extensão .tar.gz. Binários compilados são armazenados com a extensão .zip. Exemplo de arquivos como estes podem ser baixados manualmente da CRAN (veja a seção Downloads em https://cran.r-project.org/web/packages/ggplot2/index.html), GitHub ou R-forge. Eventualmente um usuário pode instalar um pacote a partir desses arquivos localmente. Isto pode também ser feito com a função install.packages(), especifincando o argumento repos = NULL e o argumento pkgs com o caminho do arquivo. Por exemplo: install.packages(&quot;ggplot2_2.1.0.tar.gz&quot;, repos=NULL) "],
["install-rstudio.html", "2.3 RStudio no Ubuntu", " 2.3 RStudio no Ubuntu é uma empresa que desenvolve ferramentas gratuitas para o e produtos pagos para empresas. Uma de suas ferramentas gratuitas é o software RStudio Desktop que consiste em um ambiente integrado de desenvolvimento (IDE) construído especificamente para o , consequentemente, também é multiplataforma. Para instalação da versão do RStudio para Desktop, você precisa saber se seu SO é 64 ou 32-bit e a versão do Linux Ubuntu. Essas informações podem ser obtidas, respectivamente, pelos comandos: $ arch x86_64 Se retornar x86_64 sua máquina é 64-bit. $ lsb_release --release | cut -f2 14.04 Com essas informações, siga os seguintes passos: acesse RStudio clique em Download (Figura 2.3) Figure 2.3: Opção para baixar o RStudio Desktop. Clique na sua plataforma (de acordo com seu SO, arquitetura e versão da distribuição) (Figura 2.4), no exemplo deste livro RStudio 1.1.447 - Ubuntu 12.04-15.10/Debian 8 (64-bit) Figure 2.4: Escolha da plataforma em que será o usada o RStudio Desktop. Dependendo da sua versão Ubuntu, ao clicar sobre o sobre o arquivo baixado com o botão direito, há a opção de abrir com Ubuntu Software Center e então clicar em instalar. Se na versão de seu Desktop não há esta opção ao clicar com botão direito sobre o arquivo, instale via terminal6 com os seguintes comandos: $ cd /local/do/arquivo/baixado $ sudo dpkg -i arquivoBaixado.deb $ sudo apt-get install -f Abra o RStudio digitando no terminal: $ rstudio &amp; Agora você está pronto para começar a programar em aproveitando as facilidades que o RStudio oferece. digite ‘Ctrl+Alt+t’ para abrir um terminal no Linux Ubuntu↩ "],
["iu.html", "3 Interface do Usuário", " 3 Interface do Usuário Na maior parte do tempo você provavelmente usará o no modo interativo: rodando comandos e vendo os resultados. Eventualmente esse processo pode ser inconveniente. Por exemplo, no caso de uma análise com um código bem extenso e que precisa ser repetida com dados atualizados semanalmente. Nessa situação, recomenda-se a criação de um script, ou seja, um arquivo texto, com a extensão .R, contendo o código de sua análise. Esse script pode ser executado pelo R no modo de processamento em lote (do termo em inglês Batch Processing) através de um terminal do SO Linux, ou via o Prompt de comando (cmd.exe) do SO Windows. Nesta seção apresenta-se ao leitor estes dois modos de execução do . "],
["no-modo-interativo.html", "3.1 no modo interativo", " 3.1 no modo interativo No Linux o pode ser aberto simplesmente digitando em um terminal a letra R. $ R R version 3.4.4 (2018-03-15) -- &quot;Someone to Lean On&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. Natural language support but running in an English locale R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R. &gt; A janela com a linha de comando do apresenta o prompt do (&gt;). Após este símbolo digitamos os comandos, pressionamos a tecla &lt;enter&gt;, o interpreta o comando e retorna o resultado. Os comandos digitados na linha de comando são chamados de expressões. Esse é o modo iterativo do . Portanto, a linha de comando é a mais importante ferramenta do , pois todas expressões são avaliadas através dela. &gt; 62 + 38 [1] 100 A expressão é avaliada pelo , o resultado é mostrado, mas o seu valor é perdido. O número entre colchetes que aparece como resultado da operação (“[1]” no caso acima) indica o conteúdo resultante da operação iniciando na posição 1 desse objeto. O significado dessa informação torna-se mais óbvio quando trabalhamos com objetos maiores, como por exemplo com vetores. Observe os valores nos colchetes para uma sequência de 100 até 1. &gt; 100:1 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 O elemento [18] da sequência de 100 até 1 é o número 83. Pode ocorrer da expressão digitada na linha ser muito extensa e ir além de uma linha. Se a expressão estiver incompleta o mostra um sinal de +. &gt; 1 * 2 * 3 * 4 * 5 * + 6 * 7 * 8 * 9 * 10 [1] 3628800 Execute a expressão abaixo até o sinal de menos e tecle &lt;enter&gt;. Enquanto a expressão não estiver completa o sinal de + se repetirá. Até que você digite o número que deseja subtrair de 4. &gt; 4 - + + 3 [1] 1 3.1.1 Expressões em sequência Podemos executar todas expressões anteriores em apenas uma linha, usando o ponto e vírgula ; para separar as expressões: &gt; 62 + 38; 100:1; 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10; 4 - 3 [1] 100 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 [1] 3628800 [1] 1 3.1.2 Navegação entre as expressões já avaliadas Você pode usar as teclas ⬆️ e ⬇️ para navegar entre as expressões já avaliadas pelo . O que é útil quando precisamos repetir um comando anterior com alguma mudança ou para corrigir um erro de digitação ou a omissão de um parentêses. Quando a linha de comando é usada por muito tempo a sua tela pode ficar poluída com a saída das expressões anteriores. Para limpar a tela, tecle Ctrl+l. Assim o console aparece na parte superior do terminal. &gt; 15 + 4 [1] 19 &gt; 100:1 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 &gt; #tecle &lt;Ctr + l&gt; Para parar ou cancelar a execução de uma expressão utilize as teclas Ctrl + C. As teclas Ctrl + l tem o efeito de limpar a tela. 3.1.3 Comentários No , a cerquilha # (hashtag) é um caracter especial. Qualquer coisa após esse caracter será ignorada pelo . Somente as expressões antes da # são avaliadas. Por meio desse símbolo de comentário podemos fazer anotações e comentários no código sem atrapalhar a interpretação das expressões pelo . &gt; # comentário antes do código &gt; 17 + 3 # comentário ao lado do código: adicionando 17 e 3 [1] 20 3.1.4 Auto preenchimento de funções O inclui o preenchimento automático de nomes de funções e arquivos por meio da tecla &lt;tab&gt;. Uma lista de possíveis funções que começam com as letras inicialmente digitadas aparecerão. &gt; read#&lt;tab&gt; pressione &lt;tab&gt; para ver as opções de comandos que iniciam com o termo read Figure 3.1: Auto preenchimento de código na linha de comandos do R. 3.1.5 Primeiro script O trecho de código abaixo apresenta nas primeiras linhas algumas expressões do executadas anteriormente. Mas há também, na segunda parte, códigos para salvar um gráfico de pontos num arquivo pdf. Na última parte do trecho, define-se uma variável x que contém aquela mesma sequência numérica usada no gráfico. # Primeiro script no R #---------------------------------------------------------------- # cálculos básicos 15 + 4 1:100 1 * 2 * 3 * 4 * 5 *6 * 7 * 8 * 9 * 10 4-3 #---------------------------------------------------------------- # salvando um gráfico em um arquivo pdf arquivo_pdf &lt;- &quot;plot-script1.pdf&quot; pdf(arquivo_pdf) # cria e abre um arquivo pdf plot(1:100) # faz o gráfico dev.off() # fecha o arquivo pdf #---------------------------------------------------------------- # definindo uma variável x x &lt;- 1:100 x Este conjunto de linhas de código, quando inseridos em um arquivo texto7 formam um primeiro script . Este script pode ser executado pelo através da função source(), usando como argumento o caminho para o local do script. &gt; source(&quot;/home/usuario/adar/script1.R&quot;) Este script produzirá como saída o arquivo /home/usuario/adar/plot-script1.pdf. Você pode visualizar o arquivo para conferir o gráficos de pontos gerado. Para fazer isso, você pode usar um editor de texto qualquer (p.ex.: gedit no SO Linux, ou Notepad no SO Windows).↩ "],
["no-modo-de-processamento-em-lote.html", "3.2 no modo de processamento em lote", " 3.2 no modo de processamento em lote Para rodar um script no modo de processamento em lote do através do seguinte comando no terminal Linux: $ R CMD BATCH opcoes arqentrada arqsaida Onde: arqentradaé o nome do script (arquivo com a extensão .R) a ser executado; arqsaida é o arquivo (com a extensão .Rout) com as saídas dos comandos executados no R; opcoes é a lista de opções que controlam a execução. Vamos rodar como exemplo, o script1.R da seção 3.1.5. $ R CMD BATCH /home/usuario/adar/script1.R O comando acima, produzirá dois arquivos de saída: script1.Rout8 criado por default quando o arqsaida não é especificado, e; arquivo &quot;plot-script1.pdf&quot;. Você pode especificar o nome do arqsaida como desejar. No exemplo abaixo, mostra-se como salvar o arquivo de saída incluindo a data em que ele foi gerado, script1-saida-adatadehoje.log. $ R CMD BATCH script1.R script1-saida-`date &quot;+%Y%m%d&quot;`.log Após a execução do último comando, os mesmos arquivos resultantes do comando anterior serão gerados, exceto pelo primeiro (.Rout), que será nomeado script1-saida-20180423.Rout. Para mais opções do comando R CMD BATCH digite no terminal do Linux R --help. Você pode notar que este arquivo tem o mesmo nome do arqentrada, exceto que a sua extensão foi alterada para .Rout.↩ "],
["rstudio.html", "4 RStudio", " 4 RStudio O RStudio Desktop é um ambiente integrado de desenvolvimento (IDE) para o . Portanto, o RStudio depende da instalação prévia do . Ele funciona como uma interface gráfica do usuário (GUI), mas com muito mais potencialidades. O RStudio é uma ferramente que potencializará sua interação com o : na produção de gráficos na organização de seu código na forma de projetos na reprodutibilidade de seu trabalho ou pesquisa na manutenção e criação de seus próprios pacotes do R na criação e compartilhamento de seus relatórios no compartilhamento de seu código e a colaboração com outros Nessa seção você terá uma visão geral do RStudio Desktop. "],
["visao-geral-do-rstudio.html", "4.1 Visão geral do RStudio", " 4.1 Visão geral do RStudio Assumindo que o RStudio tenha sido instalado (seção 2.3), ao abri-lo e clicar em File &gt; New File &gt; R script você verá uma tela com aspecto similar ao da Figura 4.1. Figure 4.1: Rstudio O RStudio possui 4 painéis principais: Editor para scripts e visualização de dados abrir e criar scripts rodar scripts código com sintaxe realçada rodar partes do código &lt;Ctrl+enter&gt; rodar todo script &lt;Ctrl+Shift+S&gt; autopreenchimento das funções &lt;tab&gt; comentar linhas &lt;Ctrl+Shift+C&gt; desfazer &lt;Ctrl+Z&gt; refazer &lt;Ctrl+Shift+Z&gt; referência para teclas de atalho &lt;Alt+Shift+K&gt; abrir script com &lt;Ctrl+Click&gt; encontrar e substituir Ctrl+F Console do R Navegador do espaço de trabalho e histórico de comandos Arquivos/Plots/Pacotes/Ajuda/Visualizador Configuração de texto e painéis em: Menus Tools &gt; global Options &gt; Appearance mostrar linhas, alterar realce da sintaxe Session Plots Para saber mais sobre os recursos fornecidos pelo RStudio assista ao vídeo RStudio Essencials. Isso o ajudará a usar mais efetivamente o RStudio. Folha de referência do RStudio Figure 4.2: Folha de referência do RStudio, disponível em https://www.rstudio.com/wp-content/uploads/2016/03/rstudio-IDE-cheatsheet-portuguese.pdf "],
["operbasic.html", "5 Operações básicas", " 5 Operações básicas Nesta seção veremos: operações aritméticas básicas com R a atribuição de valores a uma variável o uso de funções matemáticas internas do R valores numéricos especiais do R os cuidados ao nomear variáveis "],
["convencao.html", "5.1 Convenção", " 5.1 Convenção A partir deste capítulo, os códigos a serem avaliadas no R terão o prompt do R (&gt;) omitidos. Essa convenção é para tornar mais fácil a ação de copiar e colar os códigos na linha de comando do R. O resultado da avaliação das expressões será mostrado precedido do símbolo (#&gt;). Esses valores são os resultados que esperam-se sejam reproduzidos pelo leitor na sessão do R em seu computador. Por exemplo: 1:5 #&gt; [1] 1 2 3 4 5 No trecho de código acima, a primeira linha contém o código a ser copiado pelo leitor para execução em seu computador. A segunda linha é a saída do código avaliado pelo R. "],
["calculadora.html", "5.2 Calculadora", " 5.2 Calculadora O R é uma calculadora turbinada com diversas funções matemáticas disponíveis. Para quem não conhece o R, essa uma forma de familiarizar-se com a linha de comandos do R. 5.2.1 Aritmética básica Todas operações feitas em uma calculadora podem ser realizadas na linha de comandos do R. 10 + 2 + 4 #&gt; [1] 16 # Exemplo de divisao (5 + 14)/2 #&gt; [1] 9.5 # exponenciação 2^3 #&gt; [1] 8 4^0.5 #&gt; [1] 2 # operador artimético para se determinar o resto de uma divisao 10 %% 2 #&gt; [1] 0 2001 %% 2 #&gt; [1] 1 # o inteiro do quociente 11 %/% 2 #&gt; [1] 5 Note que no R, o separador decimal é o ponto “.”, ao invés da vírgula “,” usada na notação brasileira. As vírgulas tem a finalidade de separar os argumentos nas chamadas de funções, tal como em log(x = 10, base = 10). Conheça mais operadores aritméticos, digitando na linha de comando: ?&quot;Arithmetic&quot; A janela que se abrirá mostrará o texto que faz parte do manual de ajuda do R. 5.2.2 Constantes O R possui algumas constantes pré-definidas, como o a constante pi (\\(\\pi\\)). pi #&gt; [1] 3.141593 O R também tem vetores de caracteres pré-definidos, são eles: LETTERS #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; #&gt; [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; month.abb #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; #&gt; [12] &quot;Dec&quot; month.name #&gt; [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; #&gt; [6] &quot;June&quot; &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; #&gt; [11] &quot;November&quot; &quot;December&quot; Note que caracteres estão sempre entre aspas: &quot;&quot;. “caracteres são entre aspas” aeiou #&gt; Error in eval(expr, envir, enclos): object &#39;aeiou&#39; not found &quot;aeiou&quot; #&gt; [1] &quot;aeiou&quot; 5.2.3 Funções matemáticas internas Existem diversas funções internas do R que permitem, por exemplo, sortear números aleatóriamente, arrendondar números, calcular o fatorial, calcular o seno, cosseno de um ângulo e etc. A sintaxe para chamar uma função no R é: funcão(argumento) Por exemplo: # funções trigonométricas sin(pi/6) #&gt; [1] 0.5 cos(pi) #&gt; [1] -1 # raiz quadrada sqrt(100) #&gt; [1] 10 # exponencial exp(1) #&gt; [1] 2.718282 # fatorial factorial(4) #&gt; [1] 24 No R você verá que parênteses são frequentemente utilizados. Eles são sempre associados à funções. Qualquer palavra antecedendo um parênteses é uma função. Para ver a lista completa de funções trigonométricas: ?&quot;Trig&quot; 5.2.4 Valores numéricos especiais Um caso particular sobre operação aritméticas no R, são os valores numéricos Infe NaN que resultam de operações como: 2/0 #&gt; [1] Inf -12/0 #&gt; [1] -Inf exp(-Inf) #&gt; [1] 0 log(0) #&gt; [1] -Inf 0/Inf #&gt; [1] 0 (0:3)^Inf #&gt; [1] 0 1 Inf Inf log(-0.5) #&gt; Warning in log(-0.5): NaNs produced #&gt; [1] NaN sqrt(-1) #&gt; Warning in sqrt(-1): NaNs produced #&gt; [1] NaN 0/0 #&gt; [1] NaN Inf-Inf #&gt; [1] NaN Inf/Inf #&gt; [1] NaN mean(c(NA, NA), na.rm = TRUE) #&gt; [1] NaN NaN é a abreviação para Not a Number. Geralmente surge quando um cálculo não tem sentido matemático ou não pode ser propriamente realizado. A demonstração das diferentes formas de se obter essas constantes especiais é importante para entender a origem delas durante a execução de um script mais extenso. Outra constante especial do R é o NA (Not Available) que representa valor faltante, um problema comum em análise de dados. Qualquer operação envolvendo NA resultará em NA (Tabela 1). Table 5.1: Tabela 1. Operações com NA. operação resultado NA + 5 NA sqrt(NA) NA NA^2 NA NA/NaN NA 5.2.5 Notação científica e número de dígitos Na maioria das vezes precisamos trabalhar com números grandes e consequentemente acabamos usando uma notação científica ou exponencial. No R há diferentes formas de representar números com expoentes: 1.2e-6 #&gt; [1] 1.2e-06 # expressões equivalentes 1.2E6; 1.2*10^6 #&gt; [1] 1200000 #&gt; [1] 1200000 Os resultados dos cálculos no R são mostrados com 7 dígitos significativos, o que pode ser verificado pela getOptions(). É possível mudar para n dígitos usando a função options(), conforme exemplo abaixo. # opção de dígitos padrão getOption(&quot;digits&quot;) #&gt; [1] 7 exp(1) #&gt; [1] 2.718282 # alterando para 14 options(digits = 14) exp(1) #&gt; [1] 2.718281828459 getOption(&quot;digits&quot;) #&gt; [1] 14 # redefinindo para o número de casas decimais padrão options(digits = 7) getOption(&quot;digits&quot;) #&gt; [1] 7 "],
["variaveis.html", "5.3 Variáveis", " 5.3 Variáveis 5.3.1 Formas de atribuição 5.3.1.1 Variável recebe valor Até agora nós usamos expressões para fazer uma operação e obter um resultado. O termo &quot;expressão&quot; significa uma sentença de código que pode ser executada. Se a avaliação de uma expressão é salva usando o operador &lt;-, esta combinação é chamada &quot;atribuição&quot;. O resultado da &quot;atribuição&quot; é armazenado em uma variável e pode ser utilizado posteriormente. Então uma variável é um nome usado para guardar os dados. variavel &lt;- valor p &lt;- 1013 # para mostrar a variável digite o nome da variável p #&gt; [1] 1013 # ou use a função print() print(p) #&gt; [1] 1013 O R diferencia letras maiúsculas de minúsculas. Portanto p e P são variáveis diferentes. p #&gt; [1] 1013 P #&gt; Error in eval(expr, envir, enclos): object &#39;P&#39; not found Como criamos apenas a variável p, P não foi encontrada. A variável p pode ser utilizado para criar outras variáveis. p_pa &lt;- p * 100 # pressão em Pascal p_pa #&gt; [1] 101300 A seta de atribuição pode ser usada em qualquer sentido. Parênteses, além de estarem sempre acompanhando uma função, também são usados para indicar a prioridade dos cálculos. 7/3 + 0.6 -&gt; y1 y1 #&gt; [1] 2.933333 7/(3 + 0.6) -&gt; y2 y2 #&gt; [1] 1.944444 Os espaços em torno do símbolo de atribuição (&lt;-) não são obrigatórios mas eles ajudam na legibilidade do código. x &lt;- 1 x &lt; -1 # atribuição ou menor que? x&lt;-1 Vamos criar uma variável chamada ndias3 que recebe o nº de dias no mês de Março e ndias4 que recebe o nº de dias no mês de Abril. nd3 &lt;- 31 nd4 &lt;- 30 O total de dias nos meses de março e abril será armazenado na variável totdias: totd &lt;- nd3 + nd4 totd #&gt; [1] 61 A atribuição de um mesmo valor para diferentes variáveis pode ser feita da seguinte forma: # número de dias em cada mês jan &lt;- mar &lt;- mai &lt;- jul &lt;- ago &lt;- out &lt;- dez &lt;- 31 abr &lt;- jun &lt;- set &lt;- nov &lt;- 30 fev &lt;- 28 # verificação jan; jul #&gt; [1] 31 #&gt; [1] 31 jun; set #&gt; [1] 30 #&gt; [1] 30 fev #&gt; [1] 28 Nós estamos definindo a variável, digitando o nome dela na linha de comando e teclando enter para ver o resultado. Há uma forma mais prática de fazer isso e mostrar o resultado cercando a atribuição por parênteses: # ao invés de # tar &lt;- 20 # tar # é mais prático (tar &lt;- 20) #&gt; [1] 20 Se desejamos calcular e já visualizar o valor da pressão de vapor de saturação obtida com a equação de Tetens, podemos fazer: (es &lt;- 0.611 * exp((17.269 * tar)/(tar + 237.3))) #&gt; [1] 2.338865 Quando usamos a mesma variável numa sequência de atribuições o seu valor é sobrescrito. Portanto não é bom usar nomes que já foram usados antes, exceto se a intenção for realmente essa. Para saber os nomes das variáveis já usados use a função ls()9 para verificar as variáveis existentes: ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;fev&quot; &quot;jan&quot; #&gt; [7] &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; &quot;nd4&quot; #&gt; [13] &quot;nov&quot; &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; &quot;pcks&quot; #&gt; [19] &quot;rblue&quot; &quot;set&quot; &quot;tar&quot; &quot;totd&quot; &quot;y1&quot; &quot;y2&quot; totd &lt;- jan*7; totd &lt;- totd + fev; totd &lt;- totd + 4*abr totd #&gt; [1] 365 5.3.1.2 Atribuição com a função assign() Outra forma de atribuição é através da função assign(): es #&gt; [1] 2.338865 assign(x = &quot;es_hpa&quot;, value = es/10) es_hpa #&gt; [1] 0.2338865 # usando função assign sem nome dos parâmetros assign(&quot;u&quot;, 2.5) u #&gt; [1] 2.5 Um exemplo mais elaborado de uso da função assign() para criar várias variáveis pode ser visto aqui. 5.3.2 Removendo variáveis Para remover variáveis usa-se a função rm(). # lista de variáveis existentes ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;es_hpa&quot; &quot;fev&quot; #&gt; [7] &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; #&gt; [13] &quot;nd4&quot; &quot;nov&quot; &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; #&gt; [19] &quot;pcks&quot; &quot;rblue&quot; &quot;set&quot; &quot;tar&quot; &quot;totd&quot; &quot;u&quot; #&gt; [25] &quot;y1&quot; &quot;y2&quot; Vamos remover a variável u criada previamente e ver a lista de objetos no espaço de trabalho. rm(u) # lista de variáveis existentes, sem u ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;es_hpa&quot; &quot;fev&quot; #&gt; [7] &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; #&gt; [13] &quot;nd4&quot; &quot;nov&quot; &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; #&gt; [19] &quot;pcks&quot; &quot;rblue&quot; &quot;set&quot; &quot;tar&quot; &quot;totd&quot; &quot;y1&quot; #&gt; [25] &quot;y2&quot; Podemos remover mais de uma variável ao mesmo tempo. rm(es_hpa, es, tar, y1, y2) # lista de variáveis existentes, sem es_hpa, es, tar, y1, y2 ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;fev&quot; &quot;jan&quot; &quot;jul&quot; #&gt; [7] &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; &quot;nd4&quot; &quot;nov&quot; #&gt; [13] &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; &quot;pcks&quot; &quot;rblue&quot; #&gt; [19] &quot;set&quot; &quot;totd&quot; Para remover todas variáveis do espaço de trabalho (use com cautela): # apagando tudo rm(list = ls()) ls() #&gt; character(0) 5.3.3 Nomeando variáveis É preciso ter cuidado ao nomear variáveis no R porque existem algumas regras: não iniciar com um número e não conter espaços 1oAno &lt;- 1990 raizDe10 &lt;- srt(2) variavel teste &lt;- 67 # nomes alternativos para as variaveis ano1 &lt;- 1990 variavel_teste &lt;- 67 variavel.teste &lt;- 68 não conter símbolos especiais: ^, !, $, @, +, -, /, ou * dia-1 &lt;- 2 #&gt; Error in dia - 1 &lt;- 2: object &#39;dia&#39; not found # alternativa dia_1 &lt;- 2 evitar o uso de nomes usados em objetos do sistema (funções internas do R ou constantes como o número \\(\\pi\\)): c q s t C D F I T diff exp log mean pi range rank var FALSE Inf NA NaN NULL TRUE break else for function if in next repeat while variáveis com acento são permitidas mas não recomendadas. verão &lt;- &quot;DJF&quot; verão #&gt; [1] &quot;DJF&quot; Há limitações de interpretação do R para caracteres latinos como cedilha e acentos. Por isso não recomenda-se o uso destes caracteres para nomear variáveis. Uma boa prática de programação é dar nomes informativos às variáveis para maior legibilidade do código. Uma boa referência para isso é a seção Sintaxe do Guia de estilo tidyverse (ou universo arrumado). Apesar do ganho de legibilidade do código com a aplicação das regras de formatação de código do tidyverse é difícil de lembrar de todas elas. Mas este não é mais um problema, pois o pacote styler fornece funções para estilizar o seu código padrão tidyverse. install.packages(&quot;styler&quot;) library(styler) As funções são acessíveis Através do menu Addins do RStudio e incluem as opções de: estilizar um arquivo e uma região destacada do código. Essa lista de variáveis também é mostrada no painel Environment do RStudio (canto direito superior, aba Environment).↩ "],
["datatype.html", "6 Tipos de dados", " 6 Tipos de dados Nesta seção vamos: conhecer os tipos de dados mais usados no R descobrir qual é o tipo de dado de uma variável aprender a fazer testes com operadores lógicos saber como converter uma variável de um tipo para outro faltando: fórmulas factor "],
["classes-de-dados.html", "6.1 Classes de dados", " 6.1 Classes de dados Existem vários classes de dados no R. As mais utilizadas são: numeric (números) character (sequência de caracteres) logical (TRUE/FALSE) Date (datas) POSIXct (datas e horários) A classe dos dados de um objeto é verificada com a função class(). &gt; x &lt;- 51 &gt; class(x) [1] &quot;numeric&quot; 6.1.1 numeric É a classe de objeto mais usada. Essa classe é similar a float ou double em outras linguagens. Ela trata de inteiros e decimais, positivos e negativos e zero. Um valor numérico armazenado em um objeto é automaticamente assumido ser numérico. Para testar se um objeto é numérico usa-se a função is.numeric(). &gt; is.numeric(x) [1] TRUE &gt; is.numeric(pi) [1] TRUE Outro tipo é o integer (inteiro), ou seja não há parte decimal. Para definir um objeto como inteiro é necessário acrescentar ao valor numérico um L. Analogamente, uma forma de verificação se o objeto é inteiro é através função is.integer(). &gt; i &lt;- 3L &gt; is.integer(i) [1] TRUE &gt; is.integer(pi) [1] FALSE Mesmo com o objeto i sendo inteiro, ele também passa na verificação is.numeric(). &gt; is.numeric(i) [1] TRUE O R converte inteiros para numéricos quando necessário. Vamos usar a função typeof() para determinar o tipo de dado e as conversões que o R faz. Por exemplo: &gt; ## integer * numeric &gt; typeof(5L) [1] &quot;integer&quot; &gt; typeof(4.5) [1] &quot;double&quot; &gt; (prod_i &lt;- 5L * 4.5) [1] 22.5 &gt; typeof(prod_i) [1] &quot;double&quot; &gt; ## integer/integer &gt; typeof(5L) [1] &quot;integer&quot; &gt; typeof(2L) [1] &quot;integer&quot; &gt; typeof(5L/2L) [1] &quot;double&quot; &gt; # número complexo &gt; typeof(3 + 2i) [1] &quot;complex&quot; 6.1.2 character O tipo de dado character (string) é bastante utilizado e deve ser manipulado com cuidado. No R há duas principais formas de lidar com caracteres: a função character() e factor(). Embora pareçam similares eles são tratados de forma diferente. &gt; (char &lt;- &quot;Vai chover hoje?&quot;) [1] &quot;Vai chover hoje?&quot; &gt; charf &lt;- factor(&quot;Vai chover hoje?&quot;) &gt; charf [1] Vai chover hoje? Levels: Vai chover hoje? &gt; levels(charf) [1] &quot;Vai chover hoje?&quot; &gt; ordered(charf) [1] Vai chover hoje? Levels: Vai chover hoje? char contém as palavras &quot;Vai chover hoje?&quot;, enquanto, charf tem as mesmas palavras porém sem as aspas e a segunda linha de informação sobre os níveis (levels) de charf. Nós veremos esse tipos de dado futuramente em vetores. Lembre-se que caracteres em letras minúsculas e maiúsculas são coisas diferentes no R. Para encontrar o tamanho de um character usamos a função nchar(). &gt; nchar(char) [1] 16 &gt; nchar(&quot;abc&quot;) [1] 3 Esta função não funcionará para um objeto do tipo factor. &gt; nchar(charf) Error in nchar(charf): &#39;nchar()&#39; requires a character vector 6.1.3 logical logical (lógico) é uma forma de representar dados que podem assumir valores booleanos, isto é, TRUE (verdadeiro) ou FALSE (falso). &gt; # variável lógica &gt; vl &lt;- FALSE Então em operações aritméticas envolvendo dados lógicos eles serão convertidos numericamente para 1 (TRUE) e 0 (FALSE). &gt; vl * 5 [1] 0 &gt; TRUE * 5 [1] 5 &gt; TRUE + TRUE [1] 2 &gt; FALSE - TRUE [1] -1 Assim como as outras classes de dados existem funções para verificar a classe de dados lógicos. &gt; class(vl) [1] &quot;logical&quot; &gt; is.logical(vl) [1] TRUE O R aceita as abreviaturas T e F para representar TRUE e FALSE, respectivamente, mas não é recomendado usá-las, conforme exemplo abaixo. TRUE [1] TRUE T [1] TRUE class(T) [1] &quot;logical&quot; T &lt;- 10 class(T) [1] &quot;numeric&quot; Valores lógicos resultam da comparação de números ou caracteres. &gt; 4 == 3 # 4 é idêntico a 3? [1] FALSE &gt; teste2i2 &lt;- 2*2 == 2+2 &gt; teste2i2 [1] TRUE &gt; teste2d2 &lt;- 2*2 != 2+2 # operador: diferente de &gt; teste2d2 [1] FALSE &gt; 4 &lt; 3 [1] FALSE &gt; 4 &gt; 3 [1] TRUE &gt; 4 &gt;= 3 &amp; 4 &lt;= 5 [1] TRUE &gt; 4 &lt;= 3 | 4 &lt;= 5 [1] TRUE &gt; &quot;abc&quot; == &quot;defg&quot; [1] FALSE &gt; &quot;abc&quot; &lt; &quot;defg&quot; [1] TRUE &gt; nchar(&quot;abc&quot;) &lt; nchar(&quot;defg&quot;) [1] TRUE Table 6.1: Tabela 1. Operadores Lógicos Operador Descrição &lt; menor que &lt;= menor ou igual a &gt; maior que &gt;= maior ou igual == idêntico != diferente !x não é x (negação) x | y x ou y x &amp; y x e y isTRUE(x) teste se x é verdadeiro %in% está contido em 6.1.4 Date Lidar com datas e horários pode ser difícil em qualquer linguagem e pode complicar mais ainda quando há diversas opções de classes de datas disponíveis, como no R. As mais úteis são: Date POSIXct Date armazena apenas a data enquanto POSIXct armazena a data e o horário. Ambos dados são representados como o número de dias (Date) ou segundos (POSIXct) decorridos desde 1 de Janeiro de 1970. &gt; data1 &lt;- as.Date(&quot;2012-06-28&quot;) &gt; data1 [1] &quot;2012-06-28&quot; &gt; class(data1) [1] &quot;Date&quot; &gt; as.numeric(data1) [1] 15519 &gt; data2 &lt;- as.POSIXct(&quot;2012-06-28 17:42&quot;) &gt; data2 [1] &quot;2012-06-28 17:42:00 UTC&quot; &gt; class(data2) [1] &quot;POSIXct&quot; &quot;POSIXt&quot; &gt; as.numeric(data2) [1] 1340905320 A manipulação de dados da classe de datas e horários (Date-time) torna-se mais versátil através dos pacotes lubridate e chron, o que será visto posteriormente no curso. Funções como as.numeric() e as.Date() não apenas mudam o formato de um objeto mas muda realmente a classe original do objeto. &gt; class(data1) [1] &quot;Date&quot; &gt; class(as.numeric(data1)) [1] &quot;numeric&quot; "],
["testes-sobre-tipos-de-dados.html", "6.2 Testes sobre tipos de dados", " 6.2 Testes sobre tipos de dados Além função typeof(), a família is.*() também permite descobrir o tipo de dado, p.ex.: is.numeric(), is.character() e etc. &gt; x; typeof(x) [1] 51 [1] &quot;double&quot; &gt; vl; typeof(vl) [1] FALSE [1] &quot;logical&quot; &gt; data1; typeof(data1) [1] &quot;2012-06-28&quot; [1] &quot;double&quot; &gt; x; is.numeric(x) [1] 51 [1] TRUE &gt; # num.real? &gt; is.double(x/5) [1] TRUE &gt; is.double(5L) [1] FALSE &gt; is.character(&quot;12.34&quot;) [1] TRUE &gt; charf; is.factor(charf) [1] Vai chover hoje? Levels: Vai chover hoje? [1] TRUE &gt; i; is.integer(i) [1] 3 [1] TRUE &gt; is.function(sqrt) [1] TRUE &gt; is.finite(i) [1] TRUE &gt; is.nan(x) [1] FALSE &gt; is.na(x) [1] FALSE "],
["conversao-entre-tipos-de-dados.html", "6.3 Conversão entre tipos de dados", " 6.3 Conversão entre tipos de dados Em algumas circunstâncias precisamos alterar o tipo de uma variável. A maioria das funções is.*() possui uma função as.*() correspondente de conversão para aquele tipo de dado. &gt; # de character para numeric &gt; as.numeric(&quot;12.34&quot;) [1] 12.34 &gt; # de factor para character &gt; as.character(charf) [1] &quot;Vai chover hoje?&quot; &gt; # character para factor &gt; as.factor(&quot;a&quot;) [1] a Levels: a &gt; # de double para integer &gt; typeof(x) [1] &quot;double&quot; &gt; typeof(as.integer(x)) [1] &quot;integer&quot; &gt; as.integer(x) == 51L [1] TRUE &gt; as.integer(&quot;12.34&quot;) [1] 12 &gt; # arredondamento &gt; as.integer(12.34) [1] 12 &gt; # lógico para inteiro &gt; as.integer(TRUE) [1] 1 &gt; # numérico para lógico &gt; as.logical(0:2) [1] FALSE TRUE TRUE &gt; # character para numérico? &gt; as.numeric(&quot;a&quot;) Warning: NAs introduced by coercion [1] NA &gt; # de character para date &gt; dt_char &lt;- &quot;2016-03-17&quot; &gt; dt &lt;- as.Date(dt_char) &gt; dt [1] &quot;2016-03-17&quot; &gt; # de character para date-time &gt; data_hora &lt;- as.POSIXct(&quot;2016-03-17 15:30:00&quot;) &gt; data_hora [1] &quot;2016-03-17 15:30:00 UTC&quot; "],
["referencias.html", "Referências", " Referências "]
]
