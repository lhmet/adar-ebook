[
["index.html", "Análise de Dados Ambientais com R Versão preliminar Apresentação", " Análise de Dados Ambientais com R Versão preliminar Jônatan Tatsch 2018-05-14 Apresentação Ilustração: The Project Twins Este material é uma composição das notas de aula da disciplina Análise de Dados Ambientais com do curso de Graduação em meteorologia oferecido no Departamento de Física da Universidade Federal de Santa Maria (UFSM). O livro é designado para quem não tem experiência em programação, ou qualquer um com interesse em aprender o para manipular dados ambientais. O objetivo é prover uma material para ensinar os conceitos básicos de programação necessários para o processamento, a visualização e a análise de dados ambientais com o sistema computacional . Estes procedimentos são potencializados com o uso do software RStudio, uma interface de desenvolvimento integrado (IDE) para o . Neste livro o leitor aprenderá a sintaxe básica da linguagem , a importação e exportação de dados, a criação de gráficos, funções, a padronização e organização de conjunto de dados ambientais; e finalmente, a confecção de relatórios dinâmicos e reproduzíveis. O material do livro inclui o uso de dados ambientais de diferentes áreas (meteorologia, climatologia, hidrologia, sensoriamento remoto) em exemplos práticos e em exercícios, para estimular a prática da programação. O texto é intercalado com trechos de códigos que podem ser reproduzidos e os resultados visualizados no computador do leitor. Após a introdução ao apresenta-se as capacidades específicas do para manipulação de dados. Baseado na experiência do autor são empregados os pacotes mais adequados para cada finalidade, como dplyr e tidyr para o processamento de dados e o ggplot2 para visualização de dados. A intenção do livro é que após a leitura, o leitor tenha o conhecimento suficiente para desenvolver códigos que automatizem tarefas repetitivas, assim reduzindo o tempo gasto na etapa de preparação de dados. Esta programação mais efetiva permitirá focar mais na análise de dados e na comunicação dos resultados, seja ela na forma de documentos acadêmicos, ou relatórios técnicos em empresas públicas e privadas. O texto está em formato html para tirar o melhor proveito de recursos de multimídia, da capacidade de busca de texto e links para websites. O texto é organizado em 7 capítulos: 1 Introdução 2 Instalação do e Rstudio 3 Interface do Usuário 4 Rstudio 5 Operações Básicas 6 Tipos de dados 7 Estruturas de dados 8 Entrada de dados A versão on-line deste livro está licenciada com uma Licença Creative Commons - Atribuição-NãoComercial-CompartilhaIgual 4.0 Internacional. "],
["intro.html", "1 Motivação", " 1 Motivação "],
["analise-de-dados-meteorologicos.html", "1.1 Análise de dados meteorológicos", " 1.1 Análise de dados meteorológicos Processo pelo qual adquire-se conhecimento, compreensão e percepção dos fenômenos meteorológicos a partir de observações (dados) qualitativas e quantitativas. "],
["ciencia-de-dados.html", "1.2 Ciência de dados", " 1.2 Ciência de dados "],
["etapas-para-abordagem-de-um-problema.html", "1.3 Etapas para abordagem de um problema", " 1.3 Etapas para abordagem de um problema Questão científica/problema Obtenção de dados: coleta/medida do(as) estado/condições da atmosfera Instrumentos e sensores Processamento de dados: download —&gt; limpeza —&gt; formatação —&gt; transformação —&gt; controle de qualidade ferramenta/software conhecimento em programação Análise de dados ferramenta/software conhecimento em programação Solução para o problema Proposta de um modelo estatístico, empírico, ou fisicamente baseado conhecimento em programação Apresentação/divulgação/publicação "],
["programacao-computacional.html", "1.4 Programação computacional", " 1.4 Programação computacional "],
["section.html", "1.5 ", " 1.5 R é o termo usado para se referir a linguagem de programação e ao software que interpreta os scripts escritos usando esta linguagem. Comunidade fantástica Contribuidores (R Core Team (2017)) milhares de pessoas usam o R diariamente e ajudam outras pessoas Software Livre (GPL), Código aberto e multiplataforma Ambiente para Análise de dados interativa References "],
["por-que-o-r.html", "1.6 Por que o R?", " 1.6 Por que o R? R não é uma GUI (Interface gráfica do usuário) e isso é bom há uma natural resistência e dificuldade ao uso de códigos e scripts scripts favorecem a automatização e reprodutibilidade força você a ter um conhecimneto mais aprofundado do que está fazendo Reprodutibilidade qualquer pessoa (inclusive você mesmo no futuro) pode obter os mesmos resultados do mesmo conjunto de dados R é integrado com outras ferramentas de que permitem atualizar seus resultados, figuras e análises automaticamente Relatório dinâmicos e interativos Acesso ao estado da arte da ciência de dados (Big Data, Data Mining, Machine Leraning) é um software livre, de código fonte aberto e funciona em diversos sistemas operacionais (Linux, Windows e MacOS). Interface com Fortran, C, C++, Python Visualização de dados R produz gráficos de alta qualidade R trabalha com dados de todas formas e tamanhos Extensões para Manipulação de dados "],
["pacotes-da-comunidade-do-r.html", "1.7 Pacotes da comunidade do R", " 1.7 Pacotes da comunidade do R Evolução do nº de pacotes disponíveis no CRAN "],
["por-que-um-meteorologista-usaria-o-r.html", "1.8 Por que um meteorologista usaria o R?", " 1.8 Por que um meteorologista usaria o R? A meteorologia é 4D: meteorologia &lt;- function(x, y, z, t){ ...muita coisa para caber em um slide... } Logo, requer ferramentas específicas para: manipulação de dados espacias análise de séries temporais importação e ferramentas de SIG leitura de dados em formatos específicos (netcdf, binários, grib2, …) "],
["r-nao-e-perfeito.html", "1.9 R não é perfeito!", " 1.9 R não é perfeito! Muitos códigos em R são escritos para resolver um problema; foco nos resultados e não no processo usuários não são programadores códigos deselegantes, lentos e difíceis de entender Como o nosso idioma, há muitas exceções para serem lembradas R não é muito rápido e códigos mal escritos serão lentos São apenas ~20 anos de evolução Há muito o que melhorar "],
["para-saber-mais-sobre-o-r.html", "1.10 Para saber mais sobre o R", " 1.10 Para saber mais sobre o R Documentação oficial - Manuais do R traduzidos Lista de Livros relacionados ao R Livros gratuitos (em inglês) Fóruns: lista Brasileira de discussão do programa R: R-br stackoverflow "],
["install.html", "2 Instalação do R e RStudio", " 2 Instalação do R e RStudio A interação do usuário com o é por meio da linha de comando. Essa interação pode ser facilitada com o uso do software RStudio Desktop. A seguir descreve-se como: instalar o no Windows e no Linux Ubuntu manter o sempre atualizado no Linux Ubuntu configurar um diretório para armazenar os pacotes do R instalados instalar pacotes do instalar o Rstudio Desktop Neste livro, o maior foco na instalação do é dada para o SO Linux Ubuntu, pelo fato de assim como o R, ser um software livre e de código aberto. Como o Linux Ubuntu é baseado no Debian o procedimento de instalação também se estende a essa distribuição Linux e as versões derivadas do Ubuntu oficialmente reconhecidas. A instalação no SO Windows é igual a instalação de qualquer outro software e pode ser facilmente encontrada na internet. Por esta razão, somente indicou-se o caminho de instalação, sem as instruções detalhadas de instalação para este SO. Ao instalar R e RStudio recomenda-se optar por instalar na língua inglesa. Assim quando surgir uma mensagem de erro durante o uso do software, basta usá-la numa pesquisa na internet para solucionar o problema. As chances de resolver o problema serão muito maiores se sua pesquisa for realizada em inglês. "],
["instalando-o.html", "2.1 Instalando o ", " 2.1 Instalando o O pode ser instalado a partir dos binários pré-compilados ou do código fonte. Aqui, descreve-se a instalação do a partir dos arquivos binários. 2.1.1 Windows O binário executável do para o Windows está disponível na Rede Abrangente de Arquivos do (CRAN) e pode ser baixado aqui. Abra o executável e siga instruções de instalação do R mantendo todas as opções padrões. No Windows a instalação do inclui uma Interface Gráfica do Usuário (GUI) acessível pelo executável RGui.exe (Figura 2.1). Um atalho para esse executável é gerado por default na área de trabalho com o símbolo do . Figure 2.1: Interface gráfica do usuário no R para Windows. 2.1.1.1 Atualização do no Windows Novas versões do R são disponibilizadas em geral com frequência de 5 vezes por ano. Recomenda-se manter o R atualizado, pois as novas versões incluem aperfeiçoamentos e a correção de bugs. As novas versões do vem com os pacotes padrões do R. Os demais pacotes instalados pelo usuário na versão anterior precisam ser reinstalados na nova versão do . Para atualizar o no Windows, ao invés de baixar o executável a cada nova versão e repetir o processo da seção anterior, você pode utilizar o pacote installr. A instalação de pacotes no será vista na seção 2.2. 2.1.2 Linux 2.1.2.1 Ubuntu Há várias formas de instalar o no Ubuntu, mas geralmente a versão compilada no repositório default do Ubuntu não é a última. Se isso não for problema para você então basta executar: sudo apt-get install r-base Entretanto, os pacotes do recém lançados são compilados para última versão do . Então você pode ter restrições ao uso de pacotes novos, os quais geralmente incluem o estado da arte de análise de dados. Por esta razão, abaixo mostra-se como instalar o de forma que seja atualizado automaticamente pelo sistema. 2.1.2.2 R sempre atualizado Se você quer trabalhar sempre com a última versão estável do , é possível configurar o Linux Ubuntu para atualizar automaticamente o . O procedimento de instalação requer senha de superusuário do sistema ou de privilégios sudo. Caso não tenha, consulte o administrador do sistema. Ao utilizar distribuições Linux Ubuntu é importante optar por versões estáveis1. As versões de Suporte de longo prazo (LTS) mais recentes são: 14.04 (abril de 2014, codename trusty) 16.04 (abril de 2016, codename xenial) A versão mais atual é a R version 3.5.0 (2017-01-27). Para que ele seja atualizado automaticamente no Ubuntu você precisa adicionar o endereço do repósitório do R mais próximo de sua região à lista de repositórios do Linux. No exemplo deste livro, o repositório mais próximo é o da UFPR (http://cran-r.c3sl.ufpr.br/). 2.1.2.2.1 Incluindo repositório do na Lista de repositórios do Ubuntu A lista de repositórios do sistema é armazenada no arquivo /etc/apt/sources.list. Mas primeiro, você precisa descobrir ou verificar o nome da versão do sistema operacional. Para isso, você pode utilizar o seguinte comando2 : $ lsb_release --codename | cut -f2 trusty Precisamos incluir no arquivo sources.list o espelho do repositório do R mais próximo. Veja a lista de espelhos de repositórios do aqui. Assim o gerenciador de pacotes apt3 fará a atualização do quando uma nova versão estiver disponível. Ou seja, você estará utilizando sempre versão mais atual do . O endereço do repositório da UFPR será inserido na última linha do arquivo sources.list usando alguns comandos linux. Essa tarefa requer privilégios de superusuário. Vamos trocar do seu usuário para o superusuário. $ sudo su Vamos definir no terminal uma variável com o endereço do repositório (da UFPR nesse caso) e o nome de versão do Ubuntu. # repos=&quot;deb http://cran-r.c3sl.ufpr.br/bin/linux/ubuntu `lsb_release --codename | cut -f2`/&quot; Note que a variável repos é uma sequência de caracteres com as seguintes informações: deb `linkRepositorioSelecionado`/bin/linux/ubuntu `versaoUbuntu`/ O valor da variável repos é mostrado pelo comando: echo $repos. Certifique-se de que a última palavra corresponde ao nome da sua versão Ubuntu. Para acrescentar essa informação no final do arquivo sources.list digite no terminal linux: # echo $repos &gt;&gt; /etc/apt/sources.list Feito isso, você pode retornar a sessão de usuário comum, usando o comando abaixo: # exit 2.1.2.2.2 APT protegido Os arquivos binários do para Ubuntu na CRAN são assinados com uma chave pública4 Para adicionar essa chave ao seu sistema digite os seguintes comandos: $ gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys E084DAB9 e então use essa informação como entrada no apt-key com $ gpg -a --export E084DAB9 | sudo apt-key add - Se aparecer a mensagem de que a chave pública foi importada, então não há necessidade de executar os comandos abaixo. Mas caso seja impresso alguma mensagem de erro, outra alternativa pode ser usada para obter a chave, via os comandos: $ gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9 $ gpg -a --export E084DAB9 | sudo apt-key add - 2.1.2.2.3 Atualização da lista de repositórios do Ubuntu e instalação do Após fazer as configurações da lista de repositórios e adicionar a chave é necessário fazer a atualização dessa lista (requer poderes de super usuário): $ sudo apt-get update Agora, pode instalar o binário do R: $ sudo apt-get install r-base 2.1.2.2.4 Testando o Para iniciar o no Ubuntu, digite R no cursor do terminal: $ R A partir desse momento já começamos uma sessão no . Vamos gerar uma sequência numérica de 1 a 10 e plotá-la. &gt; 1:10 [1] 1 2 3 4 5 6 7 8 9 10 &gt; plot(1:10) Figure 2.2: Gráfico da sequência de 10 números. Você pode sair do , sem salvar os dados da seção, com o código a seguir: &gt; q(save = &quot;no&quot;) 2.1.2.3 Diretório para instalação de pacotes Uma boa prática é definir um diretório para armazenamento dos pacotes utilizados. Isso lhe dá mais controle sobre os pacotes do instalados no sistema. Um local sugerido é o /home/usuario/.R/libs. O seu home ou pasta pessoal pode ser obtido com o comando echo $HOME. Para criar o diretório você pode digitar o comando abaixo: $ mkdir -p `echo $HOME`/.R/libs/ Para informar ao onde procurar os pacotes instalados, você precisa criar um arquivo chamado .Renviron, no diretório $HOME, contendo a expressão R_LIBS=/home/usuario/.R/libs/. Você pode fazer isso em um terminal com os comandos: $ R_LIBS=`echo $HOME/.R/libs/` $ echo $R_LIBS &gt;&gt; `echo $HOME/.Renviron` Esse caminho fica então visível ao , o que pode ser verificado executando a função .libPaths() na linha de comando do . Abra o : $ R e ao digitar: &gt; .libPaths() [1] &quot;/home/travis/R/Library&quot; &quot;/usr/local/lib/R/site-library&quot; [3] &quot;/home/travis/R-bin/lib/R/library&quot; o seu diretório /home/usuario/.R/libs5 deve aparecer em primeiro lugar. Indicando que este local tem prioridade para instalação dos pacotes. Caso o diretório deixe de existir os seguintes diretórios serão usados. Clique aqui para saber mais sobre as versões do Ubuntu.↩ Se o comando lsb_release não funcionar você precisa instalar o pacote lsb-release no sistema. Para isso, digite no terminal Linux sudo apt-get install lsb-release.↩ o gerenciador de pacotes apt é usado para instalação, atualização e remoção de pacotes em distribuições Debian GNU/Linux.↩ Chave pública de autenticação é um meio alternativo de se logar em um servidor ao invés de digitar uma senha. É uma forma mais segura e flexível, mas mais difícil de ser configurada. Esse meio alternativo de fazer login é importante se o computador está visível na internet. Para saber mais veja aqui.↩ Diretórios precedidos por “.” no Linux são diretórios ocultos. O diretório /home/usuario/.R é um diretório oculto, para visualizá-lo no Ubuntu, na interface gráfica do sistema, acesse View &gt; Show Hidden Files (ou Visualizar &gt; Mostrar arquivos ocultos). No terminal utilize ls -a para listar os arquivos ocultos.↩ "],
["install-pck.html", "2.2 Pacotes do R", " 2.2 Pacotes do R Um pacote do R é uma coleção de funções, dados e documentação que estende as capacidades básicas do R. 2.2.1 Da internet 2.2.1.1 CRAN A forma mais fácil de instalar uma pacote do R é através da função install.packages(&quot;nome_do_pacote&quot;). Por default o pacote informado é instalado a partir da (CRAN) A seguir você verá como instalar um pacote. Como exemplo instalaremos o pacote remotes que dispões de funções para instalar pacotes de repositórios remotos, como por exemplo do GitHub. install.packages(&quot;remotes&quot;) Para ter acesso as funções disponibilizadas com o pacote você precisa carregar o pacote: library(remotes) Apesar de precisar só instalar uma vez um pacote, você precisará carregá-lo a cada nova sessão. Para desinstalar um pacote você pode usar a função remove.packages(&quot;nome_do_pacote&quot;). 2.2.1.2 GitHub e R-forge Nem todos pacotes são disponíveis na CRAN. Muitos desenvolvedores disponibilizam seus pacotes em plataformas como o GitHub e R-forge. As vezes um pacote pode estar em ambos CRAN e GitHub (ou R-forge), mas a última versão - a de desenvolvimento - é somente disponibilizada no GitHub (ou R-forge). Para instalar um pacote de um repositório do GitHub usa-se a função install_github() do pacote remotes. Portanto, o pacote remotes precisa ser sido instalado primeiro (ver seção 2.2.1.1). A função para instalar um pacote do GitHub requer como argumento o nome do usuário e do repositório. Por exemplo, para instalar o pacote inmetr do repositório mantido pelo lhmet, usa-se: # install.packages(&quot;devtools&quot;) # carrega o pacote devtools library(remotes) # instala o pacote inmetr do repositório # https://github.com/lhmet/inmetr install_github(&quot;lhmet/inmetr&quot;) Você pode acessar uma função de um pacote instalado com a forma especial pacote::funcao. O trecho de código anterior poderia ser reduzido a: remotes::install_github(“lhmet/inmetr”) Essa forma deixa explícito que estamos usando a função install_github() do pacote remotes. As vezes você pode estar com diversos pacotes carregados e eles podem ter funções de mesmo nome. Portanto essa é a alternativa mais segura de avaliar funções afim de evitar conflitos. Para instalar um pacote num repositório do R-forge, por exemplo o repositório do pacote raster, usa-se: install.packages( &quot;raster&quot;, repos = &quot;http://R-Forge.R-project.org&quot;, dependencies = TRUE ) Alguns pacotes as vezes dependem de outros pacotes e para lidar com essas dependências define-se o argumento dependencies = TRUE na função install.packages(), como no trecho de código anterior. A função automaticamente resolverá as dependências do pacote, de forma que qualquer pacote dependente também será instalado. 2.2.1.3 Arquivo fonte local Códigos fonte de pacotes do R são armazenados como arquivos com a extensão .tar.gz. Binários compilados são armazenados com a extensão .zip. Exemplo de arquivos como estes podem ser baixados manualmente da CRAN (veja a seção Downloads em https://cran.r-project.org/web/packages/ggplot2/index.html), GitHub ou R-forge. Eventualmente um usuário pode instalar um pacote a partir desses arquivos localmente. Isto pode também ser feito com a função install.packages(), especificando o argumento repos = NULL e o argumento pkgs com o caminho do arquivo. Por exemplo: install.packages(&quot;ggplot2_2.1.0.tar.gz&quot;, repos = NULL) "],
["install-rstudio.html", "2.3 RStudio no Ubuntu", " 2.3 RStudio no Ubuntu é uma empresa que desenvolve ferramentas gratuitas para o e produtos pagos para empresas. Uma de suas ferramentas gratuitas é o software RStudio Desktop que consiste em um ambiente integrado de desenvolvimento (IDE) construído especificamente para o , consequentemente, também é multiplataforma. Para instalação da versão do RStudio para Desktop, você precisa saber se seu SO é 64 ou 32-bit e a versão do Linux Ubuntu. Essas informações podem ser obtidas, respectivamente, pelos comandos: $ arch x86_64 Se retornar x86_64 sua máquina é 64-bit. $ lsb_release --release | cut -f2 14.04 Com essas informações, siga os seguintes passos: acesse RStudio clique em Download (Figura 2.3) Figure 2.3: Opção para baixar o RStudio Desktop. Clique na sua plataforma (de acordo com seu SO, arquitetura e versão da distribuição) (Figura 2.4), no exemplo deste livro RStudio 1.1.447 - Ubuntu 12.04-15.10/Debian 8 (64-bit) Figure 2.4: Escolha da plataforma em que será o usada o RStudio Desktop. Dependendo da sua versão Ubuntu, ao clicar sobre o sobre o arquivo baixado com o botão direito, há a opção de abrir com Ubuntu Software Center e então clicar em instalar. Se na versão de seu Desktop não há esta opção ao clicar com botão direito sobre o arquivo, instale via terminal6 com os seguintes comandos: $ cd /local/do/arquivo/baixado $ sudo dpkg -i arquivoBaixado.deb $ sudo apt-get install -f Abra o RStudio digitando no terminal: $ rstudio &amp; Agora você está pronto para começar a programar em aproveitando as facilidades que o RStudio oferece. digite ‘Ctrl+Alt+t’ para abrir um terminal no Linux Ubuntu↩ "],
["iu.html", "3 Interface do Usuário", " 3 Interface do Usuário Na maior parte do tempo você provavelmente usará o no modo interativo: rodando comandos e vendo os resultados. Eventualmente esse processo pode ser inconveniente. Por exemplo, no caso de uma análise com um código bem extenso e que precisa ser repetida com dados atualizados semanalmente. Nessa situação, recomenda-se a criação de um script, ou seja, um arquivo texto, com a extensão .R, contendo o código de sua análise. Esse script pode ser executado pelo R no modo de processamento em lote (do termo em inglês Batch Processing) através de um terminal do SO Linux, ou via o Prompt de comando (cmd.exe) do SO Windows. Nesta seção apresenta-se ao leitor estes dois modos de execução do . "],
["no-modo-interativo.html", "3.1 no modo interativo", " 3.1 no modo interativo No Linux o pode ser aberto simplesmente digitando em um terminal a letra R. $ R R version 3.4.4 (2018-03-15) -- &quot;Someone to Lean On&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. Natural language support but running in an English locale R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R. &gt; A janela com a linha de comando do apresenta o prompt do (&gt;). Após este símbolo digitamos os comandos, pressionamos a tecla &lt;enter&gt;, o interpreta o comando e retorna o resultado. Os comandos digitados na linha de comando são chamados de expressões. Esse é o modo iterativo do . Portanto, a linha de comando é a mais importante ferramenta do , pois todas expressões são avaliadas através dela. &gt; 62 + 38 [1] 100 A expressão é avaliada pelo , o resultado é mostrado, mas o seu valor é perdido. O número entre colchetes que aparece como resultado da operação (“[1]” no caso acima) indica o conteúdo resultante da operação iniciando na posição 1 desse objeto. O significado dessa informação torna-se mais óbvio quando trabalhamos com objetos maiores, como por exemplo com vetores. Observe os valores nos colchetes para uma sequência de 100 até 1. &gt; 100:1 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 O elemento [18] da sequência de 100 até 1 é o número 83. Pode ocorrer da expressão digitada na linha ser muito extensa e ir além de uma linha. Se a expressão estiver incompleta o mostra um sinal de +. &gt; 1 * 2 * 3 * 4 * 5 * + 6 * 7 * 8 * 9 * 10 [1] 3628800 Execute a expressão abaixo até o sinal de menos e tecle &lt;enter&gt;. Enquanto a instrução não estiver completa o sinal de + se repetirá. Você pode cancelar a execução digitando Ctrl + c ou Esc. No código abaixo isso acontecerá até que você digite o número que deseja subtrair de 4, no caso de o número 3. &gt; 4 - + + 3 [1] 1 3.1.1 Expressões em sequência Podemos executar todas expressões anteriores em apenas uma linha, usando o ponto e vírgula ; para separar as expressões: &gt; 62 + 38; 100:1; 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10; 4 - 3 [1] 100 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 [1] 3628800 [1] 1 3.1.2 Navegação entre as expressões já avaliadas Você pode usar as teclas ⬆️ e ⬇️ para navegar entre as expressões já avaliadas pelo . O que é útil quando precisamos repetir um comando anterior com alguma mudança ou para corrigir um erro de digitação ou a omissão de um parênteses. Quando a linha de comando é usada por muito tempo a sua tela pode ficar poluída com a saída das expressões anteriores. Para limpar a tela, tecle Ctrl+l. Assim o console aparece na parte superior do terminal. &gt; 15 + 4 [1] 19 &gt; 100:1 [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 &gt; #tecle &lt;Ctr + l&gt; Para parar ou cancelar a execução de uma expressão utilize as teclas Ctrl + C. As teclas Ctrl + l tem o efeito de limpar a tela. 3.1.3 Comentários No , a cerquilha # (hashtag) é um caractere especial. Qualquer coisa após esse caractere será ignorada pelo . Somente as expressões antes da # são avaliadas. Por meio desse símbolo de comentário podemos fazer anotações e comentários no código sem atrapalhar a interpretação das expressões pelo . &gt; # comentário antes do código &gt; 17 + 3 # comentário ao lado do código: adicionando 17 e 3 [1] 20 3.1.4 Auto preenchimento de funções O inclui o preenchimento automático de nomes de funções e arquivos por meio da tecla &lt;tab&gt;. Uma lista de possíveis funções que começam com as letras inicialmente digitadas aparecerão. &gt; read#&lt;tab&gt; pressione &lt;tab&gt; para ver as opções de comandos que iniciam com o termo read Figure 3.1: Auto preenchimento de código na linha de comandos do R. 3.1.5 Primeiro script O trecho de código abaixo apresenta nas primeiras linhas algumas expressões do executadas anteriormente. Mas há também, na segunda parte, códigos para salvar um gráfico de pontos num arquivo pdf. Na última parte do trecho, define-se uma variável x que contém aquela mesma sequência numérica usada no gráfico. # Primeiro script no R #---------------------------------------------------------------- # cálculos básicos 15 + 4 1:100 1 * 2 * 3 * 4 * 5 *6 * 7 * 8 * 9 * 10 4-3 #---------------------------------------------------------------- # salvando um gráfico em um arquivo pdf arquivo_pdf &lt;- &quot;plot-script1.pdf&quot; pdf(arquivo_pdf) # cria e abre um arquivo pdf plot(1:100) # faz o gráfico dev.off() # fecha o arquivo pdf #---------------------------------------------------------------- # definindo uma variável x x &lt;- 1:100 x Este conjunto de linhas de código, quando inseridos em um arquivo texto7 formam um primeiro script . Este script pode ser executado pelo através da função source(), usando como argumento o caminho para o local do script. &gt; source(&quot;/home/usuario/adar/script1.R&quot;) Este script produzirá como saída o arquivo /home/usuario/adar/plot-script1.pdf. Você pode visualizar o arquivo para conferir o gráficos de pontos gerado. Para fazer isso, você pode usar um editor de texto qualquer (p.ex.: gedit no SO Linux, ou Notepad no SO Windows).↩ "],
["no-modo-de-processamento-em-lote.html", "3.2 no modo de processamento em lote", " 3.2 no modo de processamento em lote Para rodar um script no modo de processamento em lote do através do seguinte comando no terminal Linux: $ R CMD BATCH opcoes arqentrada arqsaida Onde: arqentradaé o nome do script (arquivo com a extensão .R) a ser executado; arqsaida é o arquivo (com a extensão .Rout) com as saídas dos comandos executados no R; opcoes é a lista de opções que controlam a execução. Vamos rodar como exemplo, o script1.R da seção 3.1.5. $ R CMD BATCH /home/usuario/adar/script1.R O comando acima, produzirá dois arquivos de saída: script1.Rout8 criado por default quando o arqsaida não é especificado, e; arquivo &quot;plot-script1.pdf&quot;. Você pode especificar o nome do arqsaida como desejar. No exemplo abaixo, mostra-se como salvar o arquivo de saída incluindo a data em que ele foi gerado, script1-saida-adatadehoje.log. $ R CMD BATCH script1.R script1-saida-`date &quot;+%Y%m%d&quot;`.log Após a execução do último comando, os mesmos arquivos resultantes do comando anterior serão gerados, exceto pelo primeiro (.Rout), que será nomeado script1-saida-20180514.Rout. Para mais opções do comando R CMD BATCH digite no terminal do Linux R --help. Você pode notar que este arquivo tem o mesmo nome do arqentrada, exceto que a sua extensão foi alterada para .Rout.↩ "],
["rstudio.html", "4 RStudio", " 4 RStudio O RStudio Desktop é um ambiente integrado de desenvolvimento (IDE) para o . Portanto, o RStudio depende da instalação prévia do . Ele funciona como uma interface gráfica do usuário (GUI), mas com muito mais potencialidades. O RStudio é uma ferramente que potencializará sua interação com o : na produção de gráficos na organização de seu código na forma de projetos na reprodutibilidade de seu trabalho ou pesquisa na manutenção e criação de seus próprios pacotes do R na criação e compartilhamento de seus relatórios no compartilhamento de seu código e a colaboração com outros Nessa seção você terá uma visão geral do RStudio Desktop. "],
["visao-geral-do-rstudio.html", "4.1 Visão geral do RStudio", " 4.1 Visão geral do RStudio Assumindo que o RStudio tenha sido instalado (seção 2.3), ao abri-lo e clicar em File &gt; New File &gt; R script você verá uma tela com aspecto similar ao da Figura 4.1. Figure 4.1: Rstudio O RStudio possui 4 painéis principais: Editor para scripts e visualização de dados abrir e criar scripts rodar scripts código com sintaxe realçada rodar partes do código &lt;Ctrl+enter&gt; rodar todo script &lt;Ctrl+Shift+S&gt; autopreenchimento das funções &lt;tab&gt; comentar linhas &lt;Ctrl+Shift+C&gt; desfazer &lt;Ctrl+Z&gt; refazer &lt;Ctrl+Shift+Z&gt; referência para teclas de atalho &lt;Alt+Shift+K&gt; abrir script com &lt;Ctrl+Click&gt; encontrar e substituir Ctrl+F Console do R Navegador do espaço de trabalho e histórico de comandos Arquivos/Plots/Pacotes/Ajuda/Visualizador Configuração de texto e painéis em: Menus Tools &gt; global Options &gt; Appearance mostrar linhas, alterar realce da sintaxe Session Plots Para saber mais sobre os recursos fornecidos pelo RStudio assista ao vídeo RStudio Essencials. Isso o ajudará a usar mais efetivamente o RStudio. Folha de referência do RStudio Figure 4.2: Folha de referência do RStudio, disponível em https://www.rstudio.com/wp-content/uploads/2016/03/rstudio-IDE-cheatsheet-portuguese.pdf "],
["operbasic.html", "5 Operações básicas", " 5 Operações básicas Nesta seção veremos: operações aritméticas básicas com a atribuição de valores a uma variável o uso de funções matemáticas internas do valores numéricos especiais do os cuidados ao nomear variáveis "],
["convencao.html", "5.1 Convenção", " 5.1 Convenção A partir deste capítulo, os códigos a serem avaliadas no terão o prompt do (&gt;) omitidos. Essa convenção é para tornar mais fácil a ação de copiar e colar os códigos na linha de comando do . O resultado da avaliação das expressões será mostrado precedido do símbolo (#&gt;). Esses valores são os resultados que esperam-se sejam reproduzidos pelo leitor na sessão do em seu computador. Por exemplo: 1:5 #&gt; [1] 1 2 3 4 5 No trecho de código acima, a primeira linha contém o código a ser copiado pelo leitor para execução em seu computador. A segunda linha é a saída do código avaliado pelo R. "],
["calculadora.html", "5.2 Calculadora", " 5.2 Calculadora O é uma calculadora turbinada com diversas funções matemáticas disponíveis. Para quem não conhece o , essa uma forma de familiarizar-se com a linha de comandos. 5.2.1 Aritmética básica Todas operações feitas em uma calculadora podem ser realizadas na linha de comandos do . 10 + 2 + 4 #&gt; [1] 16 # Exemplo de divisao (5 + 14)/2 #&gt; [1] 9.5 # exponenciação 2^3 #&gt; [1] 8 4^0.5 #&gt; [1] 2 # operador artimético para se determinar o resto de uma divisao 10 %% 2 #&gt; [1] 0 2001 %% 2 #&gt; [1] 1 # o inteiro do quociente 11 %/% 2 #&gt; [1] 5 Note que no R, o separador decimal é o ponto “.”, ao invés da vírgula “,” usada na notação brasileira. As vírgulas tem a finalidade de separar os argumentos nas chamadas de funções, tal como em log(x = 10, base = 10). Conheça mais operadores aritméticos, digitando na linha de comando: ?&quot;Arithmetic&quot; A janela que se abrirá mostrará o texto que faz parte do manual de ajuda do . 5.2.2 Constantes O R possui algumas constantes pré-definidas, como o a constante pi (\\(\\pi\\)). pi #&gt; [1] 3.141593 O também tem vetores de caracteres pré-definidos, são eles: LETTERS #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; #&gt; [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; month.abb #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; #&gt; [12] &quot;Dec&quot; month.name #&gt; [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; #&gt; [6] &quot;June&quot; &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; #&gt; [11] &quot;November&quot; &quot;December&quot; Note que caracteres estão sempre entre aspas: &quot;&quot;. “caracteres são entre aspas” aeiou #&gt; Error in eval(expr, envir, enclos): object &#39;aeiou&#39; not found &quot;aeiou&quot; #&gt; [1] &quot;aeiou&quot; 5.2.3 Funções matemáticas internas Existem diversas funções internas do que permitem, por exemplo, sortear números aleatoriamente, arrendondar números, calcular o fatorial, calcular o seno, cosseno de um ângulo e etc. A sintaxe para chamar uma função no é: funcão(argumento) Por exemplo: # funções trigonométricas sin(pi/6) #&gt; [1] 0.5 cos(pi) #&gt; [1] -1 # raiz quadrada sqrt(100) #&gt; [1] 10 # exponencial exp(1) #&gt; [1] 2.718282 # fatorial factorial(4) #&gt; [1] 24 No você verá que parênteses são frequentemente utilizados. Eles são sempre associados à funções. Qualquer palavra antecedendo um parênteses é uma função. Para ver a lista completa de funções trigonométricas: ?&quot;Trig&quot; 5.2.4 Valores numéricos especiais Um caso particular sobre operação aritméticas no , são os valores numéricos Inf(Infinito) e NaN que resultam de operações como as mostradas na Tabela 5.1. NaN é a abreviação para valor indefinido (do termo em inglês Not a Number). Geralmente surge quando um cálculo não tem sentido matemático ou não pode ser propriamente realizado. A demonstração das diferentes formas de se obter essas constantes especiais é importante para entender a origem delas durante a execução de um script mais extenso. Table 5.1: Exemplos de operações que resultam em NaN ou \\(\\pm\\infty\\) . operação resultado 2/0 Inf -12/0 -Inf log(0) -Inf (c(-3, 3))^Inf NaN, Inf 0*Inf NaN log(-0.5) NaN sqrt(-1) NaN 0/0 NaN Inf-Inf NaN mean(c(NA, NA), na.rm = TRUE) NaN Por outro lado abaixo mostra-se alguns exemplos operações válidas com estes valores especiais. exp(-Inf) #&gt; [1] 0 (0:1)^Inf #&gt; [1] 0 1 0/Inf #&gt; [1] 0 (c(-1, 1)*Inf)^0 #&gt; [1] 1 1 0^0 #&gt; [1] 1 Outra constante especial do é o NA (Not Available) que representa valor faltante, um problema comum em análise de dados. Qualquer operação envolvendo NA resultará em NA (Tabela 5.2). Table 5.2: Operações com NA. operação resultado NA + 5 NA sqrt(NA) NA NA^2 NA NA/NaN NA 5.2.5 Notação científica e número de dígitos Na maioria das vezes precisamos trabalhar com números grandes e consequentemente acabamos usando uma notação científica ou exponencial. No há diferentes formas de representar números com expoentes: 1.2e-6 #&gt; [1] 1.2e-06 # expressões equivalentes 1.2E6; 1.2*10^6 #&gt; [1] 1200000 #&gt; [1] 1200000 Os resultados dos cálculos no são mostrados com 7 dígitos significativos, o que pode ser verificado pela getOptions(). É possível mudar para n dígitos usando a função options(), conforme exemplo abaixo. # opção de dígitos padrão getOption(&quot;digits&quot;) #&gt; [1] 7 exp(1) #&gt; [1] 2.718282 # alterando para 14 options(digits = 14) exp(1) #&gt; [1] 2.718281828459 getOption(&quot;digits&quot;) #&gt; [1] 14 # redefinindo para o número de casas decimais padrão options(digits = 7) getOption(&quot;digits&quot;) #&gt; [1] 7 "],
["variaveis.html", "5.3 Variáveis", " 5.3 Variáveis 5.3.1 Formas de atribuição 5.3.1.1 Variável recebe valor Até agora nós usamos expressões para fazer uma operação e obter um resultado. O termo &quot;expressão&quot; significa uma sentença de código que pode ser executada. Se a avaliação de uma expressão é salva usando o operador &lt;-, esta combinação é chamada &quot;atribuição&quot;. O resultado da &quot;atribuição&quot; é armazenado em uma variável e pode ser utilizado posteriormente. Então uma variável é um nome usado para guardar os dados. variavel &lt;- valor p &lt;- 1013 # para mostrar a variável digite o nome da variável p #&gt; [1] 1013 # ou use a função print() print(p) #&gt; [1] 1013 O R diferencia letras maiúsculas de minúsculas. Portanto p e P são variáveis diferentes. p #&gt; [1] 1013 P #&gt; Error in eval(expr, envir, enclos): object &#39;P&#39; not found Como criamos apenas a variável p, P não foi encontrada. A variável p pode ser utilizado para criar outras variáveis. p_pa &lt;- p * 100 # pressão em Pascal p_pa #&gt; [1] 101300 A seta de atribuição pode ser usada em qualquer sentido. Parênteses, além de estarem sempre acompanhando uma função, também são usados para indicar a prioridade dos cálculos. 7/3 + 0.6 -&gt; y1 y1 #&gt; [1] 2.933333 7/(3 + 0.6) -&gt; y2 y2 #&gt; [1] 1.944444 Os espaços em torno do símbolo de atribuição (&lt;-) não são obrigatórios mas eles ajudam na legibilidade do código. x &lt;- 1 x &lt; -1 # atribuição ou menor que? x&lt;-1 Vamos criar uma variável chamada ndias3 que recebe o nº de dias no mês de Março e ndias4 que recebe o nº de dias no mês de Abril. nd3 &lt;- 31 nd4 &lt;- 30 O total de dias nos meses de março e abril será armazenado na variável totdias: totd &lt;- nd3 + nd4 totd #&gt; [1] 61 A atribuição de um mesmo valor para diferentes variáveis pode ser feita da seguinte forma: # número de dias em cada mês jan &lt;- mar &lt;- mai &lt;- jul &lt;- ago &lt;- out &lt;- dez &lt;- 31 abr &lt;- jun &lt;- set &lt;- nov &lt;- 30 fev &lt;- 28 # verificação jan #&gt; [1] 31 jul #&gt; [1] 31 jun #&gt; [1] 30 set #&gt; [1] 30 fev #&gt; [1] 28 Nós estamos definindo a variável, digitando o nome dela na linha de comando e teclando enter para ver o resultado. Há uma forma mais prática de fazer isso e mostrar o resultado cercando a atribuição por parênteses: # ao invés de # tar &lt;- 20 # tar # é mais prático (tar &lt;- 20) #&gt; [1] 20 Se desejamos calcular e já visualizar o valor da pressão de vapor de saturação obtida com a equação de Tetens, podemos fazer: (es &lt;- 0.611 * exp((17.269 * tar)/(tar + 237.3))) #&gt; [1] 2.338865 Quando usamos a mesma variável numa sequência de atribuições o seu valor é sobrescrito. Portanto não é bom usar nomes que já foram usados antes, exceto se a intenção for realmente essa. Para saber os nomes das variáveis já usados use a função ls()9 para verificar as variáveis existentes: ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;esp_num_df&quot; #&gt; [6] &quot;fev&quot; &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; #&gt; [11] &quot;mar&quot; &quot;nd3&quot; &quot;nd4&quot; &quot;nov&quot; &quot;oper&quot; #&gt; [16] &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; &quot;pcks&quot; #&gt; [21] &quot;rblue&quot; &quot;res&quot; &quot;set&quot; &quot;tar&quot; &quot;totd&quot; #&gt; [26] &quot;y1&quot; &quot;y2&quot; totd &lt;- jan*7; totd &lt;- totd + fev; totd &lt;- totd + 4*abr totd #&gt; [1] 365 5.3.1.2 Atribuição com a função assign() Outra forma de atribuição é através da função assign(): es #&gt; [1] 2.338865 assign(x = &quot;es_hpa&quot;, value = es/10) es_hpa #&gt; [1] 0.2338865 # usando função assign sem nome dos parâmetros assign(&quot;u&quot;, 2.5) u #&gt; [1] 2.5 Um exemplo mais elaborado de uso da função assign() para criar várias variáveis pode ser visto aqui. 5.3.2 Removendo variáveis Para remover variáveis usa-se a função rm(). # lista de variáveis existentes ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;es_hpa&quot; #&gt; [6] &quot;esp_num_df&quot; &quot;fev&quot; &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; #&gt; [11] &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; &quot;nd4&quot; &quot;nov&quot; #&gt; [16] &quot;oper&quot; &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; #&gt; [21] &quot;pcks&quot; &quot;rblue&quot; &quot;res&quot; &quot;set&quot; &quot;tar&quot; #&gt; [26] &quot;totd&quot; &quot;u&quot; &quot;y1&quot; &quot;y2&quot; Vamos remover a variável u criada previamente e ver a lista de objetos no espaço de trabalho. rm(u) # lista de variáveis existentes, sem u ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;es&quot; &quot;es_hpa&quot; #&gt; [6] &quot;esp_num_df&quot; &quot;fev&quot; &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; #&gt; [11] &quot;mai&quot; &quot;mar&quot; &quot;nd3&quot; &quot;nd4&quot; &quot;nov&quot; #&gt; [16] &quot;oper&quot; &quot;oper_nas&quot; &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; #&gt; [21] &quot;pcks&quot; &quot;rblue&quot; &quot;res&quot; &quot;set&quot; &quot;tar&quot; #&gt; [26] &quot;totd&quot; &quot;y1&quot; &quot;y2&quot; Podemos remover mais de uma variável ao mesmo tempo. rm(es_hpa, es, tar, y1, y2) # lista de variáveis existentes, sem es_hpa, es, tar, y1, y2 ls() #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;esp_num_df&quot; &quot;fev&quot; #&gt; [6] &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; #&gt; [11] &quot;nd3&quot; &quot;nd4&quot; &quot;nov&quot; &quot;oper&quot; &quot;oper_nas&quot; #&gt; [16] &quot;out&quot; &quot;p&quot; &quot;p_pa&quot; &quot;pcks&quot; &quot;rblue&quot; #&gt; [21] &quot;res&quot; &quot;set&quot; &quot;totd&quot; Para remover todas variáveis do espaço de trabalho (use com cautela): # apagando tudo rm(list = ls()) ls() #&gt; character(0) 5.3.3 Nomeando variáveis É preciso ter cuidado ao nomear variáveis no R porque existem algumas regras: não iniciar com um número e não conter espaços 1oAno &lt;- 1990 raizDe10 &lt;- srt(2) variavel teste &lt;- 67 # nomes alternativos para as variaveis ano1 &lt;- 1990 variavel_teste &lt;- 67 variavel.teste &lt;- 68 não conter símbolos especiais: ^, !, $, @, +, -, /, ou * dia-1 &lt;- 2 #&gt; Error in dia - 1 &lt;- 2: object &#39;dia&#39; not found # alternativa dia_1 &lt;- 2 evitar o uso de nomes usados em objetos do sistema (funções internas do R ou constantes como o número \\(\\pi\\)): c q s t C D F I T diff exp log mean pi range rank var FALSE Inf NA NaN NULL TRUE break else for function if in next repeat while variáveis com acento são permitidas mas não recomendadas. verão &lt;- &quot;DJF&quot; verão #&gt; [1] &quot;DJF&quot; Há limitações de interpretação do R para caracteres latinos como cedilha e acentos. Por isso não recomenda-se o uso destes caracteres para nomear variáveis. Uma boa prática de programação é dar nomes informativos às variáveis para maior legibilidade do código. Uma boa referência para isso é a seção Sintaxe do Guia de estilo tidyverse (ou universo arrumado). Apesar do ganho de legibilidade do código com a aplicação das regras de formatação de código do tidyverse é difícil de lembrar de todas elas. Mas este não é mais um problema, pois o pacote styler fornece funções para estilizar o seu código padrão tidyverse. install.packages(&quot;styler&quot;) library(styler) As funções são acessíveis Através do menu Addins do RStudio e incluem as opções de: estilizar um arquivo e uma região destacada do código. Essa lista de variáveis também é mostrada no painel Environment do RStudio (canto direito superior, aba Environment).↩ "],
["exercicios.html", "5.4 Exercícios", " 5.4 Exercícios Execute as seguintes expressões no R mostrando os resultados obtidos. 1 + 1 100:130 5 - +1 3 % 5 2 * 3 4 - 1 6 / (4 - 1) Utilize uma expressão para cada item. Escolha um número e some 3 a ele. Multiplique o resultado por 2. Subtraia 10 da resposta. Divida o que foi obtido por 4. Calcule \\(\\sqrt{16}\\), \\({16^{0.5}}^{3}\\), \\({(16^{0.5})}^{3}\\) e \\(4^{\\frac{3}{2}}\\). Teste as expressões log10(1000), log(1000), exp(log(1000)). Depois teste a expressão log2(64). Verifique se você entendeu as diferentes funções logarítmicas. Defina as variáveis abaixo tomando cuidados ao nomear as variáveis, conforme visto em sala de aula. Mostre os valores para as seguintes constantes: Velocidade da luz: \\(\\nu = 2.998 \\times 10^{8} \\left[m \\, s^{-1}\\right]\\) Carga elementar ou eletrônica: \\(e = 1.602 \\times 10^{-19} \\left[C\\right]\\) Permissividade do vácuo: \\(\\epsilon_{0} = 8.85 \\times 10^{-12} \\left[C^{2} \\, N^{-1} \\, m^{2}\\right]\\) Constante de Planck: \\(h=6.626 \\times 10^{-34} \\left[J \\, s\\right]\\) Constante de Stefan Boltzman: \\(\\sigma = 5.67 \\times 10^{-8} \\left[W \\, m^{-2} \\, K^{-4}\\right]\\) Constante solar: \\(S_{0} = 1380 \\left[W \\, m^{-2}\\right]\\) Constante de Avogadro: \\(N_{A} = 6.022 \\times 10^{23} \\left[mol^{-1}\\right]\\) Constante dos gases para o ar seco: \\(R_{d} = 287.04 \\left[J \\, K^{-1} \\, kg^{-1}\\right]\\) Constante dos gases ideais para o vapor: \\(R_{w} = 461.5 \\left[J \\, K^{-1} \\, kg^{-1}\\right]\\) Densidade do ar seco para CNTP (à 0 ° C em 1000 mb): \\(\\rho=1.2754 \\left[kg \\, m^{-3}\\right]\\) Pressão média ao nível médio do mar para atmosfera padrão: \\(P_{0}=1013.25 \\left[mb\\right]\\) Temperatura ao nível médio do mar para atmosfera padrão: \\(T_{0}=288.15 \\left[K\\right]\\) Calor latente de vaporização ou condensação (à 0 °C): \\(\\lambda_{v} = 2.501 \\times 10^{6}\\left[J \\, kg^{-1}\\right]\\) Calor latente de fusão (à 0 °C): \\(\\lambda_{f} = 0.334 \\times 10^{6}\\left[J \\, kg^{-1}\\right]\\) Massa molecular da água: \\(M_w = 18.016 \\left[g \\, mol^{-1}\\right]\\) Peso molecular do ar: \\(M_{ar} = 28.96 \\left[g \\, mol^{-1}\\right]\\) Raio da terra: \\(r = 6.37 \\times 10^{6} \\left[m\\right]\\) Velocidade angular da Terra: \\(\\Omega=7.29 \\times 10^{-5} \\left[rad \\, s^{-1}\\right]\\) Como você pode fazer para que a constante pi seja mostrada com 20 dígitos? (b) Como voltar a trabalhar a com 7 dígitos novamente? c. Mostre o número neperiano com 7 dígitos. Determine a temperatura de bulbo úmido (\\(T_{w}\\)) usando a expressão empírica (Stull, 2011) abaixo. Salve os resultados em variáveis diferentes. Para uma temperatura do ar (\\(T\\)) de 20°C e Umidade relativa (\\(UR\\)) de 70%, qual o valor de Tw? Defina variáveis para os valores \\(T\\) e (\\(UR\\)) e use-as na equação de \\(T_{w}\\). \\[ \\begin{aligned} T_{w}=T\\cdot atan\\left [ 0.151977\\cdot \\left ( UR+8.313659 \\right )^{1/2} \\right ]+ \\\\ atan\\left (T+UR \\right )-\\\\ atan\\left ( UR-1.676331 \\right )+\\\\ 0.00391838\\left ( UR \\right )^{3/2}\\cdot atan\\left ( 0.023101\\cdot UR \\right )-\\\\ 4.686035 \\end{aligned} \\] Determine os valores de umidade do solo: no potencial hídrico de 10kPa (\\(\\theta_{10kPa}\\)) na capacidade de campo (\\(\\theta_{33kPa}\\)) no ponto de murcha permanente (\\(\\theta_{1500kPa}\\)) utilizando o conjunto de equações de pedotransferência abaixo (Tomasela et al. 2003): Considere \\(SI = 16.29\\) (%), \\(CL = 49.25\\) (%), \\(Db = 1.25\\) (\\(g \\, cm^{-3}\\)), \\(Me = 25\\) (%), onde \\(SI\\) é a porcentagem de silte no solo, \\(CL\\) é a porcentagem de argila, \\(Db\\) é a densidade do solo e \\(Me\\) é a umidade equivalente em %. Arredonde para 2 casas decimais os resultados da questão 8. Dica ver ?round. Instale a última versão do R no (seu) computador usado para resolução desta lista. Crie um script chamado solucao-q10-NomeDoAluno.R contendo os códigos gerados para solução das questões 7 e 8. Faça as seguintes alterações no código do script: no código da questão 8, utilize a temperatura do ar (\\(T\\)) de 30°C e Umidade relativa (\\(UR\\)) de 30% para calcular \\(Tw\\). no código da questão 9, considere \\(SI = 13\\) (%), \\(CL = 37\\) (%), \\(Db = 1.3\\) (\\(g \\, cm^{-3}\\)), \\(Me = 21\\) (%) para recalcular \\(\\theta_{10kPa}\\), \\(\\theta_{33kPa}\\) e \\(\\theta_{1500kPa}\\). após os códigos usados para resolver as questões 8 e 9, adicione uma nova linha com a expressão sessionInfo(). Finalmente rode o script usando o R no modo não iterativo. Anexe o arquivo de saída solucao-q10-NomeDoAluno.Rout como resposta para este problema. Instruções para entrega da resolução da lista de exercícios. A resolução da lista deve conter um único arquivo compactado nomeado segundo o padrão lista1-adar-NomedoAluno.zip. O arquivo compactado deve incluir pelo menos 3 arquivos: solucao-q10-NomeDoAluno.R: um script com os códigos usados para resolver a questão 10. solucao-q10-NomeDoAluno.Rout um arquivo texto de saída gerado (automaticamente) pelo R quando usado no modo não iterativo (Batch). Também faz parte da resolução da questão 10. lista1-adar-NomedoAluno.Rmd: arquivo Rmarkdown gerado no RStudio (File &gt; New File &gt; R Notebook) e editado de forma que contenha o texto e o código (chuncks) necessários para resolução das questões 1 a 9. Sempre procure criar variáveis para cada etapa da resolução das questões. Utilize nomes contextualizados e intuitivos. Siga as boas práticas recomendadas no material para nomear as variáveis. (Opcional) lista1-adar-NomedoAluno.html arquivo html gerado pelo RStudio (botão knit na aba do painel do editor) a partir do arquivo lista1-adar-NomedoAluno.Rmd. "],
["datatype.html", "6 Tipos de dados", " 6 Tipos de dados Nesta seção vamos: conhecer os tipos de dados mais usados no R descobrir qual é o tipo de dado de uma variável aprender a fazer testes com operadores lógicos saber como converter uma variável de um tipo para outro "],
["classes-de-dados.html", "6.1 Classes de dados", " 6.1 Classes de dados Existem vários classes de dados no R. As mais utilizadas são mostradas na 6.1. A classe de um objeto é obtida com a função class(). x &lt;- 51 class(x) #&gt; [1] &quot;numeric&quot; Table 6.1: Principais classes de dados do R. Classes de dados Classes no R exemplo Números numeric 2.5, 2 Caracteres character a Lógicos logical TRUE, FALSE Datas Date 2010-01-01 Datas e horários POSIX 2010-01-01 00:00:00 6.1.1 Números É a classe de objeto mais usada. Essa classe é chamada numeric no e é similar a float ou double em outras linguagens. Ela trata de inteiros, decimais, positivos, negativos e zero. Um valor numérico armazenado em um objeto é automaticamente assumido ser numérico. Para testar se um objeto é numérico usa-se a função is.numeric(). is.numeric(x) #&gt; [1] TRUE is.numeric(pi) #&gt; [1] TRUE Outro tipo é o integer (inteiro), ou seja não há parte decimal. Para definir um objeto como inteiro é necessário acrescentar ao valor numérico um L. Analogamente, uma forma de verificação se o objeto é inteiro é através função is.integer(). i &lt;- 3L is.integer(i) #&gt; [1] TRUE is.integer(pi) #&gt; [1] FALSE Mesmo com o objeto i sendo inteiro, ele também passa na verificação is.numeric(). is.numeric(i) #&gt; [1] TRUE O R converte inteiros para numéricos quando necessário. Vamos usar a função typeof() para determinar o tipo de dado e as conversões que o R faz. Por exemplo: ## integer * numeric typeof(5L) #&gt; [1] &quot;integer&quot; typeof(4.5) #&gt; [1] &quot;double&quot; (prod_i &lt;- 5L * 4.5) #&gt; [1] 22.5 typeof(prod_i) #&gt; [1] &quot;double&quot; ## integer/integer typeof(5L) #&gt; [1] &quot;integer&quot; typeof(2L) #&gt; [1] &quot;integer&quot; typeof(5L/2L) #&gt; [1] &quot;double&quot; # número complexo typeof(3 + 2i) #&gt; [1] &quot;complex&quot; 6.1.2 Caractere O tipo de dado caractere (do termo em inglês character ou string) é bastante utilizado e deve ser manipulado com cuidado. Há duas principais formas de lidar com caracteres: a função character() e a factor(). Embora pareçam similares eles são tratados de forma diferente. (char &lt;- &quot;Vai chover hoje?&quot;) #&gt; [1] &quot;Vai chover hoje?&quot; charf &lt;- factor(&quot;Vai chover hoje?&quot;) charf #&gt; [1] Vai chover hoje? #&gt; Levels: Vai chover hoje? levels(charf) #&gt; [1] &quot;Vai chover hoje?&quot; ordered(charf) #&gt; [1] Vai chover hoje? #&gt; Levels: Vai chover hoje? char contém as palavras &quot;Vai chover hoje?&quot;, enquanto, charf tem as mesmas palavras porém sem as aspas e a segunda linha de informação sobre os níveis (levels) de charf. Nós veremos esse tipos de dado futuramente em vetores. Lembre-se que caracteres em letras minúsculas e maiúsculas são coisas diferentes no R. Para encontrar o tamanho de um character usamos a função nchar(). nchar(char) #&gt; [1] 16 nchar(&quot;abc&quot;) #&gt; [1] 3 Esta função não funcionará para um objeto do tipo factor. nchar(charf) #&gt; Error in nchar(charf): &#39;nchar()&#39; requires a character vector 6.1.3 Lógico Valores lógicos (logical no ) são uma forma de representar dados que podem assumir valores booleanos, isto é, TRUE (verdadeiro) ou FALSE (falso). O aceita as abreviaturas T e F para representar TRUE e FALSE, # variável lógica vl &lt;- c(FALSE, T, F, TRUE) vl #&gt; [1] FALSE TRUE FALSE TRUE Entretanto, esta não é uma prática recomendável, conforme exemplo abaixo. TRUE #&gt; [1] TRUE T #&gt; [1] TRUE class(T) #&gt; [1] &quot;logical&quot; T &lt;- 10 class(T) #&gt; [1] &quot;numeric&quot; Valores lógicos podem ser usados em operações aritméticas. Neste caso, serão convertidos numericamente para 1 (TRUE) e 0 (FALSE). vl * 5 #&gt; [1] 0 5 0 5 TRUE * 4 #&gt; [1] 4 TRUE + TRUE #&gt; [1] 2 FALSE - TRUE #&gt; [1] -1 Assim como as outras classes de dados, existem funções para verificar a classe de dados lógicos. class(vl) #&gt; [1] &quot;logical&quot; is.logical(vl) #&gt; [1] TRUE Valores lógicos resultam da comparação de números ou caracteres. 4 == 3 # 4 é idêntico a 3? #&gt; [1] FALSE teste2i2 &lt;- 2 * 2 == 2 + 2 teste2i2 #&gt; [1] TRUE teste2d2 &lt;- 2 * 2 != 2 + 2 # operador: diferente de teste2d2 #&gt; [1] FALSE 4 &lt; 3 #&gt; [1] FALSE 4 &gt; 3 #&gt; [1] TRUE 4 &gt;= 3 &amp; 4 &lt;= 5 #&gt; [1] TRUE 4 &lt;= 3 | 4 &lt;= 5 #&gt; [1] TRUE &quot;abc&quot; == &quot;defg&quot; #&gt; [1] FALSE &quot;abc&quot; &lt; &quot;defg&quot; #&gt; [1] TRUE nchar(&quot;abc&quot;) &lt; nchar(&quot;defg&quot;) #&gt; [1] TRUE A Tabela 6.2 apresenta os principais operadores lógicos disponíveis no . Table 6.2: Operadores Lógicos Operador Descrição &lt; menor que &lt;= menor ou igual a &gt; maior que &gt;= maior ou igual == idêntico != diferente !x não é x (negação) x | y x ou y x &amp; y x e y isTRUE(x) teste se x é verdadeiro %in% está contido em 6.1.4 Datas e horários Lidar com datas e horários pode ser difícil em qualquer linguagem e pode complicar mais ainda quando há diversas opções de classes de datas disponíveis, como no . Entre as classes mais convenientes para este tipo de informação consideram-se: Date POSIXct Date armazena apenas a data enquanto POSIXct armazena a data e o horário. Ambos dados são representados como o número de dias (Date) ou segundos (POSIXct) decorridos desde 1 de Janeiro de 1970. data1 &lt;- as.Date(&quot;2012-06-28&quot;) data1 #&gt; [1] &quot;2012-06-28&quot; class(data1) #&gt; [1] &quot;Date&quot; as.numeric(data1) #&gt; [1] 15519 data2 &lt;- as.POSIXct(&quot;2012-06-28 17:42&quot;) data2 #&gt; [1] &quot;2012-06-28 17:42:00 UTC&quot; class(data2) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; as.numeric(data2) #&gt; [1] 1340905320 A manipulação de dados da classe de datas e horários (Date-time) torna-se mais versátil através dos pacotes lubridate e chron, o que será visto posteriormente no curso. Funções como as.numeric() e as.Date() não apenas mudam o formato de um objeto mas muda realmente a classe original do objeto. class(data1) #&gt; [1] &quot;Date&quot; class(as.numeric(data1)) #&gt; [1] &quot;numeric&quot; "],
["testes-sobre-tipos-de-dados.html", "6.2 Testes sobre tipos de dados", " 6.2 Testes sobre tipos de dados Além função typeof(), a família is.*() também permite descobrir o tipo de dado, p.ex.: is.numeric(), is.character() e etc. x; typeof(x) #&gt; [1] 51 #&gt; [1] &quot;double&quot; vl; typeof(vl) #&gt; [1] FALSE TRUE FALSE TRUE #&gt; [1] &quot;logical&quot; data1; typeof(data1) #&gt; [1] &quot;2012-06-28&quot; #&gt; [1] &quot;double&quot; x; is.numeric(x) #&gt; [1] 51 #&gt; [1] TRUE # num.real? is.double(x/5) #&gt; [1] TRUE is.double(5L) #&gt; [1] FALSE is.character(&quot;12.34&quot;) #&gt; [1] TRUE charf; is.factor(charf) #&gt; [1] Vai chover hoje? #&gt; Levels: Vai chover hoje? #&gt; [1] TRUE i; is.integer(i) #&gt; [1] 3 #&gt; [1] TRUE is.function(sqrt) #&gt; [1] TRUE is.finite(i) #&gt; [1] TRUE is.nan(x) #&gt; [1] FALSE is.na(x) #&gt; [1] FALSE "],
["conversao-entre-tipos-de-dados.html", "6.3 Conversão entre tipos de dados", " 6.3 Conversão entre tipos de dados Em algumas circunstâncias precisamos alterar o tipo de uma variável. A maioria das funções is.*() possui uma função as.*() correspondente de conversão para aquele tipo de dado. # de character para numeric as.numeric(&quot;12.34&quot;) #&gt; [1] 12.34 # de factor para character as.character(charf) #&gt; [1] &quot;Vai chover hoje?&quot; # character para factor as.factor(&quot;a&quot;) #&gt; [1] a #&gt; Levels: a # de double para integer typeof(x) #&gt; [1] &quot;double&quot; typeof(as.integer(x)) #&gt; [1] &quot;integer&quot; as.integer(x) == 51L #&gt; [1] TRUE as.integer(&quot;12.34&quot;) #&gt; [1] 12 # arredondamento as.integer(12.34) #&gt; [1] 12 # lógico para inteiro as.integer(TRUE) #&gt; [1] 1 # numérico para lógico as.logical(0:2) #&gt; [1] FALSE TRUE TRUE # character para numérico? as.numeric(&quot;a&quot;) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA # de character para date dt_char &lt;- &quot;2016-03-17&quot; dt &lt;- as.Date(dt_char) dt #&gt; [1] &quot;2016-03-17&quot; # de character para date-time data_hora &lt;- as.POSIXct(&quot;2016-03-17 15:30:00&quot;) data_hora #&gt; [1] &quot;2016-03-17 15:30:00 UTC&quot; "],
["estrutura-dados.html", "7 Estrutura de dados", " 7 Estrutura de dados O R permite ler dados de uma variedade de fontes e formatos. Nesta unidade veremos como importar dados de arquivos texto, binários e de outros softwares para o R. Nesta seção vamos: ver como importar dados no R10 conhecer os formatos mais comuns de dados reconhecidos pelo R ler arquivos de dados meteorológicos de fontes brasileiras Para uma descrição mais abrangente sobre importação e exportação de dados no R consulte a documentação de cada função e o manual R Data Import/Export.↩ "],
["visao-geral.html", "7.1 Visão geral", " 7.1 Visão geral Existem diferentes formas de armazenar dados no R. Algumas vezes os dados precisam ser armazenados de forma mais complexa do que por exemplo vetores. O R possui uma variedade de estruturas (Figura 7.1). As mais utilizadas são: dataframe (tabela de dados) matrix (matriz) list (lista) array e vector (vetor) Figure 7.1: Principais estruturas de dados no R. "],
["vetor.html", "7.2 Vetor", " 7.2 Vetor Um vetor é uma coleção de elementos. Os vetores são amplamente usados e compõem a estrutura básica de dados do R, por ser uma linguagem vetorizada. Os vetores podem ser de dois tipos: vetores atômicos e listas. 7.2.1 Vetores atômicos Os vetores atômicos são constituem a estrutura de dados mais simples do R (como se fossem os átomos do R). Um vetor atômico é uma coleção de elementos, em que todos são do mesmo tipo de dado (todos double, ou integer, ou logical, etc). Como linguagem vetorizada, as operações são aplicadas a cada elemento do vetor automaticamente, sem a necessidade de laços (ou loopings) ao longo do vetor. Esse conceito pode ser estranho para quem vem de outras linguagens, mas é uma das grandes vantagens do R. Vetores não tem dimensões, ou seja não existem é um vetor linha ou vetor coluna. 7.2.1.1 Propriedades typeof() para descobrir o tipo de dado length() para descobrir o tamanho de um tipo de dado attributes (informações acionais específicas do dado), entre eles o atributo mais comum está o names(). 7.2.1.2 Criação Vetores atômicos são geralmente criados com c(), abreviatura para o verbo combinar ou concatenar. # vetor numérico vetor_num &lt;- c(5, 2.5, 4.5) # Note o sufixo L que distingue variaveis &quot;double&quot; de &quot;integers&quot; vetor_int &lt;- c(1L, 6L, 10L) # Vetor logico vetor_log &lt;- c(TRUE, FALSE, TRUE, FALSE) # Vetor de caracteres vetor_char &lt;- c(&quot;Analise de dados&quot;, &quot;ambientais com o R&quot;) Vetores atômicos podem ser criados a partir de outros vetores aninhados entre si pela função c(). v1 &lt;- 1 # vetor com 1 elemento v2 &lt;- c(2) # vetor com 1 elemento v3 &lt;- c(4, 6) # vetor com 2 elemento Formas diferentes para criação de vetor que resultam num mesmo vetor: (v_123 &lt;- c(v1, v2, v3)) #&gt; [1] 1 2 4 6 (v_123a &lt;- c(1, c(v2, v3))) #&gt; [1] 1 2 4 6 (v_123b &lt;- c(vetor_num, c(v1, v2), v3)) #&gt; [1] 5.0 2.5 4.5 1.0 2.0 4.0 6.0 v &lt;- c(1, 2, 4, 6) v #&gt; [1] 1 2 4 6 7.2.1.3 Coerção de vetores c(&quot;a&quot;, 1) #&gt; [1] &quot;a&quot; &quot;1&quot; as.numeric(c(FALSE, FALSE, TRUE)) #&gt; [1] 0 0 1 Você pode manualmente forçar um tipo de vetor para outro usando funções de coerção: as.character(), as.double(),as.integer(), as.logical(). Coerção frequentemente acontece automaticamente, mas geralmente será mostrada uma mensagem quando ocorrer. Vamos usar a coerção no seguinte caso. Imagine um vetor com valores de chuva mensal de um ano e outro vetor com os meses do ano. Note a diferença da forma como criamos o vetor meses e o vetor months. Como descobrir o número de meses sem chuva nesse ano? # vetor com nomes criados com 1 comando meses &lt;- c( jan = 1, fev = 2, mar = 3, abr = 4, mai = 5, jun = 6, jul = 7, ago = 8, set = 9, out = 10, nov = 11, dez = 12 ) meses #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 # vetor definido e depois adiciona-se o nome das variáveis months &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) names(months) &lt;- c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;) months #&gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 # o atibuto mais comum de um vetor attributes(meses) #&gt; $names #&gt; [1] &quot;jan&quot; &quot;fev&quot; &quot;mar&quot; &quot;abr&quot; &quot;mai&quot; &quot;jun&quot; &quot;jul&quot; &quot;ago&quot; &quot;set&quot; &quot;out&quot; &quot;nov&quot; #&gt; [12] &quot;dez&quot; length(meses) #&gt; [1] 12 # Vetor com dados de prec chuva &lt;- c(100, 0, 20, 140, 110, 50, 90, 0, 0, 10, 0, 6) length(chuva) #&gt; [1] 12 # quando nao choveu? seco &lt;- chuva == 0 seco #&gt; [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE TRUE #&gt; [12] FALSE # coerção de lógico para numérico seco01 &lt;- as.numeric(seco) # seco01 &lt;- as.integer(seco) seco01 #&gt; [1] 0 1 0 0 0 0 0 1 1 0 1 0 # total de meses secos no ano sum(seco01) #&gt; [1] 4 # também funciona com vetores lógicos sum(seco) #&gt; [1] 4 7.2.1.4 Nomeando vetores Nós podemos nomear um vetor de 3 formas: Durante a criação Modificando um vetor Criando um vetor modificado Nomes devem ser únicos (sem repetições), porque para filtragem de elementos de um vetor ou a seleção de um subconjunto (razão pela qual usam-se os names) retornará somente o primeiro elemento que tiver nome repetido. # Durante a criação: x &lt;- c(a = 1, b = 2, c = 3) x #&gt; a b c #&gt; 1 2 3 # Modificando um vetor: x &lt;- 1:3 names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x #&gt; a b c #&gt; 1 2 3 # Criando um vetor modificado x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) x #&gt; a b c #&gt; 1 2 3 Nem todos elementos precisam ter nomes. Se os nomes são faltantes, names() retornará um string vazia (“”) para aqueles elementos. Se todos forem faltantes, names() retornará NULL. y &lt;- c(a = 1, 2, 3) names(y) #&gt; [1] &quot;a&quot; &quot;&quot; &quot;&quot; z &lt;- c(1, 2, 3) names(z) #&gt; NULL Podemos criar um vetor sem nomes usando a função unname(x), ou remover names com names(x) &lt;- NULL. a &lt;- c(dia1 = 12, dia2 = 20, dia3 = 10) a #&gt; dia1 dia2 dia3 #&gt; 12 20 10 names(a) #&gt; [1] &quot;dia1&quot; &quot;dia2&quot; &quot;dia3&quot; a_sn &lt;- unname(a) a_sn #&gt; [1] 12 20 10 names(a_sn) #&gt; NULL 7.2.2 Operações com vetores Para multiplicar cada elemento de um vetor por um valor é usar o operador de multiplicação (*). O mesmo procedimento se aplica as demais operações de soma, subtração, divisão, exponenciação e etc. x &lt;- 1:10 x * 3 #&gt; [1] 3 6 9 12 15 18 21 24 27 30 x + 2 #&gt; [1] 3 4 5 6 7 8 9 10 11 12 x - 3 #&gt; [1] -2 -1 0 1 2 3 4 5 6 7 x / 4 #&gt; [1] 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2 ^ (x / 4) #&gt; [1] 1.189207 1.414214 1.681793 2.000000 2.378414 2.828427 3.363586 #&gt; [8] 4.000000 4.756828 5.656854 x ^ 2 #&gt; [1] 1 4 9 16 25 36 49 64 81 100 sqrt(x) #&gt; [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 #&gt; [8] 2.828427 3.000000 3.162278 Operações vetoriais podem ser estendidas para mais de um vetor. # criando 2 vetores de mesmo tamanho x &lt;- 1:10 y &lt;- -5:4 # somando-os x + y #&gt; [1] -4 -2 0 2 4 6 8 10 12 14 x - y #&gt; [1] 6 6 6 6 6 6 6 6 6 6 x * y #&gt; [1] -5 -8 -9 -8 -5 0 7 16 27 40 x / y #&gt; [1] -0.2 -0.5 -1.0 -2.0 -5.0 Inf 7.0 4.0 3.0 2.5 x ^ y #&gt; [1] 1.000000e+00 6.250000e-02 3.703704e-02 6.250000e-02 2.000000e-01 #&gt; [6] 1.000000e+00 7.000000e+00 6.400000e+01 7.290000e+02 1.000000e+04 2 ^ x #&gt; [1] 2 4 8 16 32 64 128 256 512 1024 x %% y #&gt; [1] -4 -2 0 0 0 NA 0 0 0 2 # tamanho dos vetores length(x) #&gt; [1] 10 length(y) #&gt; [1] 10 length(x + y) #&gt; [1] 10 Uma peculiaridade do R é o tratamento de operações com vetores de tamanhos diferentes. O vetor menor é reciclado, de forma que seus elementos sejam repetidos em ordem até atingirem o tamanho do vetor mais longo envolvido na operação. v1 &lt;- c(3, 5, 88, 90) v2 &lt;- c(2, 1) v1 + v2 #&gt; [1] 5 6 90 91 Se o vetor mais longo não é múltiplo do mais curto, o R imprime um aviso. v1 &lt;- c(3, 5, 88, 90) v2 &lt;- c(2, 1, 3) v1 + v2 #&gt; Warning in v1 + v2: longer object length is not a multiple of shorter #&gt; object length #&gt; [1] 5 6 91 92 A reciclagem é intrinsecamente usada em operações envolvendo vetores. v1 #&gt; [1] 3 5 88 90 cte &lt;- 4 v1 * cte #&gt; [1] 12 20 352 360 O número 4 nesse caso é reciclado 4 vezes e então multiplicado por cada elemento do vetor v1. Avisos e erros: v1 &lt;- c(3, 5, 88, 90) srt(v1) #&gt; Error in srt(v1): could not find function &quot;srt&quot; sqrt(-v1) #&gt; Warning in sqrt(-v1): NaNs produced #&gt; [1] NaN NaN NaN NaN Comparações também funcionam com vetores. x &lt;= 5 #&gt; [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE x &gt; y #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE x &lt; y #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE Entre os operadores lógicos vistos (Tabela 6.2) alguns deles não foram aplicados em exemplos. Vamos então usar o operador %in% para verificar se um vetor está contido parcial ou totalmente em outro vetor. # operador está contido em 2:4 %in% x #&gt; [1] TRUE TRUE TRUE # 2:4 são elementos de x? is.element(2:4, x) #&gt; [1] TRUE TRUE TRUE A função nchar() também funciona sobre cada elemento do vetor. Esse é mais um exemplo de função vetorizada do R. nchar(month.name) #&gt; [1] 7 8 5 5 3 4 4 6 9 7 8 8 nchar(y) #&gt; [1] 2 2 2 2 2 1 1 1 1 1 7.2.2.1 Operadores any e all vetor &lt;- c(0, 1, -1, -2, 3, 5, -5) all(vetor &lt; 0) # todas as posições são maiores que 0 ? #&gt; [1] FALSE any(vetor &gt; 0) # alguma posição é maior que 0? #&gt; [1] TRUE Ambas as funções sintetizam a informação: all() verifica se a condição avaliada é válida para todos elementos do vetor; any() verifica se a condição avaliada é válida para pelo menos um dos elementos do vetor; As funções fornecem um único valor (vetor lógico de tamanho 1) para resumir ou descrever o resultado da condição aplicada ao vetor. 7.2.3 Sequências Vimos nas seções anteriores que é muito simples criar sequências de números inteiros com o operador :. Nesta seção veremos outras formas de gerar sequências, como uma sequência de números não inteiros e sequências de números repetidos. 7.2.3.1 Sequências de números inteiros Sequências de números formam um vetor. Há diversas formas de se gerar sequências no R. Para gerar uma sequência de 1 até 365, em vez de escrevermos cada número e combiná-los usando c(1,2,3,...,365), podemos usar o operador : da seguinte forma: # dias do ano dda &lt;- 1:365 dda #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #&gt; [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #&gt; [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #&gt; [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #&gt; [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #&gt; [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #&gt; [103] 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #&gt; [120] 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #&gt; [137] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #&gt; [154] 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 #&gt; [171] 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 #&gt; [188] 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 #&gt; [205] 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #&gt; [222] 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 #&gt; [239] 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 #&gt; [256] 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 #&gt; [273] 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 #&gt; [290] 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 #&gt; [307] 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #&gt; [324] 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 #&gt; [341] 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 #&gt; [358] 358 359 360 361 362 363 364 365 # sequencia de anos anos &lt;- 1961:1990 anos #&gt; [1] 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 #&gt; [15] 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 #&gt; [29] 1989 1990 # sequencia de inteiros decrescente si_dec &lt;- 10:-10 si_dec #&gt; [1] 10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 #&gt; [18] -7 -8 -9 -10 # sequencia de numeros não inteiros seqn &lt;- 1.5:10 seqn #&gt; [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 c(seqn, 10) #&gt; [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.0 7.2.3.2 Sequências de números não inteiros Mas para gerar uma sequencia de números não inteiros há uma função específica para tal tarefa. # igual a c(snum, 10), mas usando o seq (snum_b &lt;- seq(from = 1.5, to = 10, by = 0.5)) #&gt; [1] 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 #&gt; [15] 8.5 9.0 9.5 10.0 Exemplos de sequência de anos, meses e dias. # vetor com de anos decimais (2 valores por dia) anos_dec &lt;- seq(2010, 2011, length.out = 365 * 2) # para ver só o início do vetor ao invés de todo o vetor head(anos_dec) #&gt; [1] 2010.000 2010.001 2010.003 2010.004 2010.005 2010.007 # mas não dá pra ver a parte decimal, vamos alterar as opções # aumentando as casas decimais options(digits = 6) # verifique agora head(anos_dec) #&gt; [1] 2010.00 2010.00 2010.00 2010.00 2010.01 2010.01 # só os primeiros 30 elementos head(anos_dec, 30) #&gt; [1] 2010.00 2010.00 2010.00 2010.00 2010.01 2010.01 2010.01 2010.01 #&gt; [9] 2010.01 2010.01 2010.01 2010.02 2010.02 2010.02 2010.02 2010.02 #&gt; [17] 2010.02 2010.02 2010.02 2010.03 2010.03 2010.03 2010.03 2010.03 #&gt; [25] 2010.03 2010.03 2010.04 2010.04 2010.04 2010.04 # para ver só o final do vetor yrFrac tail(anos_dec) #&gt; [1] 2010.99 2010.99 2011.00 2011.00 2011.00 2011.00 # para ver só os último 50 elementos do yrFrac tail(anos_dec, 50) #&gt; [1] 2010.93 2010.93 2010.94 2010.94 2010.94 2010.94 2010.94 2010.94 #&gt; [9] 2010.94 2010.95 2010.95 2010.95 2010.95 2010.95 2010.95 2010.95 #&gt; [17] 2010.95 2010.96 2010.96 2010.96 2010.96 2010.96 2010.96 2010.96 #&gt; [25] 2010.97 2010.97 2010.97 2010.97 2010.97 2010.97 2010.97 2010.98 #&gt; [33] 2010.98 2010.98 2010.98 2010.98 2010.98 2010.98 2010.98 2010.99 #&gt; [41] 2010.99 2010.99 2010.99 2010.99 2010.99 2010.99 2011.00 2011.00 #&gt; [49] 2011.00 2011.00 # pentadas pent &lt;- seq(from = 1, to = 365, by = 5) # dencendios decd &lt;- seq(from = 1, to = 365, by = 10) # fracoes de dia frac_d30mn &lt;- seq(0, 365, length.out = 365 * 48) + 1 head(frac_d30mn, 48 * 2) #&gt; [1] 1.00000 1.02083 1.04167 1.06250 1.08334 1.10417 1.12501 1.14584 #&gt; [9] 1.16668 1.18751 1.20835 1.22918 1.25001 1.27085 1.29168 1.31252 #&gt; [17] 1.33335 1.35419 1.37502 1.39586 1.41669 1.43752 1.45836 1.47919 #&gt; [25] 1.50003 1.52086 1.54170 1.56253 1.58337 1.60420 1.62504 1.64587 #&gt; [33] 1.66670 1.68754 1.70837 1.72921 1.75004 1.77088 1.79171 1.81255 #&gt; [41] 1.83338 1.85422 1.87505 1.89588 1.91672 1.93755 1.95839 1.97922 #&gt; [49] 2.00006 2.02089 2.04173 2.06256 2.08340 2.10423 2.12506 2.14590 #&gt; [57] 2.16673 2.18757 2.20840 2.22924 2.25007 2.27091 2.29174 2.31257 #&gt; [65] 2.33341 2.35424 2.37508 2.39591 2.41675 2.43758 2.45842 2.47925 #&gt; [73] 2.50009 2.52092 2.54175 2.56259 2.58342 2.60426 2.62509 2.64593 #&gt; [81] 2.66676 2.68760 2.70843 2.72927 2.75010 2.77093 2.79177 2.81260 #&gt; [89] 2.83344 2.85427 2.87511 2.89594 2.91678 2.93761 2.95845 2.97928 tail(frac_d30mn, 48 * 2) #&gt; [1] 364.021 364.042 364.062 364.083 364.104 364.125 364.146 364.167 #&gt; [9] 364.187 364.208 364.229 364.250 364.271 364.292 364.312 364.333 #&gt; [17] 364.354 364.375 364.396 364.417 364.437 364.458 364.479 364.500 #&gt; [25] 364.521 364.542 364.562 364.583 364.604 364.625 364.646 364.667 #&gt; [33] 364.687 364.708 364.729 364.750 364.771 364.792 364.812 364.833 #&gt; [41] 364.854 364.875 364.896 364.917 364.937 364.958 364.979 365.000 #&gt; [49] 365.021 365.042 365.062 365.083 365.104 365.125 365.146 365.167 #&gt; [57] 365.187 365.208 365.229 365.250 365.271 365.292 365.312 365.333 #&gt; [65] 365.354 365.375 365.396 365.417 365.437 365.458 365.479 365.500 #&gt; [73] 365.521 365.542 365.562 365.583 365.604 365.625 365.646 365.667 #&gt; [81] 365.687 365.708 365.729 365.750 365.771 365.792 365.812 365.833 #&gt; [89] 365.854 365.875 365.896 365.917 365.937 365.958 365.979 366.000 # diferentes funções para gerar uma sequência an &lt;- c(1, 7, 2, 5, 3, 2) # gerando uma sequencia a partir de um número seq_len(length.out = 6) #&gt; [1] 1 2 3 4 5 6 # gerando uma sequência a partir de um número seq(6) #&gt; [1] 1 2 3 4 5 6 # de acordo com o tamanho do vetor gera-se uma sequencia seq(along = an) #&gt; [1] 1 2 3 4 5 6 seq(along = 0) # ! melhor opção para gerar sequencias do tamanho do vetor #&gt; [1] 1 seq(0) # ! cuidado, veja ?seq para entender a razão desse resultado inusitado #&gt; [1] 1 0 # conflito entre parâmetros # a &lt;-seq(from = -5, to = 5, by = 0.05, length.out=200) s5by &lt;- seq(from = -5, to = 5, by = 0.05) length(s5by) #&gt; [1] 201 tail(s5by) #&gt; [1] 4.75 4.80 4.85 4.90 4.95 5.00 s5len &lt;- seq(from = -5, to = 5, length.out = 200) length(s5len) #&gt; [1] 200 tail(s5len) #&gt; [1] 4.74874 4.79899 4.84925 4.89950 4.94975 5.00000 7.2.3.3 Sequências de números repetidos rep_t4 &lt;- rep(1:2, times = 4) rep_t4 #&gt; [1] 1 2 1 2 1 2 1 2 rep_e31 &lt;- rep(1:12, each = 31) rep_e31 #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [24] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [47] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 #&gt; [70] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #&gt; [93] 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 #&gt; [116] 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 #&gt; [139] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 #&gt; [162] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 #&gt; [185] 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #&gt; [208] 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 #&gt; [231] 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 #&gt; [254] 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 #&gt; [277] 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 #&gt; [300] 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 #&gt; [323] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 #&gt; [346] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 #&gt; [369] 12 12 12 12 rep_t13 &lt;- rep(c(&quot;chuva&quot;, &quot;sol&quot;), times = c(1, 3)) rep_t13 #&gt; [1] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; rep_t13_t4 &lt;- rep(rep(c(&quot;chuva&quot;, &quot;sol&quot;), times = c(1, 3)), times = 4) rep_t13_t4 #&gt; [1] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; #&gt; [9] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; 7.2.4 Indexação de vetores Os elementos de um vetor são indexados e para acessá-los usamos a notação de índices do R. Podemos selecionar partes de um vetor por números (posição do elemento), caracteres (nome) e vetores lógicos. Através do operador [ podemos acessar ou filtrar elementos de um vetor. O operador colchete [ aplicado a um vetor retornará um vetor. Considere os seguintes vetores como exemplo: # vetor de chuva mensal para um dado ano prec &lt;- c(300, 150, 210, 12, 0, 0, 12, 22, 80, 100, 0, 280) meses &lt;- c(&quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;, &quot;Abr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;, &quot;Set&quot;, &quot;Out&quot;, &quot;Nov&quot;, &quot;Dez&quot;) names(prec) &lt;- meses prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # gráfico de barras barplot(prec) box() # temperatura do ar média mensal para um dado ano temp &lt;- c(25, 23.2, 22.5, 21, 19, 17.6, 18, 19.7, 21.3, 22, 24, 26.8) names(temp) &lt;- meses temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 plot(temp, type = &quot;o&quot;) Como selecionar o valor de chuva e temperatura só para janeiro? Usando a seguinte sintaxe: vetor[i] onde i representa os elementos a serem selecionados. 7.2.4.1 Indexação por vetores inteiros 7.2.4.1.1 Positivos Para selecionar o valor de chuva e temperatura só para janeiro, digitamos: prec_jan &lt;- prec[1] prec_jan #&gt; Jan #&gt; 300 temp_jan &lt;- temp[1] temp_jan #&gt; Jan #&gt; 25 Como selecionar os últimos valores dos vetores de chuva e temperatura? # vetor de temperatura do ar média mensal de um ano qualquer temp_dez &lt;- temp[length(temp)] temp_dez #&gt; Dez #&gt; 26.8 prec_dez &lt;- prec[length(prec)] prec_dez #&gt; Dez #&gt; 280 Como selecionar os valores de chuva do trimestre JJA e de temperatura para o trimestre DJF? sel_prec &lt;- c(6, 7, 8) # vetor de chuva JJA prec_jja &lt;- prec[sel_prec] prec_jja #&gt; Jun Jul Ago #&gt; 0 12 22 # total de chuva trimestral nesse ano prect_jja_tot &lt;- sum(prec_jja) prect_jja_tot #&gt; [1] 34 # vetor de temperatura DJF sel_temp &lt;- c(12, 1, 2) temp_djf &lt;- temp[sel_temp] temp_djf #&gt; Dez Jan Fev #&gt; 26.8 25.0 23.2 # temp média trimestral nesse ano temp_djf_med &lt;- mean(temp_djf) temp_djf_med #&gt; [1] 25 7.2.4.1.2 Negativos Como selecionar todos valores menos o primeiro e o último? # exceto o primeiro e ultimo prec[-c(1, length(prec))] #&gt; Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; 150 210 12 0 0 12 22 80 100 0 # exceto os 3 primeiros meses temp[-c(1:3)] #&gt; Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # exceto os 3 últimos meses temp[-c(length(temp):(length(temp) - 2))] #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 7.2.4.2 Indexação por nomes prec[&quot;Jan&quot;] #&gt; Jan #&gt; 300 prec[c(&quot;Dez&quot;, &quot;Fev&quot;, &quot;Jun&quot;)] #&gt; Dez Fev Jun #&gt; 280 150 0 7.2.4.3 Indexação por vetores lógicos Vamos criar um vetor lógico e usá-lo para exemplificar a seleção lógica de elementos de um vetor. vetor_l &lt;- c( TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE ) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Abr&quot; &quot;Mai&quot; &quot;Jul&quot; &quot;Set&quot; &quot;Dez&quot; Os elementos de vetor_l correspondentes a TRUE foram selecionados. Aplicando-se a função sum() a um vetor lógico obtemos o total de elementos verdadeiros: sum(vetor_l) #&gt; [1] 6 Vamos considerar agora a seguinte forma do vetor lógico (vetor_l) e relembrar da coerção de vetores. # vetor lógico vetor_l &lt;- c(TRUE, FALSE) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Mar&quot; &quot;Mai&quot; &quot;Jul&quot; &quot;Set&quot; &quot;Nov&quot; vetor_l &lt;- c(TRUE, FALSE, FALSE) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Abr&quot; &quot;Jul&quot; &quot;Out&quot; prec[c(TRUE, FALSE)] #&gt; Jan Mar Mai Jul Set Nov #&gt; 300 210 0 12 80 0 temp[c(rep(FALSE, 3), TRUE)] #&gt; Abr Ago Dez #&gt; 21.0 19.7 26.8 A indexação pode ser feita também por comparações: # vetor prec prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # teste para chuva &gt; 80 mm/mês prec &gt; 80 #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE # salvando resultado do teste above80 &lt;- prec &gt; 80 # extraindo valores atendidos ao teste prec[above80] #&gt; Jan Fev Mar Out Dez #&gt; 300 150 210 100 280 # teste para meses com chuva abaixo da média mensal (prec_med &lt;- mean(prec)) #&gt; [1] 97.1667 # salvando resultado do teste (below_avg &lt;- prec &lt; prec_med) #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE # extraindo valores que atendem a condição prec[below_avg] #&gt; Abr Mai Jun Jul Ago Set Nov #&gt; 12 0 0 12 22 80 0 # extraindo os 3 primeiros meses com prec abaixo da média prec[below_avg][1:3] #&gt; Abr Mai Jun #&gt; 12 0 0 # forma equivalente em uma linha só prec[prec &lt; mean(prec)][1:3] #&gt; Abr Mai Jun #&gt; 12 0 0 # teste para meses com prec diferente de zero prec[prec != 0] #&gt; Jan Fev Mar Abr Jul Ago Set Out Dez #&gt; 300 150 210 12 12 22 80 100 280 7.2.4.4 Indexação com múltiplas condições Nos exemplo acima vimos como buscar os os elementos de um vetor para apenas uma condição. Entretanto frequentemente precisamos testar mais condições. Por exemplo, para condições do tipo: \\(0.5 &lt; prec \\leq 100\\) \\(temp &lt; 5\\) ou \\(temp \\geq 25\\) precisamos usar os operadores relacionais: &amp; e &amp;&amp; (&quot;e“) | e || (&quot;ou“) A ordem das operações pode ser controladas por parênteses. Os operadores &amp; e | são vetorizados (retornam vetores de mesmo tamanho que os vetores testados). As diferenças entre os operadores são mostradas nos exemplos a seguir. # prec prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # combinação de operador lógico e relacional below100 &lt;- prec &gt; 0 &amp; prec &lt;= 100 prec_cond1 &lt;- prec[below100] prec_cond1 #&gt; Abr Jul Ago Set Out #&gt; 12 12 22 80 100 A forma dupla (&amp;&amp; ou ||) compara somente um elemento de cada lado, enquanto a forma normal (&amp; e |), compara cada elemento dos vetores em cada lado. a &lt;- c(1, 1, 0, 1) b &lt;- c(2, 1, 0, 1) # forma normal verifica cada elemento de a e cada elemento de b a == 1 &amp; b == 1 #&gt; [1] FALSE TRUE FALSE TRUE # forma dupla verifica somente o primeiro elemento de a e o primeiro elemento de b # retornando somente um resultado a == 1 &amp;&amp; b == 1 #&gt; [1] FALSE Demostração da diferença entre &amp; e &amp;&amp;. a b a==1 b==1 a == 1 &amp; b == 1 a == 1 &amp;&amp; b == 1 1 2 TRUE FALSE FALSE FALSE 1 1 TRUE TRUE TRUE 0 0 FALSE FALSE FALSE 1 1 TRUE TRUE TRUE Podem haver mais que duas condições a serem testadas. As condições podem ser combinadas usando múltiplos &amp; ou |. As diferentes condições podem ser agrupadas por parênteses assim como operações matemáticas. Sem parênteses, a ordem das operações é semelhante a das operações matemáticas: PEMDAS: Parênteses &gt; Expoentes &gt; Multiplicação &gt; Divisão &gt; Adição e Subtração Onde &amp;é equivalente à multiplicação e | é equivalente à adição, logo e tem precedência sobre ou. # vetor de horas horas &lt;- 0:23 # vetor de temperaturas horárias tar_hor &lt;- c( 19.9, 19.8, 19.5, 19.4, 19.4, 19.3, 19.2, 19, 19.2, 19.5, 20.1, 20.6, 20.9, 21.8, 22.5, 22.6, 22.5, 22, 21.4, 20.1, 20, 19.8, 19.6, 19.4 ) # gráfico do varição horária da temperatura do ar plot(horas, tar_hor, type = &quot;o&quot;, pch = 20) # temperaturas noturnas abaixo de 20ºC (night_below20 &lt;- (horas &lt; 6 | horas &gt; 18) &amp; tar_hor &lt; 20) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE #&gt; [23] TRUE TRUE tar_hor[night_below20] #&gt; [1] 19.9 19.8 19.5 19.4 19.4 19.3 19.8 19.6 19.4 # destacando no gráfico points( x = horas[night_below20], y = tar_hor[night_below20], pch = 20, # tipo de símbolo para os ponts col = &quot;blue&quot;, # cor do símbolo cex = 2 ) # tamanho do ponto # temperaturas abaixo de 20ºC que não ocorreram a noite day_below20 &lt;- tar_hor &lt; 20 &amp; !night_below20 points(horas[day_below20], tar_hor[day_below20], pch = 20, col = &quot;red&quot;, cex = 2) # adicionando linha horizontal ao longo da temperatura = 20ºC abline(h = 20, col = &quot;gray&quot;) Vimos que a filtragem consiste em extrair elementos de um vetor que satisfaça uma (ou várias) condição(ões). Entretanto, em alguns casos, o interesse é na posição dentro do vetor na qual a condição é verdadeira Nós podemos localizar essas ocorrências usando a função which(): # prec sem nomes names(prec) &lt;- NULL # combinação de operador lógico e relacional below100 #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE which(below100) #&gt; Abr Jul Ago Set Out #&gt; 4 7 8 9 10 # qual os meses em que a chuva foi acima da media which(prec &gt; prec_med) #&gt; [1] 1 2 3 10 12 prec[which(prec &gt; prec_med)] #&gt; [1] 300 150 210 100 280 # Qual a temp quando a chuva ou a temp foi acima da media? sel &lt;- which(prec &gt; prec_med | !temp &lt; mean(temp)) sel #&gt; Jan Fev Mar Out Nov Dez #&gt; 1 2 3 10 11 12 prec[sel] #&gt; [1] 300 150 210 100 0 280 # quais posições do vetor prec não choveu which(prec == 0) #&gt; [1] 5 6 11 # quando ocorreu a prec max which(prec == max(prec)) #&gt; [1] 1 # equivalente a ... which.max(prec) #&gt; [1] 1 # seleciona só a primeira ocorrência! which.min(prec) #&gt; [1] 5 prec #&gt; [1] 300 150 210 12 0 0 12 22 80 100 0 280 Um outro operador útil para comparação entre vetores é o operador %in%, que pode ser interpretado como &quot;está contido em&quot;. O resultado é um vetor de mesmo tamanho que o vetor à esquerda do teste. # compare o tamanho dos vetores resultantes which(meses %in% c(&quot;JAN&quot;, &quot;Feb&quot;, &quot;Mar&quot;)) #&gt; [1] 3 # note a diferença which(c(&quot;JAN&quot;, &quot;Feb&quot;, &quot;Mar&quot;) %in% meses) #&gt; [1] 3 cond &lt;- names(temp) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;) quais &lt;- which(cond) quais #&gt; [1] 6 7 8 prec[cond] #&gt; [1] 0 12 22 prec[quais] #&gt; [1] 0 12 22 7.2.5 Substituição de elementos de um vetor # posição a ser alterada pos &lt;- 10 # valor da temperatura naquela posição old_temp &lt;- temp[pos] old_temp #&gt; Out #&gt; 22 # vetor de temperatura temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # substituição do valor original por um novo valor new_temp &lt;- 30 # alterando temperatura do mês de outubro temp[pos] &lt;- new_temp temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 30.0 24.0 26.8 A substituição também pode ser feita também pelo nome das variáveis. prec #&gt; [1] 300 150 210 12 0 0 12 22 80 100 0 280 prec[&quot;Mai&quot;] &lt;- 5 temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 30.0 24.0 26.8 temp[c(&quot;Mai&quot;, &quot;Jul&quot;)] &lt;- temp[c(&quot;Mai&quot;, &quot;Jul&quot;)] + 2 temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 21.0 17.6 20.0 19.7 21.3 30.0 24.0 26.8 7.2.6 Criação de vetores com vector Outra forma de se criar vetores é através da função vector(). # criação de vetor v v &lt;- 3 v #&gt; [1] 3 # adicionando elementos v[2] &lt;- 100 v #&gt; [1] 3 100 v[5] &lt;- 6 v #&gt; [1] 3 100 NA NA 6 # adicionando elementos de vetores x &lt;- c(88, 5, 12, 13) x &lt;- c(x[1:3], 168, x[4]) # insere 168 antes do 13 x #&gt; [1] 88 5 12 168 13 # outra opção k &lt;- vector() class(k) #&gt; [1] &quot;logical&quot; # vetor k existe? ls() #&gt; [1] &quot;a&quot; &quot;a_sn&quot; &quot;above80&quot; &quot;an&quot; #&gt; [5] &quot;anos&quot; &quot;anos_dec&quot; &quot;b&quot; &quot;below_avg&quot; #&gt; [9] &quot;below100&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; &quot;meses&quot; #&gt; [21] &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; &quot;old_temp&quot; #&gt; [25] &quot;oper&quot; &quot;pcks&quot; &quot;pent&quot; &quot;pos&quot; #&gt; [29] &quot;prec&quot; &quot;prec_cond1&quot; &quot;prec_dez&quot; &quot;prec_jan&quot; #&gt; [33] &quot;prec_jja&quot; &quot;prec_med&quot; &quot;prect_jja_tot&quot; &quot;quais&quot; #&gt; [37] &quot;rblue&quot; &quot;rep_e31&quot; &quot;rep_t13&quot; &quot;rep_t13_t4&quot; #&gt; [41] &quot;rep_t4&quot; &quot;s5by&quot; &quot;s5len&quot; &quot;seco&quot; #&gt; [45] &quot;seco01&quot; &quot;sel&quot; &quot;sel_prec&quot; &quot;sel_temp&quot; #&gt; [49] &quot;seqn&quot; &quot;si_dec&quot; &quot;snum_b&quot; &quot;tar_hor&quot; #&gt; [53] &quot;temp&quot; &quot;temp_dez&quot; &quot;temp_djf&quot; &quot;temp_djf_med&quot; #&gt; [57] &quot;temp_jan&quot; &quot;v&quot; &quot;v_123&quot; &quot;v_123a&quot; #&gt; [61] &quot;v_123b&quot; &quot;v1&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [65] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [69] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [73] &quot;z&quot; # alocando o valor 45 no 3º elemento de k k[3] &lt;- 45 k #&gt; [1] NA NA 45 class(k) #&gt; [1] &quot;numeric&quot; # diminuindo o tamanho de k length(k) #&gt; [1] 3 length(k) &lt;- 2 k #&gt; [1] NA NA length(k) &lt;- 0 k #&gt; numeric(0) class(k) #&gt; [1] &quot;numeric&quot; is.null(k) #&gt; [1] FALSE # exemplo temp &lt;- c(25, 23.2, 22.5, 21, 19, 17.6, 18, 19.7, 21.3, 22, 24, 26.8) temp_orig &lt;- temp # mostrando o vetor temp temp #&gt; [1] 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 temp[] #&gt; [1] 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # substituir todos elementos do vetor temp por um vetor com apenas um valor temp &lt;- 0 temp #&gt; [1] 0 # vamos redefinir temp e comparar o anterior com o obtido com o próximo comando temp &lt;- temp_orig temp[1:length(temp)] &lt;- 0 temp #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 # qual diferença de x &lt;- 0 e x[] &lt;-0 ? temp &lt;- temp_orig temp[] &lt;- 0 temp #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 # Um vetor com tamanho pre-definido e do tipo numeric umvetor &lt;- vector(mode = &quot;numeric&quot;, length = 100) umvetor #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [36] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [71] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 # populando o vetor umvetor[1] &lt;- 10 umvetor[10] &lt;- 100 umvetor #&gt; [1] 10 0 0 0 0 0 0 0 0 100 0 0 0 0 0 0 0 #&gt; [18] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [35] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [52] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [69] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [86] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7.2.7 Vetores nulos e elementos faltantes Seja qual for a razão, ao realizar um experimento em condições reais sempre haverá situações em que não conhecemos o valor de uma determinada variável. Por exemplo, a série de uma variável meteorológica medida em estação de superfície, sempre ocorrem datas em que não há registro da variável. Falha instrumental, dado não coletado pelo observador, falta de energia, são causas inerentes de falhas em séries climáticas de longo prazo. No R dados faltantes são representados pela string NA. v1 &lt;- c(1:8, NA) v1 &gt; 5 # NA sai na resposta #&gt; [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE NA # teste lógico com o operador idêntico &quot;==&quot; v1 == NA #&gt; [1] NA NA NA NA NA NA NA NA NA # não funcionou, porque há funções específicas para vetores com NA onde_falta &lt;- is.na(v1) # função apropriada p/ checar se tem NAs faltante &lt;- which(is.na(v1)) v1[-faltante] #&gt; [1] 1 2 3 4 5 6 7 8 # ou v1[!onde_falta] #&gt; [1] 1 2 3 4 5 6 7 8 # vamos calcular a média de v1 sum(v1) / length(v1) #&gt; [1] NA # vamos remover valores NA sum(v1[-faltante]) / length(v1[-faltante]) #&gt; [1] 4.5 sum(v1[!onde_falta]) / length(v1[!onde_falta]) #&gt; [1] 4.5 # mas o R possui a função mean mean(v1) #&gt; [1] NA # não retornou o que desejamos, removendo as posicoes dos dados faltantes mean(v1[-faltante]) #&gt; [1] 4.5 # ok, mas olhando o help ... # ?mean mean(v1, na.rm = TRUE) #&gt; [1] 4.5 # definir como faltante todos elementos de v1 v1[] &lt;- NA v1 #&gt; [1] NA NA NA NA NA NA NA NA NA length(v1) #&gt; [1] 9 # vetor com dados faltantes indicados por -999 # substituir onde é -999 por NA x &lt;- c(-999, 10, 15, -999, 50) x == -999 #&gt; [1] TRUE FALSE FALSE TRUE FALSE x[x == -999] &lt;- NA # total de dados faltantes sum(!is.na(x)) #&gt; [1] 3 7.2.8 Diferença entre NA e NULL O NULL é um tipo de dado especial do R. # v1 existe ? ls() #&gt; [1] &quot;a&quot; &quot;a_sn&quot; &quot;above80&quot; &quot;an&quot; #&gt; [5] &quot;anos&quot; &quot;anos_dec&quot; &quot;b&quot; &quot;below_avg&quot; #&gt; [9] &quot;below100&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;faltante&quot; &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; #&gt; [21] &quot;meses&quot; &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; #&gt; [25] &quot;old_temp&quot; &quot;onde_falta&quot; &quot;oper&quot; &quot;pcks&quot; #&gt; [29] &quot;pent&quot; &quot;pos&quot; &quot;prec&quot; &quot;prec_cond1&quot; #&gt; [33] &quot;prec_dez&quot; &quot;prec_jan&quot; &quot;prec_jja&quot; &quot;prec_med&quot; #&gt; [37] &quot;prect_jja_tot&quot; &quot;quais&quot; &quot;rblue&quot; &quot;rep_e31&quot; #&gt; [41] &quot;rep_t13&quot; &quot;rep_t13_t4&quot; &quot;rep_t4&quot; &quot;s5by&quot; #&gt; [45] &quot;s5len&quot; &quot;seco&quot; &quot;seco01&quot; &quot;sel&quot; #&gt; [49] &quot;sel_prec&quot; &quot;sel_temp&quot; &quot;seqn&quot; &quot;si_dec&quot; #&gt; [53] &quot;snum_b&quot; &quot;tar_hor&quot; &quot;temp&quot; &quot;temp_dez&quot; #&gt; [57] &quot;temp_djf&quot; &quot;temp_djf_med&quot; &quot;temp_jan&quot; &quot;temp_orig&quot; #&gt; [61] &quot;umvetor&quot; &quot;v&quot; &quot;v_123&quot; &quot;v_123a&quot; #&gt; [65] &quot;v_123b&quot; &quot;v1&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [69] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [73] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [77] &quot;z&quot; exists(&quot;v1&quot;) #&gt; [1] TRUE # vamos anular todo v1 v1 &lt;- NULL ls() #&gt; [1] &quot;a&quot; &quot;a_sn&quot; &quot;above80&quot; &quot;an&quot; #&gt; [5] &quot;anos&quot; &quot;anos_dec&quot; &quot;b&quot; &quot;below_avg&quot; #&gt; [9] &quot;below100&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;faltante&quot; &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; #&gt; [21] &quot;meses&quot; &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; #&gt; [25] &quot;old_temp&quot; &quot;onde_falta&quot; &quot;oper&quot; &quot;pcks&quot; #&gt; [29] &quot;pent&quot; &quot;pos&quot; &quot;prec&quot; &quot;prec_cond1&quot; #&gt; [33] &quot;prec_dez&quot; &quot;prec_jan&quot; &quot;prec_jja&quot; &quot;prec_med&quot; #&gt; [37] &quot;prect_jja_tot&quot; &quot;quais&quot; &quot;rblue&quot; &quot;rep_e31&quot; #&gt; [41] &quot;rep_t13&quot; &quot;rep_t13_t4&quot; &quot;rep_t4&quot; &quot;s5by&quot; #&gt; [45] &quot;s5len&quot; &quot;seco&quot; &quot;seco01&quot; &quot;sel&quot; #&gt; [49] &quot;sel_prec&quot; &quot;sel_temp&quot; &quot;seqn&quot; &quot;si_dec&quot; #&gt; [53] &quot;snum_b&quot; &quot;tar_hor&quot; &quot;temp&quot; &quot;temp_dez&quot; #&gt; [57] &quot;temp_djf&quot; &quot;temp_djf_med&quot; &quot;temp_jan&quot; &quot;temp_orig&quot; #&gt; [61] &quot;umvetor&quot; &quot;v&quot; &quot;v_123&quot; &quot;v_123a&quot; #&gt; [65] &quot;v_123b&quot; &quot;v1&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [69] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [73] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [77] &quot;z&quot; v1 #&gt; NULL # NULL vetor1 &lt;- c() vetor2 &lt;- NULL is.null(c(vetor1, vetor2)) #&gt; [1] TRUE # vetor1 e vetor2 são equivalentes? identical(vetor1, vetor2) #&gt; [1] TRUE # remoção de elementos de um vetor com NULL a &lt;- c(10, 2, NA, 20) a #&gt; [1] 10 2 NA 20 typeof(a) #&gt; [1] &quot;double&quot; # remover de a o dado faltante a &lt;- a[!is.na(a)] a #&gt; [1] 10 2 20 # é possível remover um elemento com o NULL? a[length(a)] &lt;- NULL #&gt; Error in a[length(a)] &lt;- NULL: replacement has length zero a #&gt; [1] 10 2 20 a &lt;- a[-length(a)] a #&gt; [1] 10 2 typeof(a) #&gt; [1] &quot;double&quot; # anulando a a &lt;- NULL # qual modo de um objeto nulo? typeof(a) #&gt; [1] &quot;NULL&quot; # qual modo de NA? b &lt;- NA b #&gt; [1] NA typeof(b) #&gt; [1] &quot;logical&quot; length(a) #&gt; [1] 0 length(b) #&gt; [1] 1 "],
["matriz.html", "7.3 Matriz", " 7.3 Matriz Vetores são dados unidimensionais. Vetores multidimensionais são denominados arranjos (tradução do termo em inglês array). As matrizes são um caso especial de array em que o número de dimensões é igual a 2, uma dimensão corresponde as linhas e a outra as colunas. Os dados armazenados em uma matriz só podem ser de um tipo de dado (ou numeric, ou character, por exemplo). 7.3.1 Criação de matrizes 7.3.1.1 Função matrix() Uma forma mais clara de se criar uma matriz é usando a função matrix(). Ao aplicarmos a função matrix() a um vetor sem especificar nenhum argumento ela produz uma matriz de uma coluna. # atribuindo novas dimensões ao vetor m &lt;- matrix(vetor) # matriz de uma coluna m #&gt; [,1] #&gt; [1,] 0 #&gt; [2,] 1 #&gt; [3,] -1 #&gt; [4,] -2 #&gt; [5,] 3 #&gt; [6,] 5 #&gt; [7,] -5 Se desejamos construir uma matriz com 3 linhas e 4 colunas a partir do vetor vetor podemos fazer da seguinte forma: # criando a matriz gerada com dim mat &lt;- matrix(vetor, nrow = 3, ncol = 4) #&gt; Warning in matrix(vetor, nrow = 3, ncol = 4): data length [7] is not a sub- #&gt; multiple or multiple of the number of rows [3] mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 -2 -5 -1 #&gt; [2,] 1 3 0 -2 #&gt; [3,] -1 5 1 3 # não há necessidade de especificar ambos ncol e nrow mat &lt;- matrix(vetor, nrow = 3) #&gt; Warning in matrix(vetor, nrow = 3): data length [7] is not a sub-multiple #&gt; or multiple of the number of rows [3] mat #&gt; [,1] [,2] [,3] #&gt; [1,] 0 -2 -5 #&gt; [2,] 1 3 0 #&gt; [3,] -1 5 1 No exemplo a seguir os dados do vetor aparecem distribuídos ao longo das linhas e não das colunas como no caso acima. Nós definimos isso com o argumento byrow = TRUE da função matrix(): mat &lt;- matrix(vetor, ncol = 4, byrow = TRUE) #&gt; Warning in matrix(vetor, ncol = 4, byrow = TRUE): data length [7] is not a #&gt; sub-multiple or multiple of the number of rows [2] mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 1 -1 -2 #&gt; [2,] 3 5 -5 0 7.3.2 Nomes das linhas e colunas de uma matriz Nas matrizes, assim como nos vetores, também é possível dar nomes aos elementos para tornar a leitura da informação mais clara. Vamos usar os vetores de temperatura mensal dos anos de 1990:1992para construir uma matriz com os meses ao longo das colunas e os anos ao longo das linhas. # temperatura do ar média mensal do ano de 1990 temp90 &lt;- c( 25.00, 23.20, 22.50, 21.00, 19.00, 17.60, 18.00, 19.70, 21.30, 22.00, 24.00, 26.80 ) # temperatura do ar média mensal do ano de 1991 temp91 &lt;- c( 24.89, 24.07, 23.56, 23.11, 18.29, 18.22, 16.72, 19.37, 20.08, 21.45, 26.61, 25.99 ) # temperatura do ar média mensal do ano de 1992 temp92 &lt;- c( 23.2, 26.61, 18, 23.11, 26.8, 21.3, 18.22, 21.45, 19.7, 22.5, 24.07, 20.08 ) # vetor com as temperaturas dos 3 anos vtemp &lt;- c(temp90, temp91, temp92) vtemp #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 # arranjar matrix com meses ao longo das colunas e anos ao longo das linhas temp_mat &lt;- matrix(vtemp, ncol = 12, byrow = TRUE) temp_mat #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; [1,] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [2,] 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; [3,] 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; [1,] 26.80 #&gt; [2,] 25.99 #&gt; [3,] 20.08 # cópia da matriz temp_mat (sem nomes) temp_matO &lt;- temp_mat Atribuindo nomes às linhas (rownames()) e colunas (colnames()) da matriz criada dos vetores de temperatura mensal (temp_mat). # atribuindo nomes as colunas e linhas da temp_mat rownames(temp_mat) &lt;- c(&quot;ano1990&quot;, &quot;ano1991&quot;, &quot;ano1992&quot;) colnames(temp_mat) &lt;- c( &quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;, &quot;Abr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;, &quot;Set&quot;, &quot;Out&quot;, &quot;Nov&quot;, &quot;Dez&quot; ) temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 7.3.3 Indexação de matrizes Como acessamos o valor de temperatura de maio de 1991 na matriz temp_mat? temp_mat # matriz de temperaturas com nomes #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 temp_matO # matriz de temperaturas sem nomes #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; [1,] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [2,] 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; [3,] 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; [1,] 26.80 #&gt; [2,] 25.99 #&gt; [3,] 20.08 # qual a linha do ano de 1991 linha &lt;- 2 # qual a coluna do mês de maio coluna &lt;- 5 # extraindo temp_mat[linha, coluna] #&gt; [1] 18.29 # ou usando os nomes temp_mat[&quot;ano1991&quot;, &quot;Mai&quot;] #&gt; [1] 18.29 Com o operador [ podemos usar todos os esquemas de indexação vistos em vetores. # temperaturas de todos janeiros temp_mat[, 1] #&gt; ano1990 ano1991 ano1992 #&gt; 25.00 24.89 23.20 temp_mat[, &quot;Jan&quot;] #&gt; ano1990 ano1991 ano1992 #&gt; 25.00 24.89 23.20 # só as temperaturas de 1990 e 1993 temp_mat[ -2, ] #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; ano1990 25.0 23.20 22.5 21.00 19.0 17.6 18.00 19.70 21.3 22.0 24.00 26.80 #&gt; ano1992 23.2 26.61 18.0 23.11 26.8 21.3 18.22 21.45 19.7 22.5 24.07 20.08 # só as temperaturas dos verões temp_mat[, c(12, 1, 2)] #&gt; Dez Jan Fev #&gt; ano1990 26.80 25.00 23.20 #&gt; ano1991 25.99 24.89 24.07 #&gt; ano1992 20.08 23.20 26.61 # invertendo ordem das colunas temp_mat[, ncol(temp_mat):1] #&gt; Dez Nov Out Set Ago Jul Jun Mai Abr Mar Fev #&gt; ano1990 26.80 24.00 22.00 21.30 19.70 18.00 17.60 19.00 21.00 22.50 23.20 #&gt; ano1991 25.99 26.61 21.45 20.08 19.37 16.72 18.22 18.29 23.11 23.56 24.07 #&gt; ano1992 20.08 24.07 22.50 19.70 21.45 18.22 21.30 26.80 23.11 18.00 26.61 #&gt; Jan #&gt; ano1990 25.00 #&gt; ano1991 24.89 #&gt; ano1992 23.20 # invertendo ordem das colunas e das linhas temp_mat[ 3:1, 12:1] #&gt; Dez Nov Out Set Ago Jul Jun Mai Abr Mar Fev #&gt; ano1992 20.08 24.07 22.50 19.70 21.45 18.22 21.30 26.80 23.11 18.00 26.61 #&gt; ano1991 25.99 26.61 21.45 20.08 19.37 16.72 18.22 18.29 23.11 23.56 24.07 #&gt; ano1990 26.80 24.00 22.00 21.30 19.70 18.00 17.60 19.00 21.00 22.50 23.20 #&gt; Jan #&gt; ano1992 23.20 #&gt; ano1991 24.89 #&gt; ano1990 25.00 # invertendo ordem das colunas e das linhas temp_mat[ c(2, 1, 3), c(6:1, 12, 10:8)] #&gt; Jun Mai Abr Mar Fev Jan Dez Out Set Ago #&gt; ano1991 18.22 18.29 23.11 23.56 24.07 24.89 25.99 21.45 20.08 19.37 #&gt; ano1990 17.60 19.00 21.00 22.50 23.20 25.00 26.80 22.00 21.30 19.70 #&gt; ano1992 21.30 26.80 23.11 18.00 26.61 23.20 20.08 22.50 19.70 21.45 # só as temperaturas dos invernos temp_mat[, colnames(temp_mat) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;) ] #&gt; Jun Jul Ago #&gt; ano1990 17.60 18.00 19.70 #&gt; ano1991 18.22 16.72 19.37 #&gt; ano1992 21.30 18.22 21.45 # exceto as temperaturas dos invernos temp_mat[, -which(colnames(temp_mat) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;)) ] #&gt; Jan Fev Mar Abr Mai Set Out Nov Dez #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 21.30 22.00 24.00 26.80 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 20.08 21.45 26.61 25.99 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 19.70 22.50 24.07 20.08 # seleção de colunas intercaladas da matriz: mês sim, mês nao temp_mat[, c(TRUE, FALSE)] #&gt; Jan Mar Mai Jul Set Nov #&gt; ano1990 25.00 22.50 19.00 18.00 21.30 24.00 #&gt; ano1991 24.89 23.56 18.29 16.72 20.08 26.61 #&gt; ano1992 23.20 18.00 26.80 18.22 19.70 24.07 # 2 meses sim, 1 mes não temp_mat[, c(TRUE, TRUE, FALSE)] #&gt; Jan Fev Abr Mai Jul Ago Out Nov #&gt; ano1990 25.00 23.20 21.00 19.00 18.00 19.70 22.00 24.00 #&gt; ano1991 24.89 24.07 23.11 18.29 16.72 19.37 21.45 26.61 #&gt; ano1992 23.20 26.61 23.11 26.80 18.22 21.45 22.50 24.07 Podemos fazer uso do operador [ de forma aninhada: temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 temp_mat[, 1:6] #&gt; Jan Fev Mar Abr Mai Jun #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 temp_mat[, 1:6][&quot;ano1991&quot;, ] #&gt; Jan Fev Mar Abr Mai Jun #&gt; 24.89 24.07 23.56 23.11 18.29 18.22 temp_mat[, 1:6][&quot;ano1991&quot;, ][2:4] #&gt; Fev Mar Abr #&gt; 24.07 23.56 23.11 Podemos substituir valores de uma submatriz da matriz: M &lt;- temp_mat M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 # 1990 e 1992 os meses de jan e dez M[c(1, 3), c(1, 12)] #&gt; Jan Dez #&gt; ano1990 25.0 26.80 #&gt; ano1992 23.2 20.08 # matriz com novos valores matrix(c(21, 22, 23, 24), ncol = 2) #&gt; [,1] [,2] #&gt; [1,] 21 23 #&gt; [2,] 22 24 # substituindo M[c(1, 3), c(1, 12)] &lt;- matrix(c(21, 22, 23, 24), ncol = 2) M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 21.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 22.00 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 23.00 #&gt; ano1991 25.99 #&gt; ano1992 24.00 7.3.4 Número de linhas e colunas de uma matriz M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 21.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 22.00 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 23.00 #&gt; ano1991 25.99 #&gt; ano1992 24.00 ncol(temp_mat) #&gt; [1] 12 nrow(temp_mat) #&gt; [1] 3 dim(temp_mat) #&gt; [1] 3 12 Existem funções específicas para saber a coluna e a linha de cada elemento de uma matriz. # colunas de cada elemento da matriz col(temp_mat) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 11 12 #&gt; [2,] 1 2 3 4 5 6 7 8 9 10 11 12 #&gt; [3,] 1 2 3 4 5 6 7 8 9 10 11 12 # linhas de cada elemento da matriz row(temp_mat) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; [1,] 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [2,] 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [3,] 3 3 3 3 3 3 3 3 3 3 3 3 7.3.5 Adição de linhas e colunas a uma matriz Na construção de um vetor concatenaram-se valores com a função c(). A concatenação por linhas ou colunas em uma matriz pode ser feita com as funções rbind() e cbind(), respectivamente. No exemplo abaixo concatenam-se vetores de temperaturas mensais de 3 anos (ver seção 7.3.2), primeiro por linhas e depois por colunas. (temp_mat_lin &lt;- rbind(temp90, temp91, temp92)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; temp90 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; temp91 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; temp92 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; temp90 26.80 #&gt; temp91 25.99 #&gt; temp92 20.08 (temp_mat_col &lt;- cbind(temp90, temp91, temp92)) #&gt; temp90 temp91 temp92 #&gt; [1,] 25.0 24.89 23.20 #&gt; [2,] 23.2 24.07 26.61 #&gt; [3,] 22.5 23.56 18.00 #&gt; [4,] 21.0 23.11 23.11 #&gt; [5,] 19.0 18.29 26.80 #&gt; [6,] 17.6 18.22 21.30 #&gt; [7,] 18.0 16.72 18.22 #&gt; [8,] 19.7 19.37 21.45 #&gt; [9,] 21.3 20.08 19.70 #&gt; [10,] 22.0 21.45 22.50 #&gt; [11,] 24.0 26.61 24.07 #&gt; [12,] 26.8 25.99 20.08 7.3.6 Matriz transposta e diagonal A primeira entre as diversas funções de álgebra matricial no R é a transposta t(). temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 t(temp_mat) #&gt; ano1990 ano1991 ano1992 #&gt; Jan 25.0 24.89 23.20 #&gt; Fev 23.2 24.07 26.61 #&gt; Mar 22.5 23.56 18.00 #&gt; Abr 21.0 23.11 23.11 #&gt; Mai 19.0 18.29 26.80 #&gt; Jun 17.6 18.22 21.30 #&gt; Jul 18.0 16.72 18.22 #&gt; Ago 19.7 19.37 21.45 #&gt; Set 21.3 20.08 19.70 #&gt; Out 22.0 21.45 22.50 #&gt; Nov 24.0 26.61 24.07 #&gt; Dez 26.8 25.99 20.08 # diagonal diag(temp_mat) #&gt; [1] 25.00 24.07 18.00 Operações matriciais adicionais são apresentadas no Apêndice A. 7.3.7 Conversão de matriz para vetor Frequentemente é mais conveniente trabalhar com um vetor do que com uma matriz, por isso precisamos saber como fazer o caminho inverso. Quando criamos uma matriz (p. ex.: temp_mat) no início da seção ela foi baseada em um vetor (vtemp). Como fazemos para voltar aquele vetor original a partir da matriz? temp_mat[1:nrow(temp_mat) * ncol(temp_mat) ] #&gt; [1] 23.11 21.45 20.08 # vetor de temperaturas vtemp &lt;- temp_mat[1:(ncol(temp_mat) * nrow(temp_mat))] vtemp #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # outra forma de converte temp_mat para vetor c(temp_mat) #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # função formal para converter as.vector(temp_mat) #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # para desmanchar a matriz com os elementos seguindo a ordem das linhas c(t(temp_mat)) #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 as.vector(t(temp_mat)) #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 # serie temporal de temp_mat stemp &lt;- c(t(temp_mat)) plot(stemp, type = &quot;o&quot;) # criar matriz com colunas temp e meses 1:12 cbind(rep(1:12, nrow(temp_mat)), stemp) #&gt; stemp #&gt; [1,] 1 25.00 #&gt; [2,] 2 23.20 #&gt; [3,] 3 22.50 #&gt; [4,] 4 21.00 #&gt; [5,] 5 19.00 #&gt; [6,] 6 17.60 #&gt; [7,] 7 18.00 #&gt; [8,] 8 19.70 #&gt; [9,] 9 21.30 #&gt; [10,] 10 22.00 #&gt; [11,] 11 24.00 #&gt; [12,] 12 26.80 #&gt; [13,] 1 24.89 #&gt; [14,] 2 24.07 #&gt; [15,] 3 23.56 #&gt; [16,] 4 23.11 #&gt; [17,] 5 18.29 #&gt; [18,] 6 18.22 #&gt; [19,] 7 16.72 #&gt; [20,] 8 19.37 #&gt; [21,] 9 20.08 #&gt; [22,] 10 21.45 #&gt; [23,] 11 26.61 #&gt; [24,] 12 25.99 #&gt; [25,] 1 23.20 #&gt; [26,] 2 26.61 #&gt; [27,] 3 18.00 #&gt; [28,] 4 23.11 #&gt; [29,] 5 26.80 #&gt; [30,] 6 21.30 #&gt; [31,] 7 18.22 #&gt; [32,] 8 21.45 #&gt; [33,] 9 19.70 #&gt; [34,] 10 22.50 #&gt; [35,] 11 24.07 #&gt; [36,] 12 20.08 # dados de temp e meses tempdat &lt;- cbind(1:12, stemp) # plot da temperatura pelos meses (os meses repetem) plot( tempdat, type = &quot;p&quot;, # tipo de grafico: pontos pch = 20, # codigo numérico do simbolo do ponto col = rep(1:3, each = ncol(temp_mat)), # cores dos pontos cex = rep(seq(1, 2, by = 0.5), each = ncol(temp_mat)), # aumenta tamanho dos pontos las = 1, # orientação dos labels dos eixos perpendiculares ao eixo ylab = expression(Tar ~ (degree ~ C)), # label da variável y xlab = &quot;meses&quot;, # label da variavel x main = &quot;Temperatura mensal (1990-1992)&quot; # título ) # end plot # para entender a variação nas cores e símbolos usadas no gráfico cbind( meses = 1:12, temp = stemp, cores = rep(1:3, each = ncol(temp_mat)), # cores simb_tam = rep(seq(1, 2, by = 0.5), each = ncol(temp_mat)) ) # tamanho dos símbolos #&gt; meses temp cores simb_tam #&gt; [1,] 1 25.00 1 1.0 #&gt; [2,] 2 23.20 1 1.0 #&gt; [3,] 3 22.50 1 1.0 #&gt; [4,] 4 21.00 1 1.0 #&gt; [5,] 5 19.00 1 1.0 #&gt; [6,] 6 17.60 1 1.0 #&gt; [7,] 7 18.00 1 1.0 #&gt; [8,] 8 19.70 1 1.0 #&gt; [9,] 9 21.30 1 1.0 #&gt; [10,] 10 22.00 1 1.0 #&gt; [11,] 11 24.00 1 1.0 #&gt; [12,] 12 26.80 1 1.0 #&gt; [13,] 1 24.89 2 1.5 #&gt; [14,] 2 24.07 2 1.5 #&gt; [15,] 3 23.56 2 1.5 #&gt; [16,] 4 23.11 2 1.5 #&gt; [17,] 5 18.29 2 1.5 #&gt; [18,] 6 18.22 2 1.5 #&gt; [19,] 7 16.72 2 1.5 #&gt; [20,] 8 19.37 2 1.5 #&gt; [21,] 9 20.08 2 1.5 #&gt; [22,] 10 21.45 2 1.5 #&gt; [23,] 11 26.61 2 1.5 #&gt; [24,] 12 25.99 2 1.5 #&gt; [25,] 1 23.20 3 2.0 #&gt; [26,] 2 26.61 3 2.0 #&gt; [27,] 3 18.00 3 2.0 #&gt; [28,] 4 23.11 3 2.0 #&gt; [29,] 5 26.80 3 2.0 #&gt; [30,] 6 21.30 3 2.0 #&gt; [31,] 7 18.22 3 2.0 #&gt; [32,] 8 21.45 3 2.0 #&gt; [33,] 9 19.70 3 2.0 #&gt; [34,] 10 22.50 3 2.0 #&gt; [35,] 11 24.07 3 2.0 #&gt; [36,] 12 20.08 3 2.0 "],
["arranjo.html", "7.4 Arranjo", " 7.4 Arranjo Arranjo é uma estrutura de dados multidimensional. A matriz é um caso particular de arranjo com 2 dimensões: linhas e colunas. Mas podemos ter dados com n dimensões. Por exemplo, imagine o campo espacial representado por uma grade de espaçamento horizontal regular de uma variável meteorológica. Nessa situação podemos usar uma matriz com valores de temperatura, onde as colunas representam as longitudes e as linhas as latitudes dos pontos da grade. Em um dados tempo, a matriz da variável com valores de temperatura do ar, por exemplo, representa o estado térmico espacial daquele momento. Então podemos dizer que esse arranjo possui 3 dimensões: latitude (linha), longitude (coluna) e tempo (camadas). 7.4.1 Criação Suponha que os campos espaciais médios mensais de temperatura sejam dados pelo vetor temp_vetor abaixo. temp_vetor &lt;- c( 18, 24, 19, 23, 19, 27, 24, 18, 13, 20, 25, 19, 18, 22, 17, 9, 17, 22, 13, 19, 29, 18, 19, 18, 11, 18, 19, 17, 13, 17, 26, 21, 22, 20, 14, 17 ) O vetor temp_vetor pode ser convertido em um arranjo dos campos espaciais usando a função array(), com o argumento dim especificando as dimensões. temp_array &lt;- array(data = temp_vetor, dim = c(3, 4, 3)) temp_array #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 18 23 24 20 #&gt; [2,] 24 19 18 25 #&gt; [3,] 19 27 13 19 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 18 9 13 18 #&gt; [2,] 22 17 19 19 #&gt; [3,] 17 22 29 18 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 11 17 26 20 #&gt; [2,] 18 13 21 14 #&gt; [3,] 19 17 22 17 dim(temp_array) #&gt; [1] 3 4 3 class(temp_array) #&gt; [1] &quot;array&quot; O arranjo também pode ter atributos, como o nomes das linhas, colunas e camadas. colnames(temp_array) &lt;- -(45:42) rownames(temp_array) &lt;- -(19:21) # nomes das dimensões dimnames(temp_array) #&gt; [[1]] #&gt; [1] &quot;-19&quot; &quot;-20&quot; &quot;-21&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;-45&quot; &quot;-44&quot; &quot;-43&quot; &quot;-42&quot; #&gt; #&gt; [[3]] #&gt; NULL # nomes para camadas dimnames(temp_array)[[3]] &lt;- c(&quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;) temp_array #&gt; , , Jan #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 18 23 24 20 #&gt; -20 24 19 18 25 #&gt; -21 19 27 13 19 #&gt; #&gt; , , Fev #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 18 9 13 18 #&gt; -20 22 17 19 19 #&gt; -21 17 22 29 18 #&gt; #&gt; , , Mar #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 11 17 26 20 #&gt; -20 18 13 21 14 #&gt; -21 19 17 22 17 7.4.2 Indexação Os mesmo procedimentos de indexação usados para matriz são aplicados a um arranjo (A), mas com a seguinte convenção de índices A[linha, coluna, camada]. # serie temporal do 1º ponto temp_array[1, 1, ] #&gt; Jan Fev Mar #&gt; 18 18 11 temp_array[&quot;-19&quot;, &quot;-45&quot;, ] #&gt; Jan Fev Mar #&gt; 18 18 11 # para 1a faixa de latitude (-19), # os valores de temp das longitudes em todos tempos temp_array[1, , ] #&gt; Jan Fev Mar #&gt; -45 18 18 11 #&gt; -44 23 9 17 #&gt; -43 24 13 26 #&gt; -42 20 18 20 # para 2a faixa de longitude (-44), todas longitudes e tempos temp_array[, 2, ] #&gt; Jan Fev Mar #&gt; -19 23 9 17 #&gt; -20 19 17 13 #&gt; -21 27 22 17 # média meridional colMeans(temp_array[, 2, ]) #&gt; Jan Fev Mar #&gt; 23.0000 16.0000 15.6667 # subdominio &quot;espacial&quot; temp_array[2:3, 2:3, ] #&gt; , , Jan #&gt; #&gt; -44 -43 #&gt; -20 19 18 #&gt; -21 27 13 #&gt; #&gt; , , Fev #&gt; #&gt; -44 -43 #&gt; -20 17 19 #&gt; -21 22 29 #&gt; #&gt; , , Mar #&gt; #&gt; -44 -43 #&gt; -20 13 21 #&gt; -21 17 22 # média espacial do 1o mês mean(temp_array[, , 1]) #&gt; [1] 20.75 # média espacial do segundo mês mean(temp_array[, , &quot;Jan&quot;]) #&gt; [1] 20.75 # demanchando o arranjo (conversão para vetor) c(temp_array) #&gt; [1] 18 24 19 23 19 27 24 18 13 20 25 19 18 22 17 9 17 22 13 19 29 18 19 #&gt; [24] 18 11 18 19 17 13 17 26 21 22 20 14 17 c(temp_array[, , 1]) #&gt; [1] 18 24 19 23 19 27 24 18 13 20 25 19 # para entender a forma como a matriz é convertida para vetor mat_temp &lt;- cbind( mes = rep(1:3, each = 20), elemat = rep(1:20, times = 6), valores = c(temp_array), elearr = 1:(cumprod(dim(temp_array))[3]) ) #&gt; Warning in cbind(mes = rep(1:3, each = 20), elemat = rep(1:20, times = #&gt; 6), : number of rows of result is not a multiple of vector length (arg 3) mat_temp #&gt; mes elemat valores elearr #&gt; [1,] 1 1 18 1 #&gt; [2,] 1 2 24 2 #&gt; [3,] 1 3 19 3 #&gt; [4,] 1 4 23 4 #&gt; [5,] 1 5 19 5 #&gt; [6,] 1 6 27 6 #&gt; [7,] 1 7 24 7 #&gt; [8,] 1 8 18 8 #&gt; [9,] 1 9 13 9 #&gt; [10,] 1 10 20 10 #&gt; [11,] 1 11 25 11 #&gt; [12,] 1 12 19 12 #&gt; [13,] 1 13 18 13 #&gt; [14,] 1 14 22 14 #&gt; [15,] 1 15 17 15 #&gt; [16,] 1 16 9 16 #&gt; [17,] 1 17 17 17 #&gt; [18,] 1 18 22 18 #&gt; [19,] 1 19 13 19 #&gt; [20,] 1 20 19 20 #&gt; [21,] 2 1 29 21 #&gt; [22,] 2 2 18 22 #&gt; [23,] 2 3 19 23 #&gt; [24,] 2 4 18 24 #&gt; [25,] 2 5 11 25 #&gt; [26,] 2 6 18 26 #&gt; [27,] 2 7 19 27 #&gt; [28,] 2 8 17 28 #&gt; [29,] 2 9 13 29 #&gt; [30,] 2 10 17 30 #&gt; [31,] 2 11 26 31 #&gt; [32,] 2 12 21 32 #&gt; [33,] 2 13 22 33 #&gt; [34,] 2 14 20 34 #&gt; [35,] 2 15 14 35 #&gt; [36,] 2 16 17 36 #&gt; [37,] 2 17 18 1 #&gt; [38,] 2 18 24 2 #&gt; [39,] 2 19 19 3 #&gt; [40,] 2 20 23 4 #&gt; [41,] 3 1 19 5 #&gt; [42,] 3 2 27 6 #&gt; [43,] 3 3 24 7 #&gt; [44,] 3 4 18 8 #&gt; [45,] 3 5 13 9 #&gt; [46,] 3 6 20 10 #&gt; [47,] 3 7 25 11 #&gt; [48,] 3 8 19 12 #&gt; [49,] 3 9 18 13 #&gt; [50,] 3 10 22 14 #&gt; [51,] 3 11 17 15 #&gt; [52,] 3 12 9 16 #&gt; [53,] 3 13 17 17 #&gt; [54,] 3 14 22 18 #&gt; [55,] 3 15 13 19 #&gt; [56,] 3 16 19 20 #&gt; [57,] 3 17 29 21 #&gt; [58,] 3 18 18 22 #&gt; [59,] 3 19 19 23 #&gt; [60,] 3 20 18 24 #&gt; [61,] 1 1 11 25 #&gt; [62,] 1 2 18 26 #&gt; [63,] 1 3 19 27 #&gt; [64,] 1 4 17 28 #&gt; [65,] 1 5 13 29 #&gt; [66,] 1 6 17 30 #&gt; [67,] 1 7 26 31 #&gt; [68,] 1 8 21 32 #&gt; [69,] 1 9 22 33 #&gt; [70,] 1 10 20 34 #&gt; [71,] 1 11 14 35 #&gt; [72,] 1 12 17 36 #&gt; [73,] 1 13 18 1 #&gt; [74,] 1 14 24 2 #&gt; [75,] 1 15 19 3 #&gt; [76,] 1 16 23 4 #&gt; [77,] 1 17 19 5 #&gt; [78,] 1 18 27 6 #&gt; [79,] 1 19 24 7 #&gt; [80,] 1 20 18 8 #&gt; [81,] 2 1 13 9 #&gt; [82,] 2 2 20 10 #&gt; [83,] 2 3 25 11 #&gt; [84,] 2 4 19 12 #&gt; [85,] 2 5 18 13 #&gt; [86,] 2 6 22 14 #&gt; [87,] 2 7 17 15 #&gt; [88,] 2 8 9 16 #&gt; [89,] 2 9 17 17 #&gt; [90,] 2 10 22 18 #&gt; [91,] 2 11 13 19 #&gt; [92,] 2 12 19 20 #&gt; [93,] 2 13 29 21 #&gt; [94,] 2 14 18 22 #&gt; [95,] 2 15 19 23 #&gt; [96,] 2 16 18 24 #&gt; [97,] 2 17 11 25 #&gt; [98,] 2 18 18 26 #&gt; [99,] 2 19 19 27 #&gt; [100,] 2 20 17 28 #&gt; [101,] 3 1 13 29 #&gt; [102,] 3 2 17 30 #&gt; [103,] 3 3 26 31 #&gt; [104,] 3 4 21 32 #&gt; [105,] 3 5 22 33 #&gt; [106,] 3 6 20 34 #&gt; [107,] 3 7 14 35 #&gt; [108,] 3 8 17 36 #&gt; [109,] 3 9 18 1 #&gt; [110,] 3 10 24 2 #&gt; [111,] 3 11 19 3 #&gt; [112,] 3 12 23 4 #&gt; [113,] 3 13 19 5 #&gt; [114,] 3 14 27 6 #&gt; [115,] 3 15 24 7 #&gt; [116,] 3 16 18 8 #&gt; [117,] 3 17 13 9 #&gt; [118,] 3 18 20 10 #&gt; [119,] 3 19 25 11 #&gt; [120,] 3 20 19 12 "],
["lista.html", "7.5 Lista", " 7.5 Lista Listas são o segundo tipo de vetor. O primeiro tipo nós já vimos, são os vetores atômicos, nos quais todos os elementos devem ser de uma mesma classe de objeto. Listas são uma estrutura de dados muito versátil por pelo menos 3 razões: Os elementos podem ser de diferentes classes de objetos (p.ex.: um elemento numeric, outro character); Cada elemento pode ter um tamanho diferente; Os elementos podem conter diferentes estrutura de dados (p.ex.: um elemento matrix, outro vector); Dentro da lista o conjunto de objetos são ordenados e cada elemento pode conter sub-elementos. 7.5.1 Criação As vezes precisamos de um container para armazenar diferentes tipos de dados do R e com diferente tamanhos. As listas servem para isso e permitem armazenar qualquer número de itens de qualquer tipo. Uma lista pode conter números, caracteres ou uma mistura de dataframes, sub-listas, matrizes e vetores. Listas podem ser criadas com a função list(). A especificação do conteúdo de uma lista é muito similar a da função c() vista anteriormente. Nós simplesmente listamos os elementos da lista separados por uma vírgula dentro da função list(). # lista de dados heterogêneos lst &lt;- list(1:4, c(1.1, 2.3, 5.9), c(TRUE, FALSE), &quot;R&quot;, list(0, 1)) lst #&gt; [[1]] #&gt; [1] 1 2 3 4 #&gt; #&gt; [[2]] #&gt; [1] 1.1 2.3 5.9 #&gt; #&gt; [[3]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[4]] #&gt; [1] &quot;R&quot; #&gt; #&gt; [[5]] #&gt; [[5]][[1]] #&gt; [1] 0 #&gt; #&gt; [[5]][[2]] #&gt; [1] 1 # estrutura da lista str(lst) #&gt; List of 5 #&gt; $ : int [1:4] 1 2 3 4 #&gt; $ : num [1:3] 1.1 2.3 5.9 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : chr &quot;R&quot; #&gt; $ :List of 2 #&gt; ..$ : num 0 #&gt; ..$ : num 1 # tamanho da lista (num. de componentes ou elementos) length(lst) #&gt; [1] 5 # atribuindo nomes a lista names(lst) #&gt; NULL names(lst) &lt;- c(&quot;vetor_int&quot;, &quot;vetor_num&quot;, &quot;logico&quot;, &quot;char&quot;, &quot;lista&quot;) Os índices em colchetes duplos [[]] identificam o elemento ou a componente da lista. Os índices em colchete simples [] indicam qual sub-elemento da lista está sendo mostrado. Por exemplo 1.1 é o primeiro sub-elemento do segundo elemento da lista lst. Desse aninhamento de elementos surge o sistema de indexação de listas. A estrutura de uma lista pode se tornar complicada com o aumento do grau de sub-elementos. Mas essa flexibilidade, faz das listas uma ferramenta de armazenamento de dados para todos propósitos. Veremos que no R, listas são frequentemente usadas para armazenar a saída de funções com diversos resultados. Como por exemplo a saída das funções rle(). Para verificar se uma lista é aninhada usamos a função is.recursive(). is.recursive(lst) #&gt; [1] TRUE Vamos ver um exemplo onde criamos uma lista com informações de duas estações meteorológicas. # matriz de dados meteorológicos da estação de Santa Maria dados_sm &lt;- cbind( tar = c(31, 35, 21, 23, 33, 17), prec = c(300, 200, 150, 120, 210, 110) ) dados_sm #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # lista com informações da estação de santa maria sm_l &lt;- list( c(-45, -23), &quot;Santa Maria&quot;, dados_sm ) sm_l #&gt; [[1]] #&gt; [1] -45 -23 #&gt; #&gt; [[2]] #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; [[3]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # adicionar nomes aos elementos names(sm_l) &lt;- c(&quot;coords&quot;, &quot;cidade&quot;, &quot;dados&quot;) sm_l #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # matriz de dados meteorológicos da estação de Júlio de Castilhos dados_jc &lt;- cbind( tar = c(22.5, 20, 18.75, 18, 20.25, 17.75), prec = c(360, 310, 285, 270, 315, 265) ) # criando lista de JC, mas nomeando de forma diferente jc_l &lt;- list( coords = c(-45.1, -23.2), cidade = &quot;Júlio de Castilhos&quot;, dados = dados_jc ) # adicionar nomes as componentes names(jc_l) &lt;- names(sm_l) jc_l #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 As informações de cada estação estão armazenadas em 2 listas. Mas é mais prático termos todas estações em um única lista: # combinando listas mantendo os elementos separadamente dados_l &lt;- list(sm_l, jc_l) dados_l #&gt; [[1]] #&gt; [[1]]$coords #&gt; [1] -45 -23 #&gt; #&gt; [[1]]$cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; [[1]]$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; [[2]]$cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; [[2]]$dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 names(dados_l) #&gt; NULL names(dados_l) &lt;- c(&quot;sm&quot;, &quot;jc&quot;) dados_l #&gt; $sm #&gt; $sm$coords #&gt; [1] -45 -23 #&gt; #&gt; $sm$cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $sm$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; #&gt; $jc #&gt; $jc$coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $jc$cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $jc$dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 # como a lista é um tipo vetor, a função length() # fornece o número de elementos da lista length(dados_l) #&gt; [1] 2 Para resumir a estrutura de uma lista (ou dataframe) podemos usar a função str(): str(dados_l) #&gt; List of 2 #&gt; $ sm:List of 3 #&gt; ..$ coords: num [1:2] -45 -23 #&gt; ..$ cidade: chr &quot;Santa Maria&quot; #&gt; ..$ dados : num [1:6, 1:2] 31 35 21 23 33 17 300 200 150 120 ... #&gt; .. ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. .. ..$ : NULL #&gt; .. .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; #&gt; $ jc:List of 3 #&gt; ..$ coords: num [1:2] -45.1 -23.2 #&gt; ..$ cidade: chr &quot;Júlio de Castilhos&quot; #&gt; ..$ dados : num [1:6, 1:2] 22.5 20 18.8 18 20.2 ... #&gt; .. ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. .. ..$ : NULL #&gt; .. .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; As listas também poderiam ser combinadas com função concatena ou combina c(). dados_l2 &lt;- c(sm_l, jc_l) dados_l2 #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 str(dados_l2) #&gt; List of 6 #&gt; $ coords: num [1:2] -45 -23 #&gt; $ cidade: chr &quot;Santa Maria&quot; #&gt; $ dados : num [1:6, 1:2] 31 35 21 23 33 17 300 200 150 120 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : NULL #&gt; .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; #&gt; $ coords: num [1:2] -45.1 -23.2 #&gt; $ cidade: chr &quot;Júlio de Castilhos&quot; #&gt; $ dados : num [1:6, 1:2] 22.5 20 18.8 18 20.2 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : NULL #&gt; .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; 7.5.2 Indexação 7.5.2.1 Operador [ Assim como em vetores, podemos acessar os elementos de uma lista usando os colchetes [ com índices numéricos positivos, negativos, caracteres (nomes dos elementos) e lógicos. As expressões abaixo, ilustram o uso dessas diferentes formas de seleção de elementos e produzem o mesmo resultado. sm_l[1:2] #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; sm_l[c(&quot;coords&quot;, &quot;alt&quot;)] #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $&lt;NA&gt; #&gt; NULL O resultado da seleção do 1º e 2º elemento é uma lista menor que a original. Isso não é muito útil, uma vez que muitas funções do R não lidam com listas. Por exemplo, se quiséssemos calcular a soma do vetor contido do primeiro elemento da lista lst obtém-se um erro. # seleção do 1º elemento da lst lst[1] #&gt; $vetor_int #&gt; [1] 1 2 3 4 # o resultado da seleção é uma lista mode(lst[1]) #&gt; [1] &quot;list&quot; # a função sum() espera como entrada um vetor sum(lst[1]) #&gt; Error in sum(lst[1]): invalid &#39;type&#39; (list) of argument # acessando elemento inexistente lst[6] #&gt; $&lt;NA&gt; #&gt; NULL Então ao selecionar elementos de uma lista com o operador [ o resultado preserva a estrutura original do objeto. lst é uma lista e o resultado da seleção lst[1] também é uma lista. Portanto, a seleção de elementos com o operador [ preserva a estrutura do objeto original. 7.5.2.2 Operador [[ e $ Entretanto na maioria das vezes estamos interessados no conteúdo dos elementos de uma lista. Para fazer isso há dois operadores: o duplo colchetes [[ e o $. Para acessar elementos individuais de uma lista usamos o duplo colchetes [[ especificando o número do elemento ou o nome. Essa forma de seleção de dados permite o acesso a um elemento por vez. # 1º elemento de sm_l sm_l[[1]] #&gt; [1] -45 -23 sm_l[[&quot;coords&quot;]] #&gt; [1] -45 -23 # modo de sm_l mode(sm_l) #&gt; [1] &quot;list&quot; # ultimo elemento de sm_l sm_l[[length(sm_l)]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 sm_l[[&quot;dados&quot;]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # subelementos dados_l[[&quot;sm&quot;]][[&quot;cidade&quot;]] #&gt; [1] &quot;Santa Maria&quot; Para acessar o conteúdo de elementos de uma lista que possui nomes podemos também usar o operador $. Ele funciona de forma similar ao duplo colchetes usado com o nome do elemento da lista. Mas esse operador tem duas vantagens: a IDE RStudio autocompleta o nome do elemento (usando a tecla &lt;tab&gt;) e o R aceita o nome parcial dos nomes dos elementos. # seleção de dados por nomes usando o símbolo $ dados_l$s #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 dados_l$j #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 dados_l$sm$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 dados_l$sm$dados[3:5, 1:2] #&gt; tar prec #&gt; [1,] 21 150 #&gt; [2,] 23 120 #&gt; [3,] 33 210 dados_l$sm$dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 dados_l$sm$dados[, &quot;tar&quot;, drop = FALSE] #&gt; tar #&gt; [1,] 31 #&gt; [2,] 35 #&gt; [3,] 21 #&gt; [4,] 23 #&gt; [5,] 33 #&gt; [6,] 17 7.5.2.3 Lista de condimentos É fácil de confundir quando usar ] e ]]. A tabela abaixo ajuda lembrar da diferença entre eles. descrição código resultado frasco de pimenta frasco frasco de pimenta com apenas 1 pacote de pimenta frasco[1] 1 pacote de pimenta frasco[[1]] conteúdo de um pacote de pimenta frasco[[1]][[1]] 7.5.3 Conversão de lista para vetor e vice-versa. vet &lt;- 1:10 vet #&gt; [1] 1 2 3 4 5 6 7 8 9 10 vet.list &lt;- as.list(vet) vet.list #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 #&gt; #&gt; [[6]] #&gt; [1] 6 #&gt; #&gt; [[7]] #&gt; [1] 7 #&gt; #&gt; [[8]] #&gt; [1] 8 #&gt; #&gt; [[9]] #&gt; [1] 9 #&gt; #&gt; [[10]] #&gt; [1] 10 # desmanchando a lista unlist(vet.list) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # deletando um elemento de uma lista length(vet.list) #&gt; [1] 10 vet.list[8] &lt;- NULL vet.list #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 #&gt; #&gt; [[6]] #&gt; [1] 6 #&gt; #&gt; [[7]] #&gt; [1] 7 #&gt; #&gt; [[8]] #&gt; [1] 9 #&gt; #&gt; [[9]] #&gt; [1] 10 length(vet.list) #&gt; [1] 9 7.5.4 Conversão de list para data.frame Vamos modificar a lista sm_l para convertê-la em um dataframe. sm_l #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # ao invés da componente coords, criamos uma lon e lat sm_l$lon &lt;- sm_l$coords[1] sm_l$lat &lt;- sm_l$coords[2] sm_l$coords &lt;- NULL sm_l #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $lon #&gt; [1] -45 #&gt; #&gt; $lat #&gt; [1] -23 # converter para dataframe sm_df &lt;- data.frame(sm_l) sm_df #&gt; cidade dados.tar dados.prec lon lat #&gt; 1 Santa Maria 31 300 -45 -23 #&gt; 2 Santa Maria 35 200 -45 -23 #&gt; 3 Santa Maria 21 150 -45 -23 #&gt; 4 Santa Maria 23 120 -45 -23 #&gt; 5 Santa Maria 33 210 -45 -23 #&gt; 6 Santa Maria 17 110 -45 -23 "],
["dataframe.html", "7.6 Dataframe", " 7.6 Dataframe Um dataframe é o objeto mais usado para guardar conjunto de dados na forma de tabela (tabulares ou planos). A estrutura de um dataframe é retangular como a de uma matriz. Mas tem a vantagem de armazenar vetores de diferentes tipos (character, numeric, logical e etc) nas suas colunas. O que não é possível em uma matriz. Ou seja é uma estrutura de armazenamento de dados heterogênea. Matrix, arrays e vector só armazenam dados homogêneos. Cada linha do dataframe corresponde a um registro da tabela. Cada coluna corresponde a uma variável a ser armazenada para cada registro da tabela. 7.6.1 Criação Uma das formas mais simples de se criar um dataframe é através da função data.frame(). # criando um dataframe dados &lt;- data.frame( datas = c( &quot;2013-01-01&quot;, &quot;2013-01-02&quot;, &quot;2013-01-03&quot;, &quot;2013-01-04&quot;, &quot;2013-01-05&quot;, &quot;2013-01-06&quot;, &quot;2013-01-07&quot;, &quot;2013-01-08&quot;, &quot;2013-01-09&quot;, &quot;2013-01-10&quot;, &quot;2013-01-11&quot;, &quot;2013-01-12&quot;, &quot;2013-01-13&quot;, &quot;2013-01-14&quot;, &quot;2013-01-15&quot; ), cidade = rep(&quot;Santa Maria&quot;, 15), tar = c(31, 35, 21, 23, 33, 17, 18, 16, 34, 27, 15, 28, 22, 29, 32) ) dados #&gt; datas cidade tar #&gt; 1 2013-01-01 Santa Maria 31 #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 #&gt; 15 2013-01-15 Santa Maria 32 class(dados) #&gt; [1] &quot;data.frame&quot; is.data.frame(dados) #&gt; [1] TRUE Para um diagnóstico rápido das variáveis de um dataframe usamos a função str(): # descrição geral do conjunto de dados str(dados) #&gt; &#39;data.frame&#39;: 15 obs. of 3 variables: #&gt; $ datas : Factor w/ 15 levels &quot;2013-01-01&quot;,&quot;2013-01-02&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ cidade: Factor w/ 1 level &quot;Santa Maria&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tar : num 31 35 21 23 33 17 18 16 34 27 ... A saída da função str()indica que há duas variáveis da classe factor. Em um dataframe vetores do tipo character são automaticamente convertidos em factor. Este é o comportamento default da função data.frame(). Para que essa conversão não seja feita você deve definir o parâmetro stringsAsFactors = FALSE na função data.frame(). Vamos recriar o dataframe dados sem a conversão de character para factor. # criando um dataframe dados &lt;- data.frame( datas = c( &quot;2013-01-01&quot;, &quot;2013-01-02&quot;, &quot;2013-01-03&quot;, &quot;2013-01-04&quot;, &quot;2013-01-05&quot;, &quot;2013-01-06&quot;, &quot;2013-01-07&quot;, &quot;2013-01-08&quot;, &quot;2013-01-09&quot;, &quot;2013-01-10&quot;, &quot;2013-01-11&quot;, &quot;2013-01-12&quot;, &quot;2013-01-13&quot;, &quot;2013-01-14&quot;, &quot;2013-01-15&quot; ), cidade = rep(&quot;Santa Maria&quot;, 15), tar = c(31, 35, 21, 23, 33, 17, 18, 16, 34, 27, 15, 28, 22, 29, 32), stringsAsFactors = FALSE ) str(dados) #&gt; &#39;data.frame&#39;: 15 obs. of 3 variables: #&gt; $ datas : chr &quot;2013-01-01&quot; &quot;2013-01-02&quot; &quot;2013-01-03&quot; &quot;2013-01-04&quot; ... #&gt; $ cidade: chr &quot;Santa Maria&quot; &quot;Santa Maria&quot; &quot;Santa Maria&quot; &quot;Santa Maria&quot; ... #&gt; $ tar : num 31 35 21 23 33 17 18 16 34 27 ... A função summary() fornece um resumo estatístico das variáveis (colunas) de um dataframe. # resumo estatístico dos dados summary(dados) #&gt; datas cidade tar #&gt; Length:15 Length:15 Min. :15.0 #&gt; Class :character Class :character 1st Qu.:19.5 #&gt; Mode :character Mode :character Median :27.0 #&gt; Mean :25.4 #&gt; 3rd Qu.:31.5 #&gt; Max. :35.0 7.6.2 Atributos de um dataframe dataframe é uma estrutura de dados avançada e possui diversos atributos. # atributos attributes(dados) #&gt; $names #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # atributos armazenados em uma lista str(attributes(dados)) #&gt; List of 3 #&gt; $ names : chr [1:3] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; #&gt; $ class : chr &quot;data.frame&quot; #&gt; $ row.names: int [1:15] 1 2 3 4 5 6 7 8 9 10 ... # número de colunas ncol(dados) #&gt; [1] 3 # número de linhas nrow(dados) #&gt; [1] 15 # dimensões dim(dados) #&gt; [1] 15 3 # nomes podem ser atribuídos as linhas e as colunas rownames(dados) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; #&gt; [15] &quot;15&quot; # novos nomes para as linhas de dados rownames(dados) &lt;- paste0(&quot;linha&quot;, rownames(dados)) dados #&gt; datas cidade tar #&gt; linha1 2013-01-01 Santa Maria 31 #&gt; linha2 2013-01-02 Santa Maria 35 #&gt; linha3 2013-01-03 Santa Maria 21 #&gt; linha4 2013-01-04 Santa Maria 23 #&gt; linha5 2013-01-05 Santa Maria 33 #&gt; linha6 2013-01-06 Santa Maria 17 #&gt; linha7 2013-01-07 Santa Maria 18 #&gt; linha8 2013-01-08 Santa Maria 16 #&gt; linha9 2013-01-09 Santa Maria 34 #&gt; linha10 2013-01-10 Santa Maria 27 #&gt; linha11 2013-01-11 Santa Maria 15 #&gt; linha12 2013-01-12 Santa Maria 28 #&gt; linha13 2013-01-13 Santa Maria 22 #&gt; linha14 2013-01-14 Santa Maria 29 #&gt; linha15 2013-01-15 Santa Maria 32 # removendo nomes das linhas rownames(dados) &lt;- NULL dados #&gt; datas cidade tar #&gt; 1 2013-01-01 Santa Maria 31 #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 #&gt; 15 2013-01-15 Santa Maria 32 # mesmo que names(dados) colnames(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; # ou simplesmente names(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; 7.6.3 Acesso as variáveis de um dataframe Existem várias formas de acessar as variáveis de um dataframe. Os operadores para extração de elementos são os mesmos utilizados para extração de elementos de uma lista: [, [[ e $. Mas observe a diferença nos resultados extraídos com cada operador. # variáveis do dataframe names(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; # acessando os dados de temperatura dados[, 3] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 # ou dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 # ou dados$tar #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 is.vector(dados$tar) #&gt; [1] TRUE # note a diferença no resultado da extração dados[&quot;tar&quot;] #&gt; tar #&gt; 1 31 #&gt; 2 35 #&gt; 3 21 #&gt; 4 23 #&gt; 5 33 #&gt; 6 17 #&gt; 7 18 #&gt; 8 16 #&gt; 9 34 #&gt; 10 27 #&gt; 11 15 #&gt; 12 28 #&gt; 13 22 #&gt; 14 29 #&gt; 15 32 class(dados[&quot;tar&quot;]) #&gt; [1] &quot;data.frame&quot; dados[[&quot;tar&quot;]] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 class(dados[[&quot;tar&quot;]]) #&gt; [1] &quot;numeric&quot; dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 class(dados[, &quot;tar&quot;]) #&gt; [1] &quot;numeric&quot; Portanto dataframes tem estrutura retangular similar a das matrizes e algumas de listas (diferentes colunas podem conter diferentes tipos de objetos). 7.6.3.1 Função with() O acesso as variáveis de um dataframe também é possível com a função with(data, expr). # acesso a variáveis de um dataframe with(data = dados, expr = tar) #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 tarK &lt;- with(data = dados, expr = tar + 273.15) tarK #&gt; [1] 304.15 308.15 294.15 296.15 306.15 290.15 291.15 289.15 307.15 300.15 #&gt; [11] 288.15 301.15 295.15 302.15 305.15 # gráfico de uma variável usando with() with(data = dados, # parâmetro expr geralmente não é mostrado plot(tar + 273.15, type = &quot;o&quot;) ) O argumento pode ser substituído por qualquer expressão ou conjunto de expressões que envolvam as variáveis do dataframe de entrada. Quando houver uma expressão com mais de uma linha você agrupa o código usando chaves {}. with(dados, { dates &lt;- as.Date(datas) plot(dates, tar) } ) 7.6.4 Indexação, seleção e substituição Todos esquemas de indexação usados para matrizes (seleção por índices, nomes, vetores lógicos - ver Aula9) podem ser usados com dataframes. # exclui a primeiro e a última observação para todas variáveis dados[-c(1, nrow(dados)), ] #&gt; datas cidade tar #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 # temperatura dos primeiros 5 dias dados[1:5, 3] #&gt; [1] 31 35 21 23 33 # temperatura no dia 2013-01-09 dados[dados$datas == &quot;2013-01-09&quot;, &quot;tar&quot;] #&gt; [1] 34 # acrescentar uma nova variavel dados$prec &lt;- c(rep(0, 5), 10, 18, 4, 0, 0, 5, 0, 0, 2, 0) dados #&gt; datas cidade tar prec #&gt; 1 2013-01-01 Santa Maria 31 0 #&gt; 2 2013-01-02 Santa Maria 35 0 #&gt; 3 2013-01-03 Santa Maria 21 0 #&gt; 4 2013-01-04 Santa Maria 23 0 #&gt; 5 2013-01-05 Santa Maria 33 0 #&gt; 6 2013-01-06 Santa Maria 17 10 #&gt; 7 2013-01-07 Santa Maria 18 18 #&gt; 8 2013-01-08 Santa Maria 16 4 #&gt; 9 2013-01-09 Santa Maria 34 0 #&gt; 10 2013-01-10 Santa Maria 27 0 #&gt; 11 2013-01-11 Santa Maria 15 5 #&gt; 12 2013-01-12 Santa Maria 28 0 #&gt; 13 2013-01-13 Santa Maria 22 0 #&gt; 14 2013-01-14 Santa Maria 29 2 #&gt; 15 2013-01-15 Santa Maria 32 0 Uma função específica para gerar subconjunto de dados em dataframes é a subset(). # subconjunto baseado em condição lógica ss1 &lt;- subset(dados, datas == &quot;2013-01-09&quot;, select = &quot;tar&quot;) ss1 #&gt; tar #&gt; 9 34 # subconjunto baseado em condição lógica ss2 &lt;- subset(dados, tar &gt; 26 &amp; prec &gt; 0) ss2 #&gt; datas cidade tar prec #&gt; 14 2013-01-14 Santa Maria 29 2 # subconjunto baseado em condição lógica ss3 &lt;- subset(dados, tar &gt; 26 | prec &gt; 0) ss3 #&gt; datas cidade tar prec #&gt; 1 2013-01-01 Santa Maria 31 0 #&gt; 2 2013-01-02 Santa Maria 35 0 #&gt; 5 2013-01-05 Santa Maria 33 0 #&gt; 6 2013-01-06 Santa Maria 17 10 #&gt; 7 2013-01-07 Santa Maria 18 18 #&gt; 8 2013-01-08 Santa Maria 16 4 #&gt; 9 2013-01-09 Santa Maria 34 0 #&gt; 10 2013-01-10 Santa Maria 27 0 #&gt; 11 2013-01-11 Santa Maria 15 5 #&gt; 12 2013-01-12 Santa Maria 28 0 #&gt; 14 2013-01-14 Santa Maria 29 2 #&gt; 15 2013-01-15 Santa Maria 32 0 # subconjunto baseado em condição lógica ss4 &lt;- subset(dados, datas %in% c(&quot;2013-01-09&quot;, &quot;2013-01-13&quot;, &quot;2013-01-15&quot;), select = -cidade ) ss4 #&gt; datas tar prec #&gt; 9 2013-01-09 34 0 #&gt; 13 2013-01-13 22 0 #&gt; 15 2013-01-15 32 0 # subconjunto baseado em condição lógica ss4 &lt;- subset(dados, !datas %in% c(&quot;2013-01-09&quot;, &quot;2013-01-13&quot;, &quot;2013-01-15&quot;), select = -cidade ) ss4 #&gt; datas tar prec #&gt; 1 2013-01-01 31 0 #&gt; 2 2013-01-02 35 0 #&gt; 3 2013-01-03 21 0 #&gt; 4 2013-01-04 23 0 #&gt; 5 2013-01-05 33 0 #&gt; 6 2013-01-06 17 10 #&gt; 7 2013-01-07 18 18 #&gt; 8 2013-01-08 16 4 #&gt; 10 2013-01-10 27 0 #&gt; 11 2013-01-11 15 5 #&gt; 12 2013-01-12 28 0 #&gt; 14 2013-01-14 29 2 Uma função específica para alteração, remoção e inclusão de variáveis em um dataframe é a transform(). Essa função é mais indicada para alteração de mais de uma variável (ao mesmo tempo) de um dataframe. # mudança do dataframe, alteração de várias variáveis dados &lt;- transform(dados, cidade = ifelse(1:nrow(dados) &gt; 8, &quot;Sao Sepe&quot;, cidade), datas = c(datas[1:8], datas[1:7]), anomalias = ifelse(cidade == &quot;Santa Maria&quot;, tar - mean(tar[cidade == &quot;Santa Maria&quot;]), tar - mean(tar[cidade == &quot;Sao Sepe&quot;]) ) ) dados #&gt; datas cidade tar prec anomalias #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 # alterar só uma variavel, anomalia normalizada dados$anomalias.norm &lt;- ifelse(dados$cidade == &quot;Santa Maria&quot;, dados$anomalias / sd(dados$anomalias[dados$cidade == &quot;Santa Maria&quot;]), dados$anomalias / sd(dados$anomalias[dados$cidade == &quot;Sao Sepe&quot;]) ) dados #&gt; datas cidade tar prec anomalias anomalias.norm #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 7.6.5 Combinando dataframes coords_df &lt;- data.frame( lon = c(rep(-45, 8), rep(-45.1, 7)), # longitudes lat = c(rep(-23, 8), rep(-23.1, 7)) ) # latitudes d &lt;- cbind(dados, coords_df) d #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 # usando a própria função data.frame() d2 &lt;- data.frame(dados, coords_df, stringsAsFactors = FALSE) d2 #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 # verificando se os dois dataframes são idênticos identical(d, d2) #&gt; [1] TRUE # dados de Caçapava cacapava &lt;- data.frame( datas = &quot;2013-01-01&quot;, cidade = &quot;Cacapava&quot;, tar = 19, prec = 0, anomalias = NA, anomalias.norm = NA, lon = -45.1, lat = -23.2 ) d &lt;- rbind(d, cacapava) d #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 #&gt; 16 2013-01-01 Cacapava 19 0 NA NA -45.1 -23.2 7.6.6 Teste e Coerção Podemos converter um objeto para dataframe com as.data.frame(): Um vetor é transformado em um dataframe de uma coluna; Uma lista terá uma coluna para elemento, se os elementos não forem de mesmo tamanho haverá um erro; Uma matriz cria um dataframe com mesma estrutura de uma matriz; # convertendo lista para dataframe sm_l #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $lon #&gt; [1] -45 #&gt; #&gt; $lat #&gt; [1] -23 sm_l_df &lt;- as.data.frame(sm_l) sm_l_df #&gt; cidade dados.tar dados.prec lon lat #&gt; 1 Santa Maria 31 300 -45 -23 #&gt; 2 Santa Maria 35 200 -45 -23 #&gt; 3 Santa Maria 21 150 -45 -23 #&gt; 4 Santa Maria 23 120 -45 -23 #&gt; 5 Santa Maria 33 210 -45 -23 #&gt; 6 Santa Maria 17 110 -45 -23 # convertendo array para dataframe v #&gt; [1] 3 100 NA NA 6 v_df &lt;- as.data.frame(v) # convertendo vetor para dataframe temp90_df &lt;- as.data.frame(temp90) # convertendo matrix para dataframe mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 1 -1 -2 #&gt; [2,] 3 5 -5 0 mat_df &lt;- as.data.frame(mat) names(mat_df) #&gt; [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; mat_df #&gt; V1 V2 V3 V4 #&gt; 1 0 1 -1 -2 #&gt; 2 3 5 -5 0 # testes is.data.frame(mat_df) #&gt; [1] TRUE class(v_df) #&gt; [1] &quot;data.frame&quot; "],
["exercicios-1.html", "7.7 Exercícios", " 7.7 Exercícios Crie um vetor com os valores de \\(e^{x}cos{x}\\) para os valores de \\(x = (3, 3.1, 3.2, ..., 6\\)). Crie os seguintes vetores. \\((0.1^{3}0.2^{1}, 0.1^{6}0.2^{4}, ..., 0.1^{36}0.2^{34})\\) \\((2, \\frac{2^{2}}{2}, \\frac{2^{3}}{3}, ..., \\frac{2^{25}}{25})\\) Reproduza a criação do vetor dias da semana (dds) mostrado abaixo. Domingo Segunda-feira Terça-feira Quarta-feira Quinta-feira 1 2 3 4 5 Sexta-feira Sábado 6 7 Escreva os códigos necessários para determinar: Na sequência de valores 19, 70, 57, 17, 91, 90, 13, 78, 44, 51 obtenha o vetor lógico indicando quais números são pares. Calcule o total de números ímpares. Se um ano é bissexto. Verifique os resultados de seu código para os anos 1913, 1977, 1961, 1910, 2005, 2004, 1905, 1989, 1945, 1954. Calcule o total de anos com 365 dias. "],
["io.html", "8 Entrada e saída de dados", " 8 Entrada e saída de dados O é capaz de importar dados de uma diversidade de fontes, formatos e tamanhos. Neste capítulo será visto como importar e exportar dados nos formatos mais comuns em aplicações ambientais, como: dados tabulares armazenados em arquivos texto (ASCII) arquivos de dados meteorológicos de agências brasileiras dados binários e netCDF dados espaciais em formato GIS Nós estamos em uma era digital e a quantidade de dados disponíveis na internet está aumentando mostruosamente. Para você estar preparado para o futuro, além de aprender como importados arquivos locais, veremos também como baixar e importar dados da web. Serão utilizados diversos pacotes para lidar com os diferentes formatos de dados. Iremos começar com o pacote rio que permite importar com facilidade uma diversidade de tipos de dados. Arquivos CSV serão tratados com os pacotes readr e data.table. Dados em formato texto tem desvantagens e por isso veremos formatos binários, entre eles, as funções nativas do R (readRDS(), load()) e funções de pacotes específicos para importar arquivos no formato netCDF. "],
["pre-requisitos.html", "8.1 Pré-requisitos", " 8.1 Pré-requisitos Para reproduzir os códigos deste capítulo você precisará dos seguintes pacotes: pacotes &lt;- c(&quot;easypackages&quot;,&quot;rio&quot;, &quot;readr&quot;, &quot;feather&quot;) Para instalá-los já com as dependências utilize a instrução abaixo: install.packages( pacotes, dependencies = TRUE ) Agora você pode carregar os pacotes. library(&quot;easypackages&quot;) library(&quot;rio&quot;) library(&quot;readr&quot;) Para carregar diversos pacotes de uma vez só, você pode usar a função libraries() do pacote easypackages. Então o trecho de código anterior poderia ser substituído por: library(easypackages) libraries(pacotes) ou simplesmente easypackages::libraries(pacotes) "],
["diretorio-de-trabalho.html", "8.2 Diretório de trabalho", " 8.2 Diretório de trabalho Antes de lidar com arquivos locais, você precisa conhecer o seu diretório de trabalho; o local para o qual sua sessão do R importará ou exportará dados por default. O possui uma variedade de funções para se obter informações do sistema, como arquivos, diretórios, e etc. Uma informação importante é diretório de trabalho atual. Importar ou exportar dados é mais fácil quando você não precisa digitar caminhos longos de diretórios para os arquivos. Por isso, quando abrimos uma sessão no , ela é vinculada a um diretório de trabalho (working directory, wd). A função getwd() retorna o diretório de trabalho da sua sessão do . getwd() O local default geralmente é o home do usuário &quot;/home/usuario&quot; no linux e &quot;C:\\Usuarios\\usuario\\&quot; no Windows. Você obtém essa informação com a instrução abaixo: Sys.getenv(&quot;HOME&quot;) É neste local onde o e o RStudio irão salvar gráficos, documentos, ler e escrever dados, quando você não especificar o caminho completo para o arquivo de saída. Ocasionalmente pode ser conveniente alterar seu wd e para isso você pode usar a função setwd(). wd &lt;- getwd() # define o wd em &quot;/home/user&quot; setwd(&quot;~/Documents&quot;) getwd() # volta para o wd original setwd(wd) getwd() Você pode configurar o diretório de trabalho pelo menu do Rstudio Session &gt; Set Working Directory. Você terá as opções: To Source File Location: definirá o diretório de trabalho como o mesmo do arquivo atualmente aberto no RStudio To Files Pane Location: definirá o diretório de trabalho como aquele atualmente aberto no painel de arquivos To Files Pane Location: definirá o diretório de trabalho como o mesmo do projeto atualmente aberto no RStudio Choose Directory: permite você navegar até o diretório de interesse O conteúdo de um diretório pode ser listado com a função dir(), ou se estiver usando o Rstudio você pode clicar na aba Files do painel de direito inferior e depois em More &gt; Go To Working Directory. "],
["arquivos-texto.html", "8.3 Arquivos texto", " 8.3 Arquivos texto Dados armazenados em um arquivo texto (do tipo ASCII) podem ser facilmente importados no R. O formato mais comum de armazenar dados é o retangular, ou seja, uma tabela de dados com as observações ao longo das linhas e as variáveis ao longo das colunas. Os valores de cada coluna de uma linha são separados por um caractere separador: vírgula, espaço, tab e etc; as linhas são separadas por quebras de linha (\\n no Linux ou \\r\\n no Windows). "],
["arquivos-binarios.html", "8.4 Arquivos binários", " 8.4 Arquivos binários Arquivo texto favorecem a legibilidade humana dos dados mas tem limitada precisão numérica limitada. Formatos binários diminuem substancialmente o tamanho, o tempo de leitura e escrita de arquivos. Por isso, vários softwares armazenam dados no formato binário. Existem diversas funções nativas do R para ler este formato de dados. versão completa da tabela na vinheta do pacote rio Formato Extensão Pacote de importação Pacote de exportação Instalado por default Valores separados por vírgula .csv data.table data.table Sim dados separados por tab .tsv data.table data.table Sim Excel .xls readxl Sim Excel .xlsx readxl openxlsx Sim script R .R base base Sim objetos salvos no R .RData, .rda base base Sim objetos do R serializados .rds base base Sim dados Fortran Sem extensão reconhecida utils Sim Formato de dados com largura fixa .fwf utils utils Sim dados separados por vírgula compactados com gzip .csv.gz utils utils Sim Feather R/Python interchange format .feather feather feather Não Armazenamento rápido (Fast Storage) .fst fst fst Não JSON .json jsonlite jsonlite Não Matlab .mat rmatio rmatio Não Planilha OpenDocument .ods readODS readODS Não tabelas HTML .html xml2 xml2 Não documentos XML .xml xml2 xml2 Não YAML .yml yaml yaml Não Área de transferência default é tsv clipr clipr Não planilhas Google como valores separados por vírgula "],
["para-saber-mais.html", "8.5 Para saber mais", " 8.5 Para saber mais Para uma descrição mais abrangente sobre importação e exportação de dados no consulte o manual R Data Import/Export e a documentação de ajuda das funções citadas naquele documento. "],
["referencias.html", "Referências", " Referências "],
["oper-mat.html", "A Operações adicionais com matrizes", " A Operações adicionais com matrizes Há outras formas de se construir uma matriz além daquela usando a função matrix(). Há também diveras operações matriciais que podem ser realizadas no . Aqui apresentam-se esse conteúdo complementar sobre matrizes. "],
["funcao-dim.html", "A.1 Função dim()", " A.1 Função dim() Podemos converter um vetor atômico em uma arranjo de n dimensões através do atributo da dimensão de um objeto. Este atributo pode ser alterado pela função dim(). Para fazer isso, definimos o atributo dim (de dimensão) com um vetor numérico com os tamanhos para cada dimensão. O R reorganizará os elementos do vetor de acordo com as dimensões. v &lt;- vetor &lt;- 1:12 length(v) #&gt; [1] 12 attributes(v) #&gt; NULL typeof(v) #&gt; [1] &quot;integer&quot; # conversão de vetor para matriz dim(v) &lt;- c(3, 4) # 1a dimensão: linhas , 2a dimensão: colunas # v é vector? is.vector(v) #&gt; [1] FALSE # v é matrix? is.matrix(v) #&gt; [1] TRUE # classe de vetor class(v) #&gt; [1] &quot;matrix&quot; attributes(v) #&gt; $dim #&gt; [1] 3 4 v #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 # invertendo as dimensões dim(v) &lt;- c(4, 3) v #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 O R usa o primeiro elemento de dim() para o número de linhas e o segundo para o número de colunas. De forma geral, em operações que usam linhas e colunas, as linhas vem sempre em primeiro lugar. Note como os valores de v foram distribuídos na matriz com 3 linhas e 4 colunas. O R sempre preenche a matriz ao longo das colunas. Para mais controle na forma como R reorganiza os dados em linhas e colunas, podemos utilizar a função matrix() ou array(). Elas fazem a mesma coisa que a dim() porém com argumentos mais versáteis para estruturar uma matrix. "],
["atribuicao-por-indexacao.html", "A.2 Atribuição por indexação", " A.2 Atribuição por indexação Uma matriz mat poderia ser criada especificando os valores de cada elemento : # criando a matriz gerada com dim mat &lt;- matrix(nrow = 3, ncol = 4) mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] NA NA NA NA #&gt; [2,] NA NA NA NA #&gt; [3,] NA NA NA NA mat[1, 1] &lt;- 1 mat[2, 1] &lt;- 2 mat[3, 1] &lt;- 3 mat[1, 2] &lt;- 4 mat[2, 2] &lt;- 5 mat[3, 2] &lt;- 6 mat[1, 3] &lt;- 7 mat[2, 3] &lt;- 8 mat[3, 3] &lt;- 9 mat[1, 4] &lt;- 10 mat[2, 4] &lt;- 11 mat[3, 4] &lt;- 12 mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 No exemplo a seguir os dados do vetor aparecem distribuídos ao longo das linhas e não das colunas como no caso acima. Nós definimos isso com o argumento byrow = TRUE da função matrix(): vetor &lt;- 1:12 mat &lt;- matrix(vetor, ncol = 4, byrow = TRUE) mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 "],
["operacoes-matriciais.html", "A.3 Operações matriciais", " A.3 Operações matriciais A.3.1 Multiplicação matricial Operações algébricas, incluindo a multiplicação *, atuam elemento a elemento sobre matrizes. Mas se a intenção é fazer uma multiplicação matricial (Figura A.1) usamos o operador (%*%). Figure A.1: Multiplicação matricial. # multiplicação de duas matrizes A &lt;- matrix(c(2, 1, 4, 3, 0, 5), ncol = 2) A #&gt; [,1] [,2] #&gt; [1,] 2 3 #&gt; [2,] 1 0 #&gt; [3,] 4 5 B &lt;- matrix(c(3, 2, 1, 4), ncol = 2) B #&gt; [,1] [,2] #&gt; [1,] 3 1 #&gt; [2,] 2 4 A * B # erro pela diferença nas dims entre as matrizes #&gt; Error in A * B: non-conformable arrays prod_mat &lt;- A %*% B prod_mat #&gt; [,1] [,2] #&gt; [1,] 12 14 #&gt; [2,] 3 1 #&gt; [3,] 22 24 # multiplicação de uma matriz por um escalar m &lt;- matrix(1:16, nrow = 4, byrow = TRUE) m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 #&gt; [4,] 13 14 15 16 m * 2 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 4 6 8 #&gt; [2,] 10 12 14 16 #&gt; [3,] 18 20 22 24 #&gt; [4,] 26 28 30 32 A.3.2 Adição matricial m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 #&gt; [4,] 13 14 15 16 m + m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 4 6 8 #&gt; [2,] 10 12 14 16 #&gt; [3,] 18 20 22 24 #&gt; [4,] 26 28 30 32 A.3.3 Produto escalar u &lt;- 1:3 v &lt;- c(5, 12, 13) u * v #&gt; [1] 5 24 39 # produto escalar = u.v = 1*5 + 2*12 + 3*13 crossprod(u, v) #&gt; [,1] #&gt; [1,] 68 A.3.4 Determinante # matriz exemplo mat_ex &lt;- matrix(c(1, -7, 3, 5, -9, 2, 6, 6, 1), ncol = 3) det(mat_ex) #&gt; [1] 182 A.3.5 Solução de sistemas lineares \\[ \\left\\{\\begin{matrix} x_1 + x_2 = 2 \\\\ -x_1 + x_2 = 4 \\end{matrix}\\right. \\] Qual os valores de \\(x_1\\) e \\(x_2\\)? # matrizes do sistema linear coefs &lt;- matrix(c(1, -1, 1, 1), ncol = 2) y &lt;- c(2, 4) x &lt;- solve(coefs, y) x #&gt; [1] -1 3 "],
["funcoes-nativas-do-r-para-importar-e-exportar-dados.html", "B Funções nativas do R para importar e exportar dados ", " B Funções nativas do R para importar e exportar dados "],
["amostras-pequenas-de-dados.html", "B.1 Amostras pequenas de dados", " B.1 Amostras pequenas de dados B.1.1 scan() Nós podemos informar os números de um vetor a partir do teclado, um de cada vez usando e quando terminar teclar enter: # Exemplo: vetor v1 &lt;- scan() # digite os números do v1, ao terminar, tecle enter A função scan() também pode ler dados de arquivos, mas a sua saída é um vetor, ou seja ela não mantém a estrutura dos dados contidos no arquivo. Vamos baixar um arquivo de dados do site com os dados do livro para ilustrar o uso da scan(). # download dados de exemplo aq_url &lt;- &quot;https://raw.githubusercontent.com/lhmet/adar-ufsm/master/data/airquality.txt&quot; # arquivo temporário, você pode substituir tempfile() por um caminho de seu computador, p.ex. &quot;~/Downloads&quot; (aq_dest_file &lt;- tempfile()) #&gt; [1] &quot;/tmp/RtmpH7ePAT/file266b692f4020&quot; download.file(aq_url, destfile = aq_dest_file) # Exemplo: vetor vetor_aq &lt;- scan(aq_dest_file) # parte inicial dos dados head(vetor_aq, 100) #&gt; [1] 41.0 190.0 7.4 67.0 5.0 1.0 36.0 118.0 8.0 72.0 #&gt; [11] 5.0 2.0 12.0 149.0 12.6 74.0 5.0 3.0 18.0 313.0 #&gt; [21] 11.5 62.0 5.0 4.0 -99.9 -99.9 14.3 56.0 5.0 5.0 #&gt; [31] 28.0 -99.9 14.9 66.0 5.0 6.0 23.0 299.0 8.6 65.0 #&gt; [41] 5.0 7.0 19.0 99.0 13.8 59.0 5.0 8.0 8.0 19.0 #&gt; [51] 20.1 61.0 5.0 9.0 -99.9 194.0 8.6 69.0 5.0 10.0 #&gt; [61] 7.0 -999.0 6.9 74.0 5.0 11.0 16.0 256.0 9.7 69.0 #&gt; [71] 5.0 12.0 11.0 290.0 9.2 66.0 5.0 13.0 14.0 274.0 #&gt; [81] 10.9 68.0 5.0 14.0 18.0 65.0 13.2 58.0 5.0 15.0 #&gt; [91] 14.0 334.0 11.5 64.0 5.0 16.0 34.0 307.0 12.0 66.0 # parte final tail(vetor_aq, 100) #&gt; [1] 24.0 10.9 71.0 9.0 14.0 13.0 112.0 11.5 71.0 9.0 15.0 #&gt; [12] 46.0 237.0 6.9 78.0 9.0 16.0 18.0 224.0 13.8 67.0 9.0 #&gt; [23] 13.0 27.0 10.3 76.0 9.0 18.0 24.0 238.0 10.3 68.0 9.0 #&gt; [34] 19.0 16.0 201.0 8.0 82.0 9.0 20.0 13.0 238.0 12.6 64.0 #&gt; [45] 9.0 21.0 23.0 14.0 9.2 71.0 9.0 22.0 36.0 139.0 10.3 #&gt; [56] 81.0 9.0 23.0 7.0 49.0 10.3 69.0 9.0 24.0 14.0 20.0 #&gt; [67] 16.6 63.0 9.0 25.0 30.0 193.0 6.9 70.0 9.0 26.0 -99.9 #&gt; [78] 145.0 13.2 77.0 9.0 27.0 14.0 191.0 14.3 75.0 9.0 28.0 #&gt; [89] 18.0 131.0 8.0 76.0 9.0 29.0 20.0 223.0 11.5 68.0 9.0 #&gt; [100] 30.0 # dados são importados como vetor is.vector(vetor_aq) #&gt; [1] TRUE mode(vetor_aq) #&gt; [1] &quot;numeric&quot; Vimos que dataframes são geralmente criados pela função data.frame, conforme o exemplo abaixo. # Exemplo: dataframe dados &lt;- data.frame( dates = c(&quot;2013-01-01&quot;, &quot;2013-01-01&quot;, &quot;2013-01-01&quot;), cidade = c(&quot;Santa Maria&quot;, &quot;Sao Sepe&quot;, &quot;Caçapava&quot;), temperatura = c(31, 35, 21), chuva = c(3, 10, 14) ) dados #&gt; dates cidade temperatura chuva #&gt; 1 2013-01-01 Santa Maria 31 3 #&gt; 2 2013-01-01 Sao Sepe 35 10 #&gt; 3 2013-01-01 Caçapava 21 14 B.1.2 readline() Para ler apenas uma linha de dados a partir do teclado como character usamos a função readline(): sentenca &lt;- readline(prompt = &quot;digite alguma coisa e tecle enter para continuar: &quot;) #&gt; digite alguma coisa e tecle enter para continuar: sentenca #&gt; [1] &quot;&quot; Esta função pode ser utilizada como uma forma de controlar um looping. Esse exemplo ilustra o uso da função lapply() para execução de laços ou loopings ao longo de um vetor de índices. Essa função será vista futuramente no curso. # para reprodutibilidade set.seed(123) # looping ao longo da sequência de 1 a 5 l &lt;- sapply( 1:5, function(i) { # cria vetor com números aleatórios com distribuição uniforme x &lt;- runif(n = 100, min = 1, max = 50) # anomalia acumulada y &lt;- cumsum(x - mean(x)) plot(y, type = &quot;o&quot;) abline(h = 0, lty = 2) # leitura de linha, só após teclar enter vai gerar próximo gráfico readline(prompt = &quot;tecle &lt;enter&gt; para continuar: &quot;) } ) l B.1.3 Impressão na tela No modo interativo do R podemos imprimir os valores de um objeto na tela digitando o nome do objeto. x &lt;- 1:3 y &lt;- x ^ 2 y #&gt; [1] 1 4 9 # ou print(x ^ 2) #&gt; [1] 1 4 9 Entretanto isso não é possível quando precisamos mostrar o valor de uma variável dentro do corpo de uma função ou dentro de um laço (looping). Nesse caso podemos usar a função print(): # dentro de uma função # digitando o nome do objeto não imprimi na tela fcubo &lt;- function(x) { classe &lt;- class(x) # intenção de mostrar objeto de entrada classe x ^ 3 } fcubo(2) #&gt; [1] 8 # adicionando print cubo &lt;- function(x) { # mostra objeto de entrada classe &lt;- class(x) print(classe) x ^ 3 } fcubo(-3) # não imprime classe do objeto de entrada #&gt; [1] -27 cubo(-3) # imprime classe do objeto de entrada #&gt; [1] &quot;numeric&quot; #&gt; [1] -27 B.1.3.1 cat() ao invés de print() É melhor usar a função cat() ao invés da função print(), já que a print() permite a impressão de apenas um único objeto enquanto a cat() não. Compare os resultados das duas funções: print(&quot;abc&quot;) #&gt; [1] &quot;abc&quot; cat(&quot;abc\\n&quot;) # \\n indica quebra de linha #&gt; abc x #&gt; [1] 1 2 3 cat(&quot;os elementos de x são: &quot;, x, &quot;\\n&quot;) #&gt; os elementos de x são: 1 2 3 cat(&quot;os elementos de x são: &quot;, x, sep = &quot;&quot;) #&gt; os elementos de x são: 123 cat(&quot;os elementos de x são: &quot;, x, sep = &quot;\\n&quot;) #&gt; os elementos de x são: #&gt; 1 #&gt; 2 #&gt; 3 k &lt;- c(5, 12, 13, 8, 88) cat(k, sep = c(&quot;.&quot;, &quot;___&quot;, &quot; ---&gt; &quot;, &quot;\\n&quot;, &quot;\\n&quot;)) #&gt; 5.12___13 ---&gt; 8 #&gt; 88 B.1.4 textConnection() Imagine que você tivesse recebido essa amostra de dados por e-mail: dates cidade temperatura chuva 2013-01-01 SM 13 3 2013-01-01 SS 30 10 2013-01-01 CV 22 12 Para converter essa pequena amostra de dados em um dataframe nós podemos selecionar, copiar e colar o texto no primeiro argumento da função textConnection, e então usar a função read.table. texto &lt;- &quot; dates cidade temperatura chuva 2013-01-01 SM 31 3 2013-01-01 SS 35 10 2013-01-01 CV 21 14&quot; # conexão de texto tc &lt;- textConnection(object = texto) tc #&gt; A connection with #&gt; description &quot;texto&quot; #&gt; class &quot;textConnection&quot; #&gt; mode &quot;r&quot; #&gt; text &quot;text&quot; #&gt; opened &quot;opened&quot; #&gt; can read &quot;yes&quot; #&gt; can write &quot;no&quot; x &lt;- read.table(file = tc, header = TRUE) x #&gt; dates cidade temperatura chuva #&gt; 1 2013-01-01 SM 31 3 #&gt; 2 2013-01-01 SS 35 10 #&gt; 3 2013-01-01 CV 21 14 "],
["exportando-e-recuperando-objetos-do-r-no-formato-textual.html", "B.2 Exportando e recuperando objetos do R no formato textual", " B.2 Exportando e recuperando objetos do R no formato textual B.2.1 dput(), dget, dump e source. Uma função útil para compartilhar dados com alguém que precisa reproduzi-los é a função dput() (que pode ser traduzido como &quot;despejar&quot;). Ela escreve uma representação textual de um objeto R que pode ser escrita em um arquivo. Para recriar o objeto basta usar a função dget(). x #&gt; dates cidade temperatura chuva #&gt; 1 2013-01-01 SM 31 3 #&gt; 2 2013-01-01 SS 35 10 #&gt; 3 2013-01-01 CV 21 14 # representação textual do objeto x dput(x) #&gt; structure(list(dates = structure(c(1L, 1L, 1L), .Label = &quot;2013-01-01&quot;, class = &quot;factor&quot;), #&gt; cidade = structure(c(2L, 3L, 1L), .Label = c(&quot;CV&quot;, &quot;SM&quot;, #&gt; &quot;SS&quot;), class = &quot;factor&quot;), temperatura = c(31L, 35L, 21L), #&gt; chuva = c(3L, 10L, 14L)), class = &quot;data.frame&quot;, row.names = c(NA, #&gt; -3L)) # salva representação textual de x em um arquivo temporário, você pode substituir tempfile() por um caminho de seu computador, p.ex. &quot;~/Downloads&quot; (aq_dest_file &lt;- tempfile()) #&gt; [1] &quot;/tmp/RtmpH7ePAT/file266b782e17e5&quot; (x_dest_file &lt;- tempfile()) #&gt; [1] &quot;/tmp/RtmpH7ePAT/file266b2ea044a6&quot; dput(x, file = x_dest_file) # recuperando x a partir do arquivo y &lt;- dget(x_dest_file) # alterar valores de y y &lt;- y[, 3:4] - sqrt(2) y #&gt; temperatura chuva #&gt; 1 29.58579 1.585786 #&gt; 2 33.58579 8.585786 #&gt; 3 19.58579 12.585786 # verificar existência de x e y ls() #&gt; [1] &quot;aq_dest_file&quot; &quot;aq_url&quot; &quot;cubo&quot; &quot;dados&quot; #&gt; [5] &quot;fcubo&quot; &quot;k&quot; &quot;pcks&quot; &quot;rblue&quot; #&gt; [9] &quot;sentenca&quot; &quot;tc&quot; &quot;texto&quot; &quot;vetor_aq&quot; #&gt; [13] &quot;x&quot; &quot;x_dest_file&quot; &quot;y&quot; # listando variáveis que começam com x ou y ls(pattern = &quot;^[xy]&quot;) #&gt; [1] &quot;x&quot; &quot;x_dest_file&quot; &quot;y&quot; # salvando mais de um objeto em um arquivo (xy_dest_file &lt;- tempfile()) #&gt; [1] &quot;/tmp/RtmpH7ePAT/file266b4089a352&quot; dump(ls(pattern = &quot;^[xy]&quot;), file = xy_dest_file) # vamos apagar x e y do espaco de trabalho rm(x, y) # x e y não existem mais ls() #&gt; [1] &quot;aq_dest_file&quot; &quot;aq_url&quot; &quot;cubo&quot; &quot;dados&quot; #&gt; [5] &quot;fcubo&quot; &quot;k&quot; &quot;pcks&quot; &quot;rblue&quot; #&gt; [9] &quot;sentenca&quot; &quot;tc&quot; &quot;texto&quot; &quot;vetor_aq&quot; #&gt; [13] &quot;x_dest_file&quot; &quot;xy_dest_file&quot; # recuperando os objetos x e y salvos em xy.R source(xy_dest_file) ls() #&gt; [1] &quot;aq_dest_file&quot; &quot;aq_url&quot; &quot;cubo&quot; &quot;dados&quot; #&gt; [5] &quot;fcubo&quot; &quot;k&quot; &quot;pcks&quot; &quot;rblue&quot; #&gt; [9] &quot;sentenca&quot; &quot;tc&quot; &quot;texto&quot; &quot;vetor_aq&quot; #&gt; [13] &quot;x&quot; &quot;x_dest_file&quot; &quot;xy_dest_file&quot; &quot;y&quot; x #&gt; dates cidade temperatura chuva #&gt; 1 2013-01-01 SM 31 3 #&gt; 2 2013-01-01 SS 35 10 #&gt; 3 2013-01-01 CV 21 14 y #&gt; temperatura chuva #&gt; 1 29.58579 1.585786 #&gt; 2 33.58579 8.585786 #&gt; 3 19.58579 12.585786 Portanto diferente da escrita dos dados em si para um arquivo texto as funções dump() e dput() armazenam os dados e os metadados, assim outro usuário não precisa especificá-los novamente. Assim o usuário que recebe a saída do dput() em um arquivo, pode recriar os dados pelo comando dget(&quot;nomedoarquivo&quot;). # representação textual de um data.frame dados3est &lt;- structure( list( dates = c(&quot;2013-01-01&quot;, &quot;2013-01-01&quot;, &quot;2013-01-01&quot;), cidade = c(&quot;SM&quot;, &quot;SS&quot;, &quot;CV&quot;), temperatura = c(31L, 35L, 21L), chuva = c(3L, 10L, 14L) ), .Names = c(&quot;dates&quot;, &quot;cidade&quot;, &quot;temperatura&quot;, &quot;chuva&quot;), class = &quot;data.frame&quot;, row.names = c(NA, -3L) ) dados3est #&gt; dates cidade temperatura chuva #&gt; 1 2013-01-01 SM 31 3 #&gt; 2 2013-01-01 SS 35 10 #&gt; 3 2013-01-01 CV 21 14 Vantagens: armazena os dados e os metadados recuperação rápida e fácil dos dados Desvantagens: armazenamento de dados nesse formato não é muito eficiente em termos de espaço em disco pouca legibilidade dos dados Esse procedimento é geralmente recomendado para fornecer pequenas amostras de dados (e-mails por exemplo) "],
["dados-de-pacotes-do-r.html", "B.3 Dados de pacotes do R", " B.3 Dados de pacotes do R O R possui diversos conjuntos de dados internos que são automaticamente carregados quando iniciado. Esses dados são usados nos exemplos do help() de diversas funções para ilustrar o uso e a aplicação delas. Esses dados podem ser carregados com a função data(). # lista de dados disponíveis data() # Annual Precipitation in US Cities, p/ mais informações &quot;?precip&quot; data(precip) # primeiros 30 elementos dos dados precip head(precip, n = 30) #&gt; Mobile Juneau Phoenix #&gt; 67.0 54.7 7.0 #&gt; Little Rock Los Angeles Sacramento #&gt; 48.5 14.0 17.2 #&gt; San Francisco Denver Hartford #&gt; 20.7 13.0 43.4 #&gt; Wilmington Washington Jacksonville #&gt; 40.2 38.9 54.5 #&gt; Miami Atlanta Honolulu #&gt; 59.8 48.3 22.9 #&gt; Boise Chicago Peoria #&gt; 11.5 34.4 35.1 #&gt; Indianapolis Des Moines Wichita #&gt; 38.7 30.8 30.6 #&gt; Louisville New Orleans Portland #&gt; 43.1 56.8 40.8 #&gt; Baltimore Boston Detroit #&gt; 41.8 42.5 31.0 #&gt; Sault Ste. Marie Duluth Minneapolis/St Paul #&gt; 31.7 30.2 25.9 # New York Air Quality Measurements, , p/ mais informações &quot;?airquality&quot; data(airquality) # primeiras linhas dos dados head(airquality, n = 10) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 #&gt; 7 23 299 8.6 65 5 7 #&gt; 8 19 99 13.8 59 5 8 #&gt; 9 8 19 20.1 61 5 9 #&gt; 10 NA 194 8.6 69 5 10 "],
["arquivos-de-texto.html", "B.4 Arquivos de texto", " B.4 Arquivos de texto A função nativa do mais usada para leitura de dados de um arquivo texto é a read.table(). Os dados lidos são armazenados em um dataframe. Essa função possui diversos parâmetros para especificar a importação de acordo com as peculiaridades do formato de dados do arquivo. O valor default do parâmetro sep é um ou mais caracteres de espaço e tabs. Devido as diversas opções de separadores existem outras funções envelopes da read.table(), com a diferença no separador, por exemplo as funções: read.csv(), read.csv2(), read.delim() que chamam a read.table(), dentro corpo da função, com o argumento sep definido como ,, ; e \\t, respectivamente. Para detalhes sobre essas funções o help de cada uma. Uma vez que essas funções aceitam qualquer argumento da read.table() elas são mais convenientes que usar a read.table() e configurar os argumentos apropriados manualmente. Alguns argumentos da função read.table() são: file nome do arquivo header lógico (TRUE ou FALSE) indicando se o arquivo tem ou não linha de cabeçalho sep um caractere indicando como as colunas são separadas colClasses, um vetor caractere indicando as classes de cada coluna no conjunto de dados nrows, número de linhas no conjunto de dados comment.char, um caractere indicando o caractere usado como comentário (para ignorar essas linhas) skip, o número de linhas que devem ser “puladas” desde o início do arquivo stringsAsFactors, lógico, as variáveis do tipo character devem ser codificadas como factor? Esse último argumento pode ser definido também através da configuração global de opções no R pelo comando: options(stringsAsFactors=FALSE). Quando se faz a leitura de dados com read.table(&quot;nome_do_arquivo&quot;) o R automaticamente: pula linhas que começam com ‘#’ descobre quantas linhas tem o arquivo e quanta memória precisa ser alocada descobre qual o tipo de variável em cada coluna Vamos ver alguns exemplos de leitura de dados hidrometeorológicos no formato texto amplamente usados em aplicações da Meteorologia. B.4.1 Dados hidrometeorológicos brasileiros B.4.1.1 hidroweb-ANA O sistema hidroweb é o maior base de dados hidrológicos brasileira. No trecho de código a seguir baixamos um arquivo de dados de precipitação obtidos no sistema hidroweb que foi salvo no site do livro. # arquivo de exemplo disponível no GitHub hidroweb_url_file &lt;- &quot;https://raw.github.com/lhmet/adar-ufsm/master/data/CHUVAS.TXT&quot; #arquivo temporário, você pode substituir tempfile() por um caminho de seu computador, p.ex. &quot;~/Downloads/CHUVAS.TXT&quot; hidroweb_dest_file &lt;- tempfile() download.file( url = hidroweb_url_file, destfile = hidroweb_dest_file ) Antes de importar os dados você precisa visualizar o arquivo para extrair as informações básicas necessárias para sua importação. Você pode abri-lo em um editor de texto ou # caracteres não devem tratados como fatores options(stringsAsFactors = FALSE) # leitura de dados da ANA dprec &lt;- read.csv2(file = hidroweb_url_file, skip = 15, head = TRUE, fill = TRUE) # primeiras linhas head(dprec) #&gt; X..EstacaoCodigo NivelConsistencia Data TipoMedicaoChuvas Maxima #&gt; 1 3054002 1 01/01/1934 1 NA #&gt; 2 3054002 1 01/02/1934 1 66.3 #&gt; 3 3054002 1 01/03/1934 1 55.0 #&gt; 4 3054002 1 01/04/1934 1 54.5 #&gt; 5 3054002 1 01/05/1934 1 30.5 #&gt; 6 3054002 1 01/06/1934 1 42.5 #&gt; Total DiaMaxima NumDiasDeChuva MaximaStatus TotalStatus #&gt; 1 NA NA NA 0 0 #&gt; 2 174.7 6 10 1 1 #&gt; 3 160.7 9 10 1 1 #&gt; 4 98.4 1 4 1 1 #&gt; 5 119.4 29 8 1 1 #&gt; 6 191.6 13 11 1 1 #&gt; NumDiasDeChuvaStatus TotalAnual TotalAnualStatus Chuva01 Chuva02 Chuva03 #&gt; 1 0 NA 0 NA NA NA #&gt; 2 0 NA 0 15.5 3.5 0.0 #&gt; 3 0 NA 0 0.0 0.0 0.0 #&gt; 4 0 NA 0 54.5 0.0 0.0 #&gt; 5 1 NA 0 0.0 19.0 26.7 #&gt; 6 0 NA 0 0.0 0.0 21.5 #&gt; Chuva04 Chuva05 Chuva06 Chuva07 Chuva08 Chuva09 Chuva10 Chuva11 Chuva12 #&gt; 1 NA 10.5 3.0 11.1 0.0 0 0.0 0.0 0.0 #&gt; 2 0.0 11.9 66.3 1.0 40.0 0 0.0 0.0 1.1 #&gt; 3 0.0 0.0 0.0 0.0 0.0 55 11.7 5.0 0.0 #&gt; 4 0.0 0.0 18.5 0.0 19.5 0 0.0 0.0 0.0 #&gt; 5 0.0 3.2 4.2 0.0 0.0 0 0.0 0.0 0.0 #&gt; 6 12.7 8.7 0.0 0.0 0.0 0 0.0 27.3 37.5 #&gt; Chuva13 Chuva14 Chuva15 Chuva16 Chuva17 Chuva18 Chuva19 Chuva20 Chuva21 #&gt; 1 0.0 0.0 0 37.6 0 18.4 12.5 0.0 0.0 #&gt; 2 24.7 0.0 0 0.0 0 0.0 0.0 0.0 0.0 #&gt; 3 7.5 9.5 0 3.0 1 23.0 0.0 0.0 0.0 #&gt; 4 0.0 0.0 0 0.0 0 0.0 0.0 0.0 0.0 #&gt; 5 0.0 0.0 0 0.0 0 0.0 0.0 0.0 20.5 #&gt; 6 42.5 0.0 0 0.0 0 0.0 0.0 0.7 3.2 #&gt; Chuva22 Chuva23 Chuva24 Chuva25 Chuva26 Chuva27 Chuva28 Chuva29 Chuva30 #&gt; 1 67.5 12.3 0.0 0.0 0 0 0 0.0 0.0 #&gt; 2 0.0 0.0 8.2 2.5 0 0 0 NA NA #&gt; 3 0.0 0.0 0.0 0.0 0 0 0 0.0 23.5 #&gt; 4 0.0 0.0 0.0 5.9 0 0 0 0.0 0.0 #&gt; 5 0.0 0.0 0.0 1.3 0 0 14 30.5 0.0 #&gt; 6 3.0 0.0 33.5 0.0 0 0 1 0.0 0.0 #&gt; Chuva31 Chuva01Status Chuva02Status Chuva03Status Chuva04Status #&gt; 1 0.0 0 0 0 0 #&gt; 2 NA 1 1 1 1 #&gt; 3 21.5 1 1 1 1 #&gt; 4 NA 1 1 1 1 #&gt; 5 0.0 1 1 1 1 #&gt; 6 NA 1 1 1 1 #&gt; Chuva05Status Chuva06Status Chuva07Status Chuva08Status Chuva09Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva10Status Chuva11Status Chuva12Status Chuva13Status Chuva14Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva15Status Chuva16Status Chuva17Status Chuva18Status Chuva19Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva20Status Chuva21Status Chuva22Status Chuva23Status Chuva24Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva25Status Chuva26Status Chuva27Status Chuva28Status Chuva29Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 0 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva30Status Chuva31Status X #&gt; 1 1 1 NA #&gt; 2 0 0 NA #&gt; 3 1 1 NA #&gt; 4 1 0 NA #&gt; 5 1 1 NA #&gt; 6 1 0 NA # últimas linhas tail(dprec) #&gt; X..EstacaoCodigo NivelConsistencia Data TipoMedicaoChuvas #&gt; 1279 3054002 2 01/07/2005 1 #&gt; 1280 3054002 2 01/08/2005 1 #&gt; 1281 3054002 2 01/09/2005 1 #&gt; 1282 3054002 2 01/10/2005 1 #&gt; 1283 3054002 2 01/11/2005 1 #&gt; 1284 3054002 2 01/12/2005 1 #&gt; Maxima Total DiaMaxima NumDiasDeChuva MaximaStatus TotalStatus #&gt; 1279 44.8 69.5 4 4 1 1 #&gt; 1280 19.9 91.4 30 9 1 1 #&gt; 1281 49.8 149.2 24 12 1 1 #&gt; 1282 57.2 145.3 4 6 1 1 #&gt; 1283 14.2 36.0 24 5 1 1 #&gt; 1284 11.2 22.0 31 6 1 1 #&gt; NumDiasDeChuvaStatus TotalAnual TotalAnualStatus Chuva01 Chuva02 #&gt; 1279 1 1123.4 1 0.0 0.0 #&gt; 1280 1 1123.4 1 0.0 0.0 #&gt; 1281 1 1123.4 1 3.8 11.3 #&gt; 1282 1 1123.4 1 0.0 0.0 #&gt; 1283 1 1123.4 1 0.0 0.0 #&gt; 1284 1 1123.4 1 0.0 0.0 #&gt; Chuva03 Chuva04 Chuva05 Chuva06 Chuva07 Chuva08 Chuva09 Chuva10 #&gt; 1279 0 44.8 0.0 0.0 0.0 0 0.0 0.0 #&gt; 1280 0 0.0 0.0 0.0 0.5 0 0.1 0.0 #&gt; 1281 0 0.0 0.0 0.0 0.0 0 8.9 24.7 #&gt; 1282 0 57.2 19.6 0.0 0.0 0 0.0 0.0 #&gt; 1283 0 0.0 13.2 6.3 0.0 0 0.0 0.0 #&gt; 1284 0 2.1 1.9 0.0 0.0 0 0.0 0.0 #&gt; Chuva11 Chuva12 Chuva13 Chuva14 Chuva15 Chuva16 Chuva17 Chuva18 #&gt; 1279 0.0 0 0 0.0 0.0 12.9 9.7 0.0 #&gt; 1280 0.0 0 0 0.0 0.0 0.0 0.0 14.1 #&gt; 1281 9.7 0 0 0.2 15.6 0.1 0.0 3.2 #&gt; 1282 0.0 0 0 46.3 0.0 3.9 0.2 0.0 #&gt; 1283 0.0 0 0 0.0 1.4 0.0 0.9 0.0 #&gt; 1284 0.0 0 0 0.0 0.0 0.0 2.2 0.0 #&gt; Chuva19 Chuva20 Chuva21 Chuva22 Chuva23 Chuva24 Chuva25 Chuva26 #&gt; 1279 0.0 0 0.0 2.1 0.0 0.0 0.0 0 #&gt; 1280 0.0 0 6.3 19.7 6.4 17.1 0.0 0 #&gt; 1281 4.5 0 0.0 0.0 0.0 49.8 0.0 0 #&gt; 1282 0.0 0 0.0 0.0 0.0 0.0 18.1 0 #&gt; 1283 0.0 0 0.0 0.0 0.0 14.2 0.0 0 #&gt; 1284 0.7 0 0.0 0.0 0.0 0.0 0.0 0 #&gt; Chuva27 Chuva28 Chuva29 Chuva30 Chuva31 Chuva01Status Chuva02Status #&gt; 1279 0 0 0.0 0.0 0.0 1 1 #&gt; 1280 0 0 7.3 19.9 0.0 1 1 #&gt; 1281 0 0 0.0 17.4 NA 1 1 #&gt; 1282 0 0 0.0 0.0 0.0 1 1 #&gt; 1283 0 0 0.0 0.0 NA 1 1 #&gt; 1284 0 0 0.0 3.9 11.2 1 1 #&gt; Chuva03Status Chuva04Status Chuva05Status Chuva06Status Chuva07Status #&gt; 1279 1 1 1 1 1 #&gt; 1280 1 1 1 1 1 #&gt; 1281 1 1 1 1 1 #&gt; 1282 1 1 1 1 1 #&gt; 1283 1 1 1 1 1 #&gt; 1284 1 1 1 1 1 #&gt; Chuva08Status Chuva09Status Chuva10Status Chuva11Status Chuva12Status #&gt; 1279 1 1 1 1 1 #&gt; 1280 1 1 1 1 1 #&gt; 1281 1 1 1 1 1 #&gt; 1282 1 1 1 1 1 #&gt; 1283 1 1 1 1 1 #&gt; 1284 1 1 1 1 1 #&gt; Chuva13Status Chuva14Status Chuva15Status Chuva16Status Chuva17Status #&gt; 1279 1 1 1 1 1 #&gt; 1280 1 1 1 1 1 #&gt; 1281 1 1 1 1 1 #&gt; 1282 1 1 1 1 1 #&gt; 1283 1 1 1 1 1 #&gt; 1284 1 1 1 1 1 #&gt; Chuva18Status Chuva19Status Chuva20Status Chuva21Status Chuva22Status #&gt; 1279 1 1 1 1 1 #&gt; 1280 1 1 1 1 1 #&gt; 1281 1 1 1 1 1 #&gt; 1282 1 1 1 1 1 #&gt; 1283 1 1 1 1 1 #&gt; 1284 1 1 1 1 1 #&gt; Chuva23Status Chuva24Status Chuva25Status Chuva26Status Chuva27Status #&gt; 1279 1 1 1 1 1 #&gt; 1280 1 1 1 1 1 #&gt; 1281 1 1 1 1 1 #&gt; 1282 1 1 1 1 1 #&gt; 1283 1 1 1 1 1 #&gt; 1284 1 1 1 1 1 #&gt; Chuva28Status Chuva29Status Chuva30Status Chuva31Status X #&gt; 1279 1 1 1 1 NA #&gt; 1280 1 1 1 1 NA #&gt; 1281 1 1 1 0 NA #&gt; 1282 1 1 1 1 NA #&gt; 1283 1 1 1 0 NA #&gt; 1284 1 1 1 1 NA # corrigindo nome da primeira coluna names(dprec)[1] &lt;- &quot;EstacaoCodigo&quot; # removendo última coluna que só tem NAs dprec &lt;- dprec[ , -ncol(dprec)] # estrutura dos dados str(dprec) #&gt; &#39;data.frame&#39;: 1284 obs. of 75 variables: #&gt; $ EstacaoCodigo : int 3054002 3054002 3054002 3054002 3054002 3054002 3054002 3054002 3054002 3054002 ... #&gt; $ NivelConsistencia : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Data : chr &quot;01/01/1934&quot; &quot;01/02/1934&quot; &quot;01/03/1934&quot; &quot;01/04/1934&quot; ... #&gt; $ TipoMedicaoChuvas : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Maxima : num NA 66.3 55 54.5 30.5 42.5 10.5 30.3 36.8 69.2 ... #&gt; $ Total : num NA 174.7 160.7 98.4 119.4 ... #&gt; $ DiaMaxima : int NA 6 9 1 29 13 6 30 19 5 ... #&gt; $ NumDiasDeChuva : int NA 10 10 4 8 11 7 8 4 7 ... #&gt; $ MaximaStatus : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ TotalStatus : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ NumDiasDeChuvaStatus: int 0 0 0 0 1 0 0 0 0 0 ... #&gt; $ TotalAnual : num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ TotalAnualStatus : int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ Chuva01 : num NA 15.5 0 54.5 0 0 0 0 0 0 ... #&gt; $ Chuva02 : num NA 3.5 0 0 19 0 0 0 0 0 ... #&gt; $ Chuva03 : num NA 0 0 0 26.7 21.5 0 0 0 0 ... #&gt; $ Chuva04 : num NA 0 0 0 0 12.7 0 0 0 20.8 ... #&gt; $ Chuva05 : num 10.5 11.9 0 0 3.2 8.7 0 27.5 0 69.2 ... #&gt; $ Chuva06 : num 3 66.3 0 18.5 4.2 0 10.5 0 5 6.1 ... #&gt; $ Chuva07 : num 11.1 1 0 0 0 0 4 2.9 0 0 ... #&gt; $ Chuva08 : num 0 40 0 19.5 0 0 0 5.4 0 0 ... #&gt; $ Chuva09 : num 0 0 55 0 0 0 0 0 0 0 ... #&gt; $ Chuva10 : num 0 0 11.7 0 0 0 0 13.6 0 0 ... #&gt; $ Chuva11 : num 0 0 5 0 0 27.3 0 0 34.5 0 ... #&gt; $ Chuva12 : num 0 1.1 0 0 0 37.5 0 0 0 0 ... #&gt; $ Chuva13 : num 0 24.7 7.5 0 0 42.5 1.2 0 0 0 ... #&gt; $ Chuva14 : num 0 0 9.5 0 0 0 0.7 0 0 0 ... #&gt; $ Chuva15 : num 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ Chuva16 : num 37.6 0 3 0 0 0 0 1.8 0 0 ... #&gt; $ Chuva17 : num 0 0 1 0 0 0 0 17 0 0 ... #&gt; $ Chuva18 : num 18.4 0 23 0 0 0 7.2 0 0 0 ... #&gt; $ Chuva19 : num 12.5 0 0 0 0 0 0 0 36.8 0 ... #&gt; $ Chuva20 : num 0 0 0 0 0 0.7 0 0 17.7 0 ... #&gt; $ Chuva21 : num 0 0 0 0 20.5 3.2 0 0 0 0 ... #&gt; $ Chuva22 : num 67.5 0 0 0 0 3 0 0 0 0 ... #&gt; $ Chuva23 : num 12.3 0 0 0 0 0 0 0 0 14 ... #&gt; $ Chuva24 : num 0 8.2 0 0 0 33.5 0 0 0 40 ... #&gt; $ Chuva25 : num 0 2.5 0 5.9 1.3 0 0 0 0 1 ... #&gt; $ Chuva26 : num 0 0 0 0 0 0 1.1 0 0 5.4 ... #&gt; $ Chuva27 : num 0 0 0 0 0 0 5.9 0 0 0 ... #&gt; $ Chuva28 : num 0 0 0 0 14 1 0 0 0 0 ... #&gt; $ Chuva29 : num 0 NA 0 0 30.5 0 0 0 0 0 ... #&gt; $ Chuva30 : num 0 NA 23.5 0 0 0 0 30.3 0 0 ... #&gt; $ Chuva31 : num 0 NA 21.5 NA 0 NA 0 1.8 NA 0 ... #&gt; $ Chuva01Status : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva02Status : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva03Status : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva04Status : int 0 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva05Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva06Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva07Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva08Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva09Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva10Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva11Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva12Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva13Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva14Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva15Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva16Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva17Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva18Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva19Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva20Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva21Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva22Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva23Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva24Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva25Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva26Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva27Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva28Status : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva29Status : int 1 0 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva30Status : int 1 0 1 1 1 1 1 1 1 1 ... #&gt; $ Chuva31Status : int 1 0 1 0 1 0 1 1 0 1 ... # Fazendo a mesma leitura com read.table dprec2 &lt;- read.table(file = hidroweb_url_file, skip = 15, head = T, stringsAsFactors = FALSE, fill = T, sep = &quot;;&quot;, dec = &quot;,&quot;) head(dprec2) #&gt; X..EstacaoCodigo NivelConsistencia Data TipoMedicaoChuvas Maxima #&gt; 1 3054002 1 01/01/1934 1 NA #&gt; 2 3054002 1 01/02/1934 1 66.3 #&gt; 3 3054002 1 01/03/1934 1 55.0 #&gt; 4 3054002 1 01/04/1934 1 54.5 #&gt; 5 3054002 1 01/05/1934 1 30.5 #&gt; 6 3054002 1 01/06/1934 1 42.5 #&gt; Total DiaMaxima NumDiasDeChuva MaximaStatus TotalStatus #&gt; 1 NA NA NA 0 0 #&gt; 2 174.7 6 10 1 1 #&gt; 3 160.7 9 10 1 1 #&gt; 4 98.4 1 4 1 1 #&gt; 5 119.4 29 8 1 1 #&gt; 6 191.6 13 11 1 1 #&gt; NumDiasDeChuvaStatus TotalAnual TotalAnualStatus Chuva01 Chuva02 Chuva03 #&gt; 1 0 NA 0 NA NA NA #&gt; 2 0 NA 0 15.5 3.5 0.0 #&gt; 3 0 NA 0 0.0 0.0 0.0 #&gt; 4 0 NA 0 54.5 0.0 0.0 #&gt; 5 1 NA 0 0.0 19.0 26.7 #&gt; 6 0 NA 0 0.0 0.0 21.5 #&gt; Chuva04 Chuva05 Chuva06 Chuva07 Chuva08 Chuva09 Chuva10 Chuva11 Chuva12 #&gt; 1 NA 10.5 3.0 11.1 0.0 0 0.0 0.0 0.0 #&gt; 2 0.0 11.9 66.3 1.0 40.0 0 0.0 0.0 1.1 #&gt; 3 0.0 0.0 0.0 0.0 0.0 55 11.7 5.0 0.0 #&gt; 4 0.0 0.0 18.5 0.0 19.5 0 0.0 0.0 0.0 #&gt; 5 0.0 3.2 4.2 0.0 0.0 0 0.0 0.0 0.0 #&gt; 6 12.7 8.7 0.0 0.0 0.0 0 0.0 27.3 37.5 #&gt; Chuva13 Chuva14 Chuva15 Chuva16 Chuva17 Chuva18 Chuva19 Chuva20 Chuva21 #&gt; 1 0.0 0.0 0 37.6 0 18.4 12.5 0.0 0.0 #&gt; 2 24.7 0.0 0 0.0 0 0.0 0.0 0.0 0.0 #&gt; 3 7.5 9.5 0 3.0 1 23.0 0.0 0.0 0.0 #&gt; 4 0.0 0.0 0 0.0 0 0.0 0.0 0.0 0.0 #&gt; 5 0.0 0.0 0 0.0 0 0.0 0.0 0.0 20.5 #&gt; 6 42.5 0.0 0 0.0 0 0.0 0.0 0.7 3.2 #&gt; Chuva22 Chuva23 Chuva24 Chuva25 Chuva26 Chuva27 Chuva28 Chuva29 Chuva30 #&gt; 1 67.5 12.3 0.0 0.0 0 0 0 0.0 0.0 #&gt; 2 0.0 0.0 8.2 2.5 0 0 0 NA NA #&gt; 3 0.0 0.0 0.0 0.0 0 0 0 0.0 23.5 #&gt; 4 0.0 0.0 0.0 5.9 0 0 0 0.0 0.0 #&gt; 5 0.0 0.0 0.0 1.3 0 0 14 30.5 0.0 #&gt; 6 3.0 0.0 33.5 0.0 0 0 1 0.0 0.0 #&gt; Chuva31 Chuva01Status Chuva02Status Chuva03Status Chuva04Status #&gt; 1 0.0 0 0 0 0 #&gt; 2 NA 1 1 1 1 #&gt; 3 21.5 1 1 1 1 #&gt; 4 NA 1 1 1 1 #&gt; 5 0.0 1 1 1 1 #&gt; 6 NA 1 1 1 1 #&gt; Chuva05Status Chuva06Status Chuva07Status Chuva08Status Chuva09Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva10Status Chuva11Status Chuva12Status Chuva13Status Chuva14Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva15Status Chuva16Status Chuva17Status Chuva18Status Chuva19Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva20Status Chuva21Status Chuva22Status Chuva23Status Chuva24Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 1 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva25Status Chuva26Status Chuva27Status Chuva28Status Chuva29Status #&gt; 1 1 1 1 1 1 #&gt; 2 1 1 1 1 0 #&gt; 3 1 1 1 1 1 #&gt; 4 1 1 1 1 1 #&gt; 5 1 1 1 1 1 #&gt; 6 1 1 1 1 1 #&gt; Chuva30Status Chuva31Status X #&gt; 1 1 1 NA #&gt; 2 0 0 NA #&gt; 3 1 1 NA #&gt; 4 1 0 NA #&gt; 5 1 1 NA #&gt; 6 1 0 NA B.4.1.2 BDMEP-INMET O Banco de Dados Meteorológicos para Ensino e Pesquisa do INMET é uma das principais fonte de dados climáticos brasileiros. Abaixo veremos como importar um arquivo de dados diários de uma estação meteorológica convencional. Os dados foram obtidos no BDMEP e salvos no site do livro. No trecho de código a seguir baixamos o arquivo de dados da estação 83004. # arquivo de exemplo disponível no GitHub bdmep_url_file &lt;- &quot;https://raw.githubusercontent.com/lhmet/adar-ufsm/master/data/83004.txt&quot; #arquivo temporário, você pode substituir tempfile() por um caminho de seu computador, p.ex. &quot;~/Downloads/CHUVAS.TXT&quot; bdmep_dest_file &lt;- tempfile() download.file( url = bdmep_url_file, destfile = bdmep_dest_file ) x &lt;- read.csv2(file = bdmep_dest_file, header = FALSE, skip = 16, stringsAsFactors = FALSE, na.strings = &quot;&quot; ) head(x) #&gt; V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 V13 #&gt; 1 83004 02/08/1993 0 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; #&gt; 2 83004 01/01/1995 0 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 26.8 &lt;NA&gt; NA &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; #&gt; 3 83004 01/01/1995 1200 21.2 22.5 20 &lt;NA&gt; 19.5 80 924.6 &lt;NA&gt; 32 4 #&gt; 4 83004 01/01/1995 1800 &lt;NA&gt; 25.2 21.5 &lt;NA&gt; &lt;NA&gt; 73 922.9 &lt;NA&gt; 32 2 #&gt; 5 83004 02/01/1995 0 &lt;NA&gt; 20.7 20.3 28.9 &lt;NA&gt; 97 924.2 &lt;NA&gt; 0 0 #&gt; 6 83004 02/01/1995 1200 3.2 23.8 20.6 &lt;NA&gt; 19.9 76 924.7 &lt;NA&gt; 32 3 #&gt; V14 V15 V16 V17 V18 V19 V20 #&gt; 1 &lt;NA&gt; &lt;NA&gt; 1.4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA #&gt; 2 1.5 &lt;NA&gt; 1.6 22.04 86.75 2 NA #&gt; 3 &lt;NA&gt; 10 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA #&gt; 4 &lt;NA&gt; 10 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA #&gt; 5 1.3 10 1.1 23.32 83 2.666667 NA #&gt; 6 &lt;NA&gt; 10 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA str(x) #&gt; &#39;data.frame&#39;: 5863 obs. of 20 variables: #&gt; $ V1 : chr &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; ... #&gt; $ V2 : chr &quot;02/08/1993&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; ... #&gt; $ V3 : int 0 0 1200 1800 0 1200 1800 0 1200 1800 ... #&gt; $ V4 : chr NA NA &quot;21.2&quot; NA ... #&gt; $ V5 : chr NA NA &quot;22.5&quot; &quot;25.2&quot; ... #&gt; $ V6 : chr NA NA &quot;20&quot; &quot;21.5&quot; ... #&gt; $ V7 : chr NA &quot;26.8&quot; NA NA ... #&gt; $ V8 : chr NA NA &quot;19.5&quot; NA ... #&gt; $ V9 : int NA NA 80 73 97 76 66 95 86 94 ... #&gt; $ V10: chr NA NA &quot;924.6&quot; &quot;922.9&quot; ... #&gt; $ V11: chr NA NA NA NA ... #&gt; $ V12: int NA NA 32 32 0 32 32 0 0 5 ... #&gt; $ V13: chr NA NA &quot;4&quot; &quot;2&quot; ... #&gt; $ V14: chr NA &quot;1.5&quot; NA NA ... #&gt; $ V15: chr NA NA &quot;10&quot; &quot;10&quot; ... #&gt; $ V16: chr &quot;1.4&quot; &quot;1.6&quot; NA NA ... #&gt; $ V17: chr NA &quot;22.04&quot; NA NA ... #&gt; $ V18: chr NA &quot;86.75&quot; NA NA ... #&gt; $ V19: chr NA &quot;2&quot; NA NA ... #&gt; $ V20: logi NA NA NA NA NA NA ... Os dados lidos não incluíram a linha de cabeçalho com os nomes das variáveis. Nós pulamos essa linha porque o nome das variáveis está de acordo como número de colunas do arquivo. Então se tentarmos ler um arquivo de dados que contém linhas com número de registros diferentes ocorrerá um erro pois os dados não são tabulares. Outro aspecto nos dados lidos é que aparecem vários &lt;NA&gt;, que é o símbolo para dados do tipo character faltantes. A razão dos terem sido interpretados dessa forma deve-se a um caractere (&lt;/pre&gt;) encontrado na última linha do arquivo. Para que os dados numéricos não sejam interpretados como caractere nós poderíamos executar a função read.table(..., nrows = 5878), que ignoraria a última linha do arquivo e os dados seriam interpretados como numeric. x1 &lt;- read.csv2(file=bdmep_dest_file, header = FALSE, skip = 16, stringsAsFactors = FALSE, dec = &quot;.&quot;, na.strings = &quot;&quot;, nrows = 5878 ) head(x1) #&gt; V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 V13 V14 #&gt; 1 83004 02/08/1993 0 NA NA NA NA NA NA NA NA NA NA NA #&gt; 2 83004 01/01/1995 0 NA NA NA 26.8 NA NA NA NA NA NA 1.5 #&gt; 3 83004 01/01/1995 1200 21.2 22.5 20.0 NA 19.5 80 924.6 NA 32 4 NA #&gt; 4 83004 01/01/1995 1800 NA 25.2 21.5 NA NA 73 922.9 NA 32 2 NA #&gt; 5 83004 02/01/1995 0 NA 20.7 20.3 28.9 NA 97 924.2 NA 0 0 1.3 #&gt; 6 83004 02/01/1995 1200 3.2 23.8 20.6 NA 19.9 76 924.7 NA 32 3 NA #&gt; V15 V16 V17 V18 V19 V20 #&gt; 1 NA 1.4 NA NA NA NA #&gt; 2 NA 1.6 22.04 86.75 2.000000 NA #&gt; 3 10 NA NA NA NA NA #&gt; 4 10 NA NA NA NA NA #&gt; 5 10 1.1 23.32 83.00 2.666667 NA #&gt; 6 10 NA NA NA NA NA str(x1) #&gt; &#39;data.frame&#39;: 5863 obs. of 20 variables: #&gt; $ V1 : chr &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; ... #&gt; $ V2 : chr &quot;02/08/1993&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; ... #&gt; $ V3 : int 0 0 1200 1800 0 1200 1800 0 1200 1800 ... #&gt; $ V4 : num NA NA 21.2 NA NA 3.2 NA NA 4.4 NA ... #&gt; $ V5 : num NA NA 22.5 25.2 20.7 23.8 26.4 22 23 23.4 ... #&gt; $ V6 : num NA NA 20 21.5 20.3 20.6 21.6 21.4 21.3 22.6 ... #&gt; $ V7 : num NA 26.8 NA NA 28.9 NA NA 25.4 NA NA ... #&gt; $ V8 : num NA NA 19.5 NA NA 19.9 NA NA 20.7 NA ... #&gt; $ V9 : int NA NA 80 73 97 76 66 95 86 94 ... #&gt; $ V10: num NA NA 925 923 924 ... #&gt; $ V11: num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ V12: int NA NA 32 32 0 32 32 0 0 5 ... #&gt; $ V13: num NA NA 4 2 0 3 5 0 0 3 ... #&gt; $ V14: num NA 1.5 NA NA 1.3 NA NA 0.2 NA NA ... #&gt; $ V15: num NA NA 10 10 10 10 10 10 10 10 ... #&gt; $ V16: num 1.4 1.6 NA NA 1.1 NA NA 1.3 NA NA ... #&gt; $ V17: num NA 22 NA NA 23.3 ... #&gt; $ V18: num NA 86.8 NA NA 83 ... #&gt; $ V19: num NA 2 NA NA 2.67 ... #&gt; $ V20: logi NA NA NA NA NA NA ... Outra alternativa seria converter as colunas de interesse (todas exceto as de 1 a 3) para numeric através da função as.numeric() usando a função apply ao longo das colunas: # corrigindo classe dos dados # convertendo de character para numeric x[, -c(1:3)] &lt;- apply(x[,-c(1:3)], 2, as.numeric) str(x) #&gt; &#39;data.frame&#39;: 5863 obs. of 20 variables: #&gt; $ V1 : chr &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; &quot;83004&quot; ... #&gt; $ V2 : chr &quot;02/08/1993&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; &quot;01/01/1995&quot; ... #&gt; $ V3 : int 0 0 1200 1800 0 1200 1800 0 1200 1800 ... #&gt; $ V4 : num NA NA 21.2 NA NA 3.2 NA NA 4.4 NA ... #&gt; $ V5 : num NA NA 22.5 25.2 20.7 23.8 26.4 22 23 23.4 ... #&gt; $ V6 : num NA NA 20 21.5 20.3 20.6 21.6 21.4 21.3 22.6 ... #&gt; $ V7 : num NA 26.8 NA NA 28.9 NA NA 25.4 NA NA ... #&gt; $ V8 : num NA NA 19.5 NA NA 19.9 NA NA 20.7 NA ... #&gt; $ V9 : num NA NA 80 73 97 76 66 95 86 94 ... #&gt; $ V10: num NA NA 925 923 924 ... #&gt; $ V11: num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ V12: num NA NA 32 32 0 32 32 0 0 5 ... #&gt; $ V13: num NA NA 4 2 0 3 5 0 0 3 ... #&gt; $ V14: num NA 1.5 NA NA 1.3 NA NA 0.2 NA NA ... #&gt; $ V15: num NA NA 10 10 10 10 10 10 10 10 ... #&gt; $ V16: num 1.4 1.6 NA NA 1.1 NA NA 1.3 NA NA ... #&gt; $ V17: num NA 22 NA NA 23.3 ... #&gt; $ V18: num NA 86.8 NA NA 83 ... #&gt; $ V19: num NA 2 NA NA 2.67 ... #&gt; $ V20: num NA NA NA NA NA NA NA NA NA NA ... # razão dos avisos #as.numeric(&quot;NA&quot;) Mas e o nome das variáveis? Nós ignoramos a linha de cabeçalho por que nos dados do INMET ocorre uma variável denominada VelocidadeVentoInsolacao. Essa string deveria ser separada em duas. Vamos fazer essa adequação aos dados. # lendo somente o nome das variaveis vnames &lt;- read.csv2(file=bdmep_dest_file, header = FALSE, skip = 15, stringsAsFactors = FALSE, dec = &quot;.&quot;, na.strings = &quot;&quot;, nrows = 1) # convertendo de dataframe para vetor vnames &lt;- c(t(vnames)) vnames #&gt; [1] &quot;Estacao&quot; &quot;Data&quot; #&gt; [3] &quot;Hora&quot; &quot;Precipitacao&quot; #&gt; [5] &quot;TempBulboSeco&quot; &quot;TempBulboUmido&quot; #&gt; [7] &quot;TempMaxima&quot; &quot;TempMinima&quot; #&gt; [9] &quot;UmidadeRelativa&quot; &quot;PressaoAtmEstacao&quot; #&gt; [11] &quot;PressaoAtmMar&quot; &quot;DirecaoVento&quot; #&gt; [13] &quot;VelocidadeVentoInsolacao&quot; &quot;Nebulosidade&quot; #&gt; [15] &quot;Evaporacao Piche&quot; &quot;Temp Comp Media&quot; #&gt; [17] &quot;Umidade Relativa Media&quot; &quot;Velocidade do Vento Media&quot; #&gt; [19] NA # número de variáveis é diferente do número de colunas do arquivo length(vnames) == ncol(x) #&gt; [1] FALSE # corrigindo nomes das variaveis # substitui &quot;VelocidadeVentoInsolacao&quot; por &quot;VelocidadeVento&quot; vnames[13] &lt;- &quot;VelocidadeVento&quot; # acresenta na 14a posição dos nomes a variável &quot;insolacao&quot; e # desloca os elementos orginais do vetor vnames &lt;- c(vnames[1:13], &quot;insolacao&quot;, vnames[14:length(vnames)]) length(vnames) #&gt; [1] 20 ncol(x) #&gt; [1] 20 names(x) &lt;- vnames head(x) #&gt; Estacao Data Hora Precipitacao TempBulboSeco TempBulboUmido #&gt; 1 83004 02/08/1993 0 NA NA NA #&gt; 2 83004 01/01/1995 0 NA NA NA #&gt; 3 83004 01/01/1995 1200 21.2 22.5 20.0 #&gt; 4 83004 01/01/1995 1800 NA 25.2 21.5 #&gt; 5 83004 02/01/1995 0 NA 20.7 20.3 #&gt; 6 83004 02/01/1995 1200 3.2 23.8 20.6 #&gt; TempMaxima TempMinima UmidadeRelativa PressaoAtmEstacao PressaoAtmMar #&gt; 1 NA NA NA NA NA #&gt; 2 26.8 NA NA NA NA #&gt; 3 NA 19.5 80 924.6 NA #&gt; 4 NA NA 73 922.9 NA #&gt; 5 28.9 NA 97 924.2 NA #&gt; 6 NA 19.9 76 924.7 NA #&gt; DirecaoVento VelocidadeVento insolacao Nebulosidade Evaporacao Piche #&gt; 1 NA NA NA NA 1.4 #&gt; 2 NA NA 1.5 NA 1.6 #&gt; 3 32 4 NA 10 NA #&gt; 4 32 2 NA 10 NA #&gt; 5 0 0 1.3 10 1.1 #&gt; 6 32 3 NA 10 NA #&gt; Temp Comp Media Umidade Relativa Media Velocidade do Vento Media NA #&gt; 1 NA NA NA NA #&gt; 2 22.04 86.75 2.000000 NA #&gt; 3 NA NA NA NA #&gt; 4 NA NA NA NA #&gt; 5 23.32 83.00 2.666667 NA #&gt; 6 NA NA NA NA Finalmente vamos escrever os dados do INMET corretamente organizados. bdmep_dest_file_clean &lt;- file.path(tempdir(), &quot;83004_clean.txt&quot;) write.csv2(x, file = bdmep_dest_file_clean, na = &quot;-9999&quot;, row.names = FALSE) B.4.2 Arquivos formatados com largura fixa Alguns arquivos texto com dados tabulares podem não conter separadores (para p.ex. economizar espaço de disco). Outros arquivos podem ser formatados usando largura fixa para reservar o espaço de cada variável, o que aumenta a legibilidade dos dados em editor de texto. Nesses casos a função read.fwf() é conveniente. Vamos usar como exemplo o arquivo de dados do Índice de Oscilação Sul (SOI) obtido no site do National Weather Service - Climate Prediction Center (NWS-CPC). # link para os dados do SOI noaa_url_file &lt;- &quot;http://www.cpc.ncep.noaa.gov/data/indices/soi&quot; Abrindo o link dos dados no navegador para visualização dos dados. browseURL(url = noaa_url_file) Leitura dos dados: #soi &lt;- read.fwf(file = link, # nome do arquivo ou link soi &lt;- read.fwf(file = noaa_url_file, # sem internet, usar esse arquivo skip = 4, # pula 4 linhas header = FALSE, # sem cabeçalho nrows = 70, # num. de linhas widths = c(4, rep(6,12)), # largura dos campos das variáveis na.strings = &quot;-999.9&quot;, # string para dados faltantes col.names = scan(noaa_url_file, # varredura do arquivo #col.names = scan(link, # varredura do arquivo what = &quot;character&quot;, # tipo dos dados a serem lidos skip = 3, # pula 3 linhas nmax = 13) # num. max de registros a serem lidos ) head(soi) #&gt; YEAR JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC #&gt; 1 1951 2.5 1.5 -0.2 -0.5 -1.1 0.3 -1.7 -0.4 -1.8 -1.6 -1.3 -1.2 #&gt; 2 1952 -1.5 -1.0 0.9 -0.4 1.2 1.2 0.8 0.1 -0.4 0.6 0.0 -2.0 #&gt; 3 1953 0.5 -0.8 -0.3 0.3 -2.8 0.2 0.0 -2.0 -2.1 0.1 -0.5 -0.8 #&gt; 4 1954 1.1 -0.5 0.4 1.1 0.8 0.2 0.7 1.8 0.3 0.4 0.2 2.3 #&gt; 5 1955 -0.9 3.1 1.1 -0.2 1.7 2.2 2.6 2.4 2.2 2.5 2.0 1.6 #&gt; 6 1956 2.2 2.7 2.2 1.5 2.3 1.8 1.8 2.0 0.1 2.9 0.2 1.8 Vamos alterar a estrutura dos dados: ao invés dos dados serem distribuídos ao longo das colunas, vamos estruturá-los como série temporal, ou seja cada valor mensal corresponderá a uma linha. # converte a matriz de dados para um vetor (em sequencia cronológica) soi_v &lt;- c(t(soi[, -1])) # criando um dataframe com valores de SOI, mes e ano soi_df &lt;- data.frame(ano = rep(soi$YEAR, each = 12), mes = rep(1:12, length(soi[,1])), soi = soi_v) # escrevendo dados SOI em um arquivo CSV soi_csv_file &lt;- file.path(tempdir(), &quot;SOI.csv&quot;) write.csv(x = soi_df, file = soi_csv_file, na = &quot;-999.9&quot;, row.names = FALSE) Vamos ler os dados reestruturados que foram salvos no formato csv usando uma função que permite a escolha do arquivo de forma iterativa. # leitura de dados com escolha interativa do arquivo soi.df &lt;- read.csv(file = file.choose(), # file.choose só é válido em sistema *unix # no windows é choose.file() header = TRUE, na.strings = &quot;-999.9&quot;) Navegue até o diretório do arquivo SOI.csv e clique duas vezes sobre ele. soi.df &lt;- read.csv(file = soi_csv_file, header = TRUE, na.strings = &quot;-999.9&quot;) head(soi.df) #&gt; ano mes soi #&gt; 1 1951 1 2.5 #&gt; 2 1951 2 1.5 #&gt; 3 1951 3 -0.2 #&gt; 4 1951 4 -0.5 #&gt; 5 1951 5 -1.1 #&gt; 6 1951 6 0.3 str(soi.df) #&gt; &#39;data.frame&#39;: 840 obs. of 3 variables: #&gt; $ ano: int 1951 1951 1951 1951 1951 1951 1951 1951 1951 1951 ... #&gt; $ mes: int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ soi: num 2.5 1.5 -0.2 -0.5 -1.1 0.3 -1.7 -0.4 -1.8 -1.6 ... A função read.fortran() é uma função similar à read.fwf() e permite usar especificações de colunas no estilo Fortran. B.4.3 Arquivos texto não estruturados Em alguns casos é necessário ler arquivos textos sem uma estrutura definida como no caso de arquivos delimitados. Se o arquivo não é bem estruturado é mais fácil ler cada linha de texto separadamente e depois decompor e manipular o conteúdo do texto. A função readLines() é adequada para isso. Cada linha é tratada como um elemento de um vetor do tipo character. Vamos importar os dados do INMET, mas dessa vez vamos focar no cabeçalho, onde estão as informações da estação meteorológica. # leitura do cabecalho do arquivo de dados de uma estação do inmet cab &lt;- readLines(bdmep_dest_file) head(cab) #&gt; [1] &quot;--------------------&quot; #&gt; [2] &quot;BDMEP - INMET&quot; #&gt; [3] &quot;--------------------&quot; #&gt; [4] &quot;Estação : SAO PAULO IAG - SP (OMM: 83004)&quot; #&gt; [5] &quot;Latitude (graus) : -23.65&quot; #&gt; [6] &quot;Longitude (graus) : -46.61&quot; # somente linhas com coordenadas da estação cab[5:7] #&gt; [1] &quot;Latitude (graus) : -23.65&quot; &quot;Longitude (graus) : -46.61&quot; #&gt; [3] &quot;Altitude (metros): 800.00&quot; is.vector(cab[5:7]) #&gt; [1] TRUE # arranjando em coluna cbind(cab[5:7]) #&gt; [,1] #&gt; [1,] &quot;Latitude (graus) : -23.65&quot; #&gt; [2,] &quot;Longitude (graus) : -46.61&quot; #&gt; [3,] &quot;Altitude (metros): 800.00&quot; # selecionando somente os dados e o nome das variáveis cab[-c(1:15)][1:10] #&gt; [1] &quot;Estacao;Data;Hora;Precipitacao;TempBulboSeco;TempBulboUmido;TempMaxima;TempMinima;UmidadeRelativa;PressaoAtmEstacao;PressaoAtmMar;DirecaoVento;VelocidadeVentoInsolacao;Nebulosidade;Evaporacao Piche;Temp Comp Media;Umidade Relativa Media;Velocidade do Vento Media;&quot; #&gt; [2] &quot;83004;02/08/1993;0000;;;;;;;;;;;;;1.4;;;;&quot; #&gt; [3] &quot;83004;01/01/1995;0000;;;;26.8;;;;;;;1.5;;1.6;22.04;86.75;2;&quot; #&gt; [4] &quot;83004;01/01/1995;1200;21.2;22.5;20;;19.5;80;924.6;;32;4;;10;;;;;&quot; #&gt; [5] &quot;83004;01/01/1995;1800;;25.2;21.5;;;73;922.9;;32;2;;10;;;;;&quot; #&gt; [6] &quot;83004;02/01/1995;0000;;20.7;20.3;28.9;;97;924.2;;0;0;1.3;10;1.1;23.32;83;2.666667;&quot; #&gt; [7] &quot;83004;02/01/1995;1200;3.2;23.8;20.6;;19.9;76;924.7;;32;3;;10;;;;;&quot; #&gt; [8] &quot;83004;02/01/1995;1800;;26.4;21.6;;;66;921.5;;32;5;;10;;;;;&quot; #&gt; [9] &quot;83004;03/01/1995;0000;;22;21.4;25.4;;95;922.7;;0;0;0.2;10;1.3;22.54;93.5;1;&quot; #&gt; [10] &quot;83004;03/01/1995;1200;4.4;23;21.3;;20.7;86;923.6;;0;0;;10;;;;;&quot; # escrevendo dados com writeLines bdmep_dest_file_limpo &lt;- file.path(tempdir(), &quot;83004_limpo.txt&quot;) writeLines(text = cab[-c(1:15)] , con = bdmep_dest_file_limpo) A função writeLines() escreve os elementos do vetor de caracteres um de cada vez em um arquivo texto. Vamos abrir o arquivo gerado sem cabeçalho com: file.show(bdmep_dest_file_limpo) "]
]
