# Manipulação de Vetores {#manip-vectors}

```{r setup, include = FALSE}
rm(list = ls())
pcks <- c("knitr", "pander", "htmlTable")
easypackages::libraries(pcks)
opts_chunk$set(
  prompt = FALSE,
  cache = FALSE,
  fig.path = "images/",
  comment = "#>",
  collapse = TRUE
)
source("R/utils.R")
```


Neste capítulo veremos como manipular vetores, incluindo:

- como nomear vetores

- realizar cálculos entre vetores

- gerar sequências

- entender a indexação de vetores

- lidar com dados faltantes, nulos e duplicados

- usar as funções para cálculos móveis


Em algumas seções deste capítulos usaremos funções dos pacotes do grupo [tidyverse](https://www.tidyverse.org/), como o [ggplot2](https://ggplot2.tidyverse.org/) e [dplyr](https://dplyr.tidyverse.org/). Para carregá-los basta digitar:

```{r, message=FALSE, warning=FALSE, error=FALSE}
library(tidyverse)
```


## Propriedades

+ `typeof()` para descobrir o tipo de dado

+ `length()` para descobrir o tamanho de um tipo de dado 

+ `attributes` (informações acionais específicas do dado), entre eles o atributo mais comum está o `names()`.


### Nomeando vetores


As 3 formas equivalentes mais comuns de criar vetores com nomes são demostradas abaixo com um exemplo de dados mensais de precipitação.

+ Durante a criação, com a função `c()` incluindo os nomes nos argumentos

```{r nv1, message=FALSE}
# vetor de chuva mensal para um dado ano
prec <- c(
  jan = 300, 
  fev = 150,
  mar = 210,
  abr = 12, 
  mai = 0, 
  jun = 0, 
  jul = 12, 
  ago = 22, 
  set = 100, 
  out = 120, 
  nov = 10,  
  dez = 280
  )
```

+ Modificando um vetor com a função `names()<-`

```{r nv2}
prec <- c(300, 200, 210, 12, 0, 0, 12, 22, 100, 120, 10, 280)
meses <- c("jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez")
names(prec) <- meses
prec
```


+ Criando um vetor modificado

```{r nv3}
prec <- setNames(
  object = c(300, 200, 210, 12, 0, 0, 12, 22, 100, 120, 10, 280),
  nm = c("jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez")
)
prec
```

Nomes não podem ser repetidos entre os elementos, porque a seleção de um subconjunto do vetor baseada nos nomes retornará somente o primeiro elemento que tiver nome repetido.

Embora não faça muito sentido, nem todos elementos precisam ter nomes. A saída da função `names()` retornará um vetor caractere vazio (\"\") para aqueles elementos sem nomes especificados. 

```{r chunk75}
(meses <- c(jan = 1, fev = 2, 3:12))
names(meses)
```

Quando nenhum nome é especificado, `names()` retornará `NULL`[^mais-sobre-null].

```{r}
names(1:12)
```

[^mais-sobre-null]: Nós conheceremos mais detalhes sobre o `NULL` na sessão \@ref(dados-nulos).

Para remover os nomes de um vetor, podemos usar a função `unname()` ou `names() <- NULL`.

```{r chunk76, message=FALSE}
prec_clim <- c(230, 205, 160, 100, 60, 30, 40, 60, 110, 165, 200, 220)
names(prec_clim) <- names(prec)
prec_clim
unname(prec_clim)
names(prec_clim) <- NULL
prec_clim
```


Nas próximas seções frequentemente usaremos  os vetores `prec` e `prec_clim`. É importante então contextualizar essas variáveis. A variável `prec` consiste na precipitação mensal observada em um ano qualquer em um dado local. A variável `prec_clim` refere-se aos valores esperados de precipitação mensal[^normais] (médias de pelo menos 30 anos) do mesmo local.

[^normais]: Também conhecidos como **normais climatológicas** de precipitação de um local. 


## Atributos

Nós podemos adicionar atributos a um vetor, como por exemplo alguma informação sobre os valores daquela variável. A variável `prec` possui um atributo (`names`). A função `attributes()` lista qualquer atributo de uma variável. Vamos criar uma variável para mostrar como podemos adicionar um atributo a um vetor.

```{r}
temp <- c(27, 23, 21, 18, 19, 28)
attributes(temp)
```

Podemos adicionar um atributo chamado `metadados` à `temp` e fornecer um vetor caractere com a função de atribuição de atributo `attr()<-`
```{r}
attr(temp, "metadados") <- "dados obtidos em www.inmet.gov.br, acesso em 10/10/2010"
temp
```

Algumas funções carregarão este atributo adiante, mas outras não, conforme exemplo a seguir.

```{r}
(temp_inc <- temp + 1)
(temp_inc <- c(temp_inc, 18))
```

Há situações de uso válido deste recurso, mas inicialmente é melhor não confiar nele. 

## Operações com vetores {#oper-vect}

Como o `R` é uma linguagem vetorizada, as operações são aplicadas a cada elemento do vetor automaticamente, sem a necessidade de laços (ou *loopings*) ao longo do vetor. Esta é uma das grandes vantagens do  `r rblue`.

Operações aritméticas podem ser aplicadas diretamente entre vetores.

```{r chunk78, message=FALSE}
# desvios da prec em relação a média climatológica
prec - prec_clim
# anomalia em % relativa
prec/prec_clim * 100
# transformação boxcox da prec com alpha = 0.335
((prec^0.335 - 1)/0.335)
# cte^intervalo
mean(prec)^(1/2:5)
```


Uma peculiaridade do `r rblue` é o tratamento de operações com vetores de tamanhos diferentes. O vetor menor é reciclado, de forma que seus elementos sejam repetidos em ordem até atingirem o tamanho do vetor mais longo envolvido na operação. 

```{r chunk711, message=FALSE}
# velocidades em m s-1
(vel_ms <- c(1.5, 0.3, 1.4, 2.0))
# fator de conversão para km h-1
fator_conv <- 3.6
vel_ms * fator_conv
# equivalência
fator_conv <- c(3.6, 3.6, 3.6, 3.6)
vel_ms * fator_conv
```

A constante `fator_conv = 3.6` nesse caso é reciclada 4 vezes (tamanho do vetor `vel_ms`) e então multiplicada por cada elemento de `vetor_dbl`. Por isso os resultados no código acima são idênticos. Essa funcionalidade de fazer um vetor do mesmo tamanho de outro é conhecida como **reciclagem**. Se o vetor mais longo não tem tamanho múltiplo do mais curto, o `r rblue` realiza a operação com uma mensagem de aviso.

```{r}
1:10 * 1:2
1:10 * 1:3
```


A reciclagem é um recurso útil, mas também perigoso. Seu código pode ficar mais elegante ou gerar resultados inesperados.


Operações aritméticas podem ser feitas com vetores lógicos, como nos exemplos abaixo:

```{r}
FALSE - TRUE
prec_clim >= 100
(prec_clim >= 100) * 1:12
```

### Comparações

Vetores lógicos resultam da comparação de números ou caracteres. A Tabela \@ref(tab:oper-logic) apresenta os principais operadores lógicos para comparações.

```{r oper-logic, echo = FALSE, warning=FALSE}
# <a name="tab-oper-logic"></a>
oper <- c("<", "<=", ">", ">=", "==", "!=", "!x", "x | y", "x & y", "isTRUE(x)", "%in%")
desc <- c("menor que", " menor ou igual a", "maior que", "maior ou igual", "idêntico", "diferente", "não é x (negação)", "x ou y", "x e y", "teste se x é verdadeiro", "está contido em")
oper_logic <- data.frame(
  Operador = oper,
  Descrição = desc,
  stringsAsFactors = FALSE
)
kable(oper_logic, caption = "Operadores Lógicos", align = "c")
```

Este conjunto de operadores permite diversas comparações entre vetores, por exemplo: 

- quais meses de `prec` foram abaixo do normal?

```{r}
prec
prec_clim
prec - prec_clim < 0
```

O operador `%in%` serve para verificar se um vetor está contido parcial ou totalmente em outro vetor.

```{r }
# operador está contido em
c(200, 150, 100) %in% prec
# 2:4 são elementos de x?
is.element(c(200, 150, 100), prec)
```


Nos exemplos acima, vimos como buscar os os elementos de um vetor para apenas uma condição. Entretanto, frequentemente precisamos testar mais condições, ou seja, combinar comparações. Por exemplo, para condições do tipo:

- $0 < prec \leq 100$ 
- $prec < 50$  ou $prec \geq 150$ 

precisamos usar os operadores relacionais:

- `&` e `&&` (\"e"\)

- `|` e `||` (\"ou"\)


```{r}
# prec entre 0 e 100 mm
prec > 0 & prec <= 100
# prec abaixo de 50 e acima de 150 mm
prec < 50 | prec >= 150
```


A ordem das operações pode ser controlada por parênteses. Os operadores `&` e `|` são vetorizados (retornam vetores de mesmo tamanho que os vetores testados). 


A forma dupla (`&&` ou `||`) compara somente um elemento de cada lado, enquanto a forma normal (`&` e `|`), compara cada elemento dos vetores em cada lado.

```{r chunk7290, message=FALSE}
a <- c(1, 1, 0, 1)
b <- c(2, 1, 0, 1)
# forma normal verifica cada elemento de a e cada elemento de b
a == 1 & b == 1
# forma dupla verifica somente o primeiro elemento de a e o primeiro elemento de b
# retornando somente um resultado
a == 1 && b == 1
```

```{r chunk72901, message=FALSE  , echo=FALSE, out.width=200}
oper <- c("a", "b", "a==1", "b==1", "a == 1 & b == 1", "a == 1 && b == 1")
desc <- data.frame(
  a,
  b,
  a == 1,
  b == 1,
  a == 1 & b == 1,
  a == 1 && b == 1
)
names(desc) <- oper
desc[2:nrow(desc), 6] <- ""
pander(desc, caption = "Demonstração da diferença entre & e &&.")
```

Podem haver mais que duas condições a serem testadas. As condições podem ser combinadas usando múltiplos `&` ou `|`. As diferentes condições podem ser agrupadas por parênteses assim como feito nas operações matemáticas. 


#### Testes de igualdade 

A comparação de igualdade no `r rblue` pode ser meio confusa devido as forma de armazenamento diferentes dos números.

```{r}
0.6 - 0.3
0.9 - 0.6
0.3 == 0.3
```

Tudo normal, mas ao comparar operações com valores decimais, você pode se surpreender:

```{r}
(0.6 - 0.3) == (0.9 - 0.6)
```

Isso ocorre por imprecisão no final da parte decimal que pode ser arrendondada incorretamente. Isso não acarreta problema na maioria dos cálculos. Para evitar esse problema é melhor comparar os resultados usando a função `all.equal()`.

```{r}
all.equal(
  target = 0.6 - 0.3,
  current = 0.9 - 0.6
)
```

A `all.equal()` inclui uma tolerância na comparação ($1,5\times10^{-8}$) fazendo com aquela imprecisão seja ignorada. Para mais detalhes consulte `?all.equal`.


### Funções `any` e `all`

Estas funções fornecem um único valor (vetor lógico de tamanho 1) para resumir ou descrever o resultado da condição aplicada ao vetor.

```{r chunk715, message=FALSE  }
vetor <- c(0, 1, -1, -2, 3, 5, -5)
all(vetor < 0) # todas as posições são maiores que 0 ?
any(vetor > 0) # alguma posição é maior que 0?
```

- `all()` verifica se a condição avaliada é válida para todos elementos de um vetor;

- `any()` verifica se a condição avaliada é válida para pelo menos um dos elementos de um vetor;



## Sequências 

Vimos nas seções anteriores que é muito simples criar sequências de números inteiros com o operador `:`.  Nesta seção veremos outras formas de gerar sequências, como uma sequência de números reais e sequências de números repetidos. 


### Sequências de números inteiros

Os dois pontos (`:`) são uma maneira muito fácil de gerar uma sequência de números igualmente espaçados por 1. Você especifica um número inicial e um número final e o `R` produzirá todos os números inteiros entre eles, incluindo os dois números. Isso funciona mesmo para números negativos ou para valores decrescentes.


```{r chunk716, message=FALSE}
(ddm <- 1:31)
typeof(ddm)
# sequencia de inteiros decrescente
(si_dec <- 10:-10)
typeof(si_dec)
```

### Sequências de números reais

A função `seq()`pode ser usada para gerar sequências tanto de números reais como inteiros.

No código abaixo são geradas uma sequência crescente e uma decrescente, ambas igualmente espaçadas por 3.

```{r seq1}
seq(from = 1, to = 10, by = 3)
seq(from = 10, to = 1, by = -3)
```

Para sequências decrescentes o argumento `by` (\"por\") deve ser negativo.

A saída da `seq()` vai sempre incluir o n° inicial (passado no argumento `from` - \"de\"), mas nem sempre incluirá o n° final (passado no argumento `to` - \"até\"). Se sua sequência está aumentando por um argumento `by` que é par (ímpar) e o argumento `to` também é par (ímpar), não incluirá o valor do argumento `to` no resultado (Tabela \@ref(tab:seqs-by)). Quando `to` e `by` diferem o valor de `to` fará parte da sequência de saída.


```{r seqs-by, eval = TRUE, echo = FALSE}
tbl_seqs_by <- tibble::tibble(
  `'from'` = 1,
  `'to'` = c(10, 10, 11, 11),
  `'to' é par?` = `'to'` %% 2 == 0,
  `'by'` = rep(c(2, 3), times = 2),
  `'by' é par?` = `'by'` %% 2 == 0,
  `sequência` = mapply(base::seq,
    from = `'from'`,
    to = `'to'`,
    by = rep(c(2, 3), times = 2)
  ),
  `resultado inclui 'to'` = lapply(
    base::seq_along(`'to'`),
    function(i) {
      `'to'`[i] %in% `sequência`[[i]]
    }
  )
)
knitr::kable(tbl_seqs_by,
  caption = "Sequências com argumentos ímpares e pares.",
  align = "c"
)

```

Ao invés de usar o argumento `by`, podemos especificar um valor para o argumento `length.out` (\"tamanho de saída\") para produzir um vetor com tantos números, igualmente espaçados, entre os valores `from` e `to`.


```{r chunk718, message=FALSE  }
seq(from = 1, to = 10, length.out = 20)
```

O `length.out = 20` no código acima permite gerar 20 números igualmente espaçados entre 1 e 10.



### Repetições

Algumas vezes precisamos repetir certos valores, o que pode ser feito com a função `rep()`. O argumento `times` especifica o número de vezes para repetir o `x`. 

```{r}
rep(x = 1:2, times = 4)
```

O argumento `each` especifica o número de vezes para repetir cada elemento de `x`.

```{r}
rep(x = 1:2, each = 3)
```

Os argumentos podem ser combinados.

```{r}
rep(x = 1:2, times = 4, each = 3)
```

No caso acima, `x` primeiro foi repetido 4 vezes e depois cada elemento foi repetido 3 vezes.

Quando argumento `times` é um vetor de mesmo tamanho que `x`, cada um de seus valores será usado para repetir tantas vezes o respectivo elemento de `x`.

```{r}
rep(x = 1:2, times = 4:3)
```

<!-- 
AULA-6 encerrou aqui 
-->

## Indexação de vetores {#index-vetores}

Os elementos de um vetor são indexados e para acessá-los usamos a notação de índices do `r rblue`. Para extrair ou filtrar elementos de um vetor usamos o operador colchetes **`[ ]`**, seguindo a sintaxe: 

<p style="color:DodgerBlue; font-size:1.3em; font-weight: bold;text-align:center;"> `vetor[indices]` </p>

onde **`indices`** representa o vetor com os índices dos elementos da variável `vetor` a serem selecionados. O operador **`[`** quando aplicado a um vetor retornará sempre um vetor.

Para acessar partes um elemento de um vetor o vetor `indices` dentro dos colchetes pode ser especificado de diferentes formas:

- por posições (vetor numérico)

- por nomes (vetor de caracteres)

- por comparações, testes ou condições (vetor lógico)


### Indexação por vetores numéricos

#### Positivos

Para extrairmos a precipitação de janeiro e dezembro do vetor `prec` podemos usar o seguinte código:

```{r chunk721, message=FALSE }
# vetor com as posições dos meses de janeiro e dezembro
c(1, length(prec))
# acesso aos valores localizados nas posições 1 e 12 
prec[c(1, length(prec))]
```

Passando um vetor numérico entre os colchetes retorna a parte do vetor contendo os elementos daquelas posições.

Similarmente a precipitação dos meses de inverno (Junho, Julho e Agosto) podem ser selecionadas usando um vetor definido com os índices das posições daqueles meses:

```{r chunk723, message=FALSE }
inds_jja <- 6:8
# vetor de chuva JJA
prec[inds_jja]
```

```{block, reposicionamento, type='rmdtip'}
O reposicionamento dos elementos de um vetor pode ser feito pela especificação da ordem dos índices. Par ordenar os elementos na ordem dezembro, Janeiro e Fevereiro indexamos da seguinte maneira:

`prec[c(12, 1, 2)]`

A inversão da ordem dos elementos pode ser feita com a indexação:

`prec[length(prec):1]`

A função `rev()` economiza tempo de digitação de código para realizar esta mesma ação:

`rev(prec)`

```

#### Negativos

O acesso aos dados de precipitação de janeiro e dezembro do vetor `prec` poderia ser feita uma lógica complementar. Poderíamos selecionar todos elementos de `prec` exceto aqueles entre Fevereiro (posição 2) e Novembro (posição 11). Esta frase poderia ser transcrita em código `R`, simplesmente como `-(2:11)`. O sinal `-` precedendo o vetor numérico, exclui o acesso aquelas posições quando usado entre o operador **`[`**.

```{r chunk724, message=FALSE }
prec[-(2:11)]
```

Analogamente, os meses de inverno poderiam ser selecionados com:

```{r}
 prec[-c(1:5, 9:12)]
```





###  Indexação por nomes

A seleção de partes e um vetor pode ser feita também usando os nomes de seus elementos. As precipitações de janeiro e dezembro poderiam ser extraídas usando os nomes daqueles elementos:

```{r}
prec[c("jan", "dez")]
```

Assim como as precipitações de inverno.

```{r}
prec[c("jun", "jul", "ago")]
```


### Indexação por vetores lógicos

Vamos criar um vetor lógico e usá-lo para a seleção com um vetor lógico dos elementos de `prec` para Janeiro e Dezembro. 

```{r chunk725, message=FALSE}
inds_log <- c(
  TRUE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, TRUE
)
prec[inds_log]
```        

Somente os elementos de `inds_log` correspondentes a `TRUE` foram selecionados. 

Vetores lógicos são muito úteis quando aproveitamos a funcionalidade de **coerção**. Imagine que você queira extrair de `prec` o primeiro elemento, mas o segundo não, o terceiro elemento sim, o quarto não e assim sucessivamente. Essa seleção intercalada pode ser simplesmente feita com:

```{r chunk727, message=FALSE  }
inds_log <- c(TRUE, FALSE)
prec[inds_log]
``` 

Uma forma mais prática de filtrar vetores é por comparações. Por exemplo, quais valores de precipitação foram acima de 80 mm?

```{r chunk728, message=FALSE}
inds_prec_alta <- prec > 80
prec[inds_prec_alta]
``` 



Vimos que a filtragem consiste em extrair elementos de um vetor que satisfaça uma ou várias condições. Entretanto, em alguns casos, o interesse está nas posições do vetor que atendem a condição (onde ela é verdadeira). Nós podemos localizar essas ocorrências usando a função `which()`. Por exemplo, qual a posição dos elementos do vetor `inds_prec_alta` que são verdadeiros?

```{r}
which(inds_prec_alta)
``` 

A função `which()` converte um vetor lógico em numérico, somente os índices em que a condição é `TRUE`.

A utilidade da `which()` é mais evidente quando usada para, por  exemplo, sabermos qual o mês do 4° caso mais chuvoso.

```{r}
which(inds_prec_alta)[4]
names(which(inds_prec_alta)[4])
# ou
names(prec)[which(inds_prec_alta)[4]]
```

```{block, which-more, type='rmdtip'}
A resultado da `which()` é um vetor numérico e portanto equivale a indexação numérica. Então a seleções abaixo são equivalentes:


`prec[which(inds_prec_alta)]`

`prec[inds_prec_alta]`


Quando é melhor usar uma ou outra opção?
Note que o resultado de `which(inds_prec_alta)` armazena somente os índices que satisfazem a condição, enquanto que o resultado de `inds_prec_alta` é um vetor lógico de mesmo tamanho que `prec`. Então, se estiver trabalhando com **big data** (p.ex.: um vetor com milhões de elementos) em termos de eficiência de uso da memória a `which()` é melhor opção.
```



```{block, which-max-min, type='rmdimportant'}
Para localizar valores extremos em um vetor podemos usar as funções `which.max()` e `which.min()` que fornecem respectivamente, a posição do valor máximo e mínimo no vetor.
Elas são versões eficientes dos códigos `which(x == max(x))` e `which(x == min(x))`. Contudo, há uma diferença entre elas que pode ser verificada pela comparação dos resultados das instruções:

`which.min(prec)`

`which(prec == min(prec))`

A primeira seleciona o primeiro índice para o qual `prec` tem seu mínimo (5° elemento), enquanto a segunda retorna todos os índices correspondentes ao mínimo (5° e 6° elemento).
```


## Substituição de elementos de um vetor {#replace-vect}

Podemos substituir os valores de um vetor usando os mesmos esquemas de indexação vistos na seção anterior. A sintaxe geral para substituir elementos de um vetor por novos valores é:

<p style="color:DodgerBlue; font-size:1.3em; font-weight: bold;text-align:center;"> `vetor[indices] <- novos_valores` </p>

Vamos fazer uma cópia do vetor `prec` para então alterá-lo, fazendo substituição de seus elementos usando as diferentes formas de indexação.

```{r}
(prec_alt <- prec)
```

#### Por posições

suponha que você precisa substituir os valores de precipitação dos meses de inverno por valores corrigidos.

```{r chunk732, message=FALSE}
inds_jja
prec_alt[inds_jja] <- c(NA, 21, 42)
prec
prec_alt
```


  
#### Por nomes

Suponha que os valores de precipitação de janeiro e dezembro foram atualizados para 250 e 208, respectivamente. Esta alteração pode ser com o código abaixo.

```{r chunk733, message=FALSE}
prec_jd_corr <- c(250, 208)
prec_alt[c("jan", "dez")] <- prec_jd_corr
prec
prec_alt
```


#### Por comparação

Imagine que você precisa substituir os valores de `prec` que ficaram em torno de $\pm10 \%$  da média mensal climatológica pelos valores climatológicos.

Vamos primeiro determinar os desvios relativos (em %) em relação as médias climatológicas:

```{r}
# limiar em % da normal climatológica
limiar <- 10 
desvios <- prec - prec_clim
# anomalias relativas em %
(anom_perc <-  abs(desvios)/prec_clim * 100)
```

Então substituímos os casos com baixo desvio pela precipitação climatológica.

```{r}
# meses com prec em torno de +-10% da média climatol.
prec[anom_perc <= 10]
# substituição pela prec mensal climatol. 
prec[anom_perc <= 10] <- prec_clim[anom_perc <= 10]
prec
```

A função `abs()` determina o valor absoluto ou módulo de um vetor.

Uma alternativa bastante útil para substituir valores de um vetor usando comparações é a **função vetorizada** **`ifelse()`**. A mesma operação realizada no trecho de código anterior poderia ser feita com `ifelse()` da seguinte forma:

```{r, eval = FALSE}
prec <- ifelse(ano_perc <= 10, prec_clim, prec)
```
```{r}
prec
```


<!---
Uma exemplo é sua aplicação para preencher as falhas no vetor `prec_alt` por seus valores climatológicos.

```{r}
prec_alt_comp <- ifelse(
  test = is.na(prec_alt), # condição: é faltante?
  yes = prec_clim,        # se verdadeira: preenche com prec_clim 
  no = prec_alt           # se falsa: mantém prec_alt
)
prec_alt_comp
```
--->


## Lidando com dados faltantes

Dados faltantes (`NA`s) são inevitáveis e em qualquer processamento de dados reais nós precisamos determinar se existem dados faltantes e a quantidade de observações válidas. É importante também, saber o efeito que eles tem nos cálculos, as funcionalidades para identificá-los e substituí-los se necessários.

Vamos substituir alguns valores da `prec_alt` por `NA` para poder tratar de dados faltantes usando as diferentes funcionalidades que o `r rblue` oferece para isso. 

```{r}
prec_alt[c(3, 4, 11)] <- NA
prec_alt
```

### Identificação e remoção de `NA`s

Para identificar `NA`s em um vetor, a função específica para isso é a `is.na()`. 

```{r}
is.na(prec_alt)
``` 

Também podemos usá-la aninhada com a função `which()` para obter os índices dos elementos faltantes.

```{r}
which(is.na(prec_alt))
```

Novos usuários do R tentam identificar dados faltantes com a expressão: 

```{r}
prec_alt == NA
```

O que produzirá somente `NA`s mesmo que o vetor testado possua algum `NA`. Isso ocorre pela regra de qualquer operação com `NA`s resulta em `NA`s.

Para verificar se há algum dado faltante em um vetor usamos a função `anyNA()` e para quantificar o total de observações faltantes combinamos as expressões `sum()` e `is.na()`:

```{r}
anyNA(prec_alt)
sum(is.na(prec_alt))
```

A remoção dos elementos faltantes de um vetor é moleza. É só combinar o operador negação `!` e `is.na()` por indexação lógica:

```{r}
prec_alt[!is.na(prec_alt)]
# outra forma equivalente
#prec_alt[-which(is.na(prec_alt))]
```

Uma alternativa mais sofisticada é a função `na.omit()`. Ela não só remove os valores faltantes, mas como também guarda a localização dos dados faltantes. Esta informação é armazenada na lista de atributos do vetor.

```{r}
prec_alt_sem_falt <- na.omit(prec_alt)
attributes(prec_alt_sem_falt)
```

As posições originais dos dados faltantes descartados podem ser obtidas com:

```{r}
attr(
  x = prec_alt_sem_falt,
  which = "na.action"
)
```

Quando trabalhamos com vetores grandes que contenham várias falhas é útil saber a posição da sequência de dados consecutivos válidos mais longa. A função `na.contiguous()` retornará somente elementos daquela sequência.

```{r}
prec_alt_val_long <- na.contiguous(prec_alt)
prec_alt_val_long
```

### Indexação com `NA`s

Suponha que queremos extrair um conjunto de elementos de `prec_clim` baseado em `inds_na`.

```{r}
prec_alt > 220
```

O interesse é extrair os valores de `prec_clim` quando a `prec_alt` superou 220 mm. A expressão para essa seleção é: 

```{r}
prec_clim[prec_alt > 220]
```

o resultado da filtragem foi um vetor com o resultado da condição de prec_clim  para qual `prec_alt > 220` e também `NA`s. Isto é um resultado que provavelmente ninguém deseja. 

Se nós queremos extrair os valores de `prec_clim` para os quais `prec_alt` **não é faltante** e **também superior a 220** nós devemos usar a seguinte expressão:

```{r}
prec_clim[!is.na(prec_alt) & prec_alt > 220]
```

A moral da história aqui é que na prática quando você tem `NA`s em índices (ou seja, nos valores de qualquer vetor dentro do colchetes) o `r rblue` pode retornar algo diferente do que era esperado.


Uma função para filtragem de dados que é capaz de dar conta disso mais prontamente é função `subset()` (que pode ser traduzida como *subconjunto*) que recebe os dados no primeiro argumento (`x`) e a expressão lógica no segundo (argumento `subset` de mesmo nome da função).

```{r}
subset(
  x = prec_clim,
  subset = prec_alt > 220
)
```


### Efeito de `NAs` em funções

Na seção \@ref(NAs) vimos que qualquer operação com `NA` resulta em `NA`. Algumas funções úteis merecem ser enfatizadas quando usadas em vetores com dados faltantes.

A função `range()` retorna a amplitude de variação dos valores em um vetor.

```{r}
range(prec_alt)
```

Como `prec_alt` possui dados faltantes ela retornará `NA`. Assim como várias outras funções matemáticas básicas no `r rblue` a função `range()` permite especificar o argumento `na.rm = TRUE` para calcular o resultado após omitir os valores faltantes.

```{r}
range(prec_alt, na.rm = TRUE)
```

Logo, `prec_alt` varia de um mínimo `r min(prec_alt, na.rm = TRUE)` a um máximo de `r max(prec_alt, na.rm = TRUE)`. 


Diversas funções tem essa funcionalidade, entre elas as mais usadas para estatísticas descritivas, como:

```{r}
# prec máx. mensal
max(prec_alt, na.rm = TRUE)
# pŕec min mensal
min(prec_alt, na.rm = TRUE)
# prec total anual
sum(prec_alt, na.rm = TRUE)
# prec média
mean(prec_alt, na.rm = TRUE)
# mediana da prec 
median(prec_alt, na.rm = TRUE)
# desvio padrão
sd(prec_alt, na.rm = TRUE)
# variância
var(prec_alt, na.rm = TRUE)
```

A função `summary()` fornece um resumo estatístico de uma variável, incluindo: mínimo, 1° quartil, mediana, média, 3° quartil, máximo e o número de casos faltantes (se aplicável). 

```{r}
summary(prec_alt)
```

## Dados Nulos (`NULL`) {#dados-nulos}

O `NULL` é um tipo especial de dado no `r rblue`. Ele é um vetor de tamanho zero.


```{r}
vetor_nulo1 <- NULL
vetor_nulo1
length(vetor_nulo1)
```

Um vetor nulo também pode ser definido com:

```{r}
vetor_nulo2 <- c()
vetor_nulo2
```

Note que um vetor ser nulo não significa que ele não exista. Ou seja, a atribuição de `NULL` a uma variável não apaga a variável de seu ambiente de trabalho. A existência de uma variável pode ser verificada com a função `exists()`, na qual o argumento `x` deve ser passado como caractere. 

```{r}
exists(x = "vetor_nulo1")
```

Como o `NULL` é um vetor vazio, seu uso explícito dentro de um vetor não conta. Assim, qualquer operação com `NULL` resulta em um vetor vazio.

```{r}
(vetor_elem_nulo <- c(1, 2, NULL, 4))
length(vetor_elem_nulo)
vetor_elem_nulo + NULL
```

Em algumas situações você pode querer anular um atributo de um vetor, como os nomes. Eventualmente até mesmo o próprio vetor.

```{r}
prec
names(prec) <- NULL
prec
prec <- NULL
prec
```


## Dados duplicados
 
Dados frequentemente pode ter valores duplicados ou repetidos e dependendo da aplicação isso pode causar problemas nos resultados. Portanto é importante detectar e remover essas ocorrências. O `r rblue` oferece algumas funções convenientes para detectar dados duplicados. 

Mas antes, vamos criar um vetor de datas com alguns dias repetidos para então mostrar as funcionalidades disponíveis.

```{r}
datas <- seq(
  from = as.Date("2017-01-10"),
  to = as.Date("2017-01-10") + 10,
  by = "day"
)
datas <- c(
  datas[1:6], NA, 
  datas[7:length(datas)], 
  datas[length(datas)], 
  datas[5:6]
)
datas
```

A função `duplicated()` detecta onde ocorrem valores repetidos. 


```{r}
duplicated(datas)
```

Ela retorna um vetor lógico mostrando quais elementos são duplicados. Neste exemplo os últimos 3 elementos. Este resultado pode ser usado para remover os valores repetidos:

```{r}
# datas únicas: sem valores duplicados
datas[!duplicated(datas)]
```

Alternativamente, há função `unique()` para remover valores repetidos de um vetor:

```{r}
unique(datas)
```

## Dados ordenados

Duas operações comuns em análise de dados são a ordenação e a classificação dados de um vetor.

A função `sort()` arranja os dados de um vetor numérico em ordem crescente ou descrescente (se argumento for especificado como `decreasing = TRUE`). Se o vetor for de caracteres, o arranjo segue a ordem alfabética dando precedência às letras em minúsculo.

```{r}
sort(prec_alt)
sort(prec_alt, decreasing = TRUE)
```

```{r}
sort(names(prec_alt))
```

A ordem de classificação de cada elemento de um vetor numérico é obtida com a função `order()`:

```{r}
prec_alt
order(prec_alt)
```

O resultado indica que o 5º elemento de `prec_alt` é o menor valor e o 1º elemento é o de maior valor. Isso pode ser facilmente verificado passando este resultado na indexação da `prec_alt`.

```{r}
# equivalente a sort()
prec_alt[order(prec_alt)]
```


Nota-se então, que por padrão na saída da `order()` os elementos faltantes são colocados nas últimas posições (no exemplo: 3, 4, 6, 11). Para remover os casos faltantes especificamos o argumento `na.last = NA`.

```{r}
order(prec_alt, na.last = NA)
```



## Funções móveis úteis

Se queremos obter um valor que leve em consideração todos os valores anteriores e o valor atual, podemos usar funções da família **cum{fun}()**, como a **`cumsum()`** para somar valores à medida que avançamos na sequência. Esta operação é conhecida como soma cumulativa, total móvel ou soma móvel.

Vamos obter a soma cumulativa da série da precipitação mensal abaixo.

```{r}
# serie de com 2 anos de prec mensal
prec <- c(
    230, 205, 160, 100, 60, 30, 
    40, 60, 110, 165, 200, 220, 
    250,200, 210, 12, 0, 30, 
    21, 42, 100, 120, 10, 208
  )
prec
# meses de prec como datas
dts <- seq(
  from = as.Date("2010-01-01"),
  by = "month",
  length.out = length(prec)
)
dts
prec_ac <- cumsum(prec)
prec_ac
```

A relação entre essas duas variáveis pode ser melhor compreendida pelo gráfico da Figura \@ref(fig:plot-cumsum).

```{r plot-cumsum, ref.label='plot-cumsum', echo = FALSE, fig.align='center', fig.cap="Visualização da soma acumulada. A precipitação será representada por barras e a precipitação acumulada até o mês decorrido como linha. Nós abordaremos os recursos para visualização gráfica na seção **Visualização de dados**.", out.width='90%'}
#library(ggplot2)
# gráfico
graf <- qplot(
  x = dts,
  y = prec,
  geom = c("col"),
  ylim = range(c(prec, prec_ac))
) +
  # ajuste dos labels das datas (eixo x)
  scale_x_date(
    name = "meses",
    date_breaks = "2 months",
    date_labels = "%b\n%Y"
  ) +
  # camada com prec acumulado
  layer(
    map = aes(
      x = dts,
      y = prec_ac,
    ),
    geom = "line",
    params = list(
      colour = "green",
      size = 1
    ),
    stat = "identity",
    position = "identity"
  )
graf

# (y_cmx <- cummax(y))
# (y_cmn <- cummin(y))
```


As funções `cummax()` e `cummin()` fornecem os valores mínimo e máximo entre o início do vetor e a posição de cada elemento. Para enfatizar a utilidade destas funções, vamos considerar o vetor `y` abaixo, representando uma onda com amplitude que aumenta no tempo.


```{r}
(x <- seq(from = 0, to = 2.75*pi, length.out = 20))
(y <- round(-x*cos(2*x), 2))
# maximos e minimos móveis de y
(y_env_sup <- cummax(y))
(y_env_inf <- cummin(y))
```

A Figura \@ref(fig:plot-cumaxmin) permite visualizar que estas funções fornecem os envelopes superior e inferior de variação de um vetor.



```{r plot-cumaxmin, ref.label='plot-cumaxmin', echo = FALSE, fig.align='center', fig.cap="Visualização do potencial uso das funções `cummax()` e `cummin()`.", out.width='90%'}
graf <- qplot(
  x = x,
  y = y,
  geom = c("line", "point"),
  ylim = range(c(y, y_env_sup, y_env_inf))
) +
  # linha do envelope superior
  layer(
    map = aes(
      x = x, 
      y = y_env_sup, 
      ), 
    geom = "line",
    params = list(
      colour = "red", 
      size = 1
      ),
    stat = "identity", 
    position = "identity"
    ) +
  # linha do envelope inferior
  layer(
    map = aes(
      x = x, 
      y = y_env_inf
      ), 
    geom = "line",
    params = list(
      colour = "blue", 
      size = 1
      ),
    stat = "identity", 
    position = "identity"
    )
graf
```

Em alguns casos precisamos comparar os valores em relação a valores antes ou depois de um elemento do vetor. Para este tipo de operação podemos usar as funções: 

- `diff(x)`: diferencial ou primeira diferença, calcula para cada elemento de `x` a diferença `x[i] - x[i-1]` para i de 2 até `length(x)`. Resulta em um vetor com um elemento a menos que o vetor de entrada.



- `lag(x, n)` do pacote **`dplyr`**[^pcktidyverse]: atrasa os valores de um vetor `x` por `n` observações (valor predefinido `n = 1`); 



- `lead(x, n)` do pacote **`dplyr`**: adianta os valores de um vetor `x` por `n` observações (valor predefinido `n = 1`); 


[^pcktidyverse]: faz parte da coleção de pacotes `r rblue` para ciência de dados chamada **tidyverse**.


Vamos comparar o resultado da `diff()` aplicada ao vetor de `prec` acumulado (`prec_ac`) com os valores `prec`.

```{r}
diff(prec_ac) 
#length(diff(prec_ac))
prec
#length(prec)
```

Se precisássemos comparar `prec` com valores do mês anterior e posterior, estes vetores poderiam ser obtidos simplesmente com:

```{r}
# vetor prec deslocado para frente (atrasado)
lag(prec)
# vetor prec deslocado para trás (adiantados)
lead(prec)
```

Para detectar períodos de aumento (ou redução) da precipitação do mês atual em relação ao anterior.

```{r}
prec - lag(prec) > 0
prec - lag(prec) < 0
```





## Identificação de eventos discretos

Frequentemente precisamos separar a série temporal de uma variável em eventos discretos, como a identificação de períodos extremos ou de risco, como secas, tempestades, ondas de calor, períodos de poluição atmosférica crítica (acima ou abaixo de um limiar de concentração do poluentes) e etc. 

Para caracterização destes eventos as informação essencias são o **início**, o **fim** e a **duração** de cada evento. Com essas informações podemos identificar cada evento e extrair outros atributos, na escala de evento, para aprofundar a análise.

Para ilustrar a conveniência das funções vistas até agora, veremos uma forma geral para identificação de eventos. O evento de interesse será o período da estação chuvosa nos dados `prec`. Neste exemplo, a estação chuvosa é definida quando `prec > 100` mm mês^-1^.  

O primeiro passo é identificar a ocorrência dos eventos.

```{r}
limiar <- 100
# definição de evento (condição)
(x <- evts <- as.integer(prec > limiar))
```

A conversão dos eventos de lógico para numérico é opcional[^aviso] e foi usada apenas para facilitar a localização dos eventos visualmente (1: ocorrência de evento, 0: não ocorrência). A partir daí, o problema consiste em identificar sequências de elementos adjacentes iguais (sequências de 1 repetidos).

[^aviso]: Isso significa que os resultados nos códigos abaixo não se alteram se removermos essa conversão.

As posições iniciais de cada evento podem ser encontradas subtraindo o elemento prévio (`lag(x)`) do elemento atual (`x`). Se a diferença for  `-1` temos o início de um evento. A tabela abaixo permite visualizar melhor isso.

```{r, echo = FALSE}
view_evts <- rbind(
  elemento = seq_along(x),
  x, 
  `lag(x)` = lag(x),
  #`lead(x)` = lead(x), 
  pos_ini = lag(x) - x 
  #pos_fim = lead(x) - x
  )
view_evts <- as.data.frame(view_evts) %>%
  setNames(., nm = rep(" ", ncol(.)))
kable(view_evts)
```



```{r}
# x atrasado: desloca os elementos para para frente
pos_ini <- which(lag(x) - x < 0)
# ajuste do primeiro elemento de pos_ini
pos_prim <- ifelse(
  test = x[1] == 1,
  yes = 1,
  no = 0
)
(pos_ini <- c(pos_prim, pos_ini))
# datas de início dos eventos
dts[pos_ini]
```

Temos que ter cuidado especial com o primeiro índice das posições iniciais (`pos_prim`), ajustando-o para considerar adequadamente eventos começando logo início do vetor. Esse ajuste é necessário porque usando a diferença do vetor defasado não há como detectar se o primeiro elemento é evento ou não.    


Analogamente, as posições finais de cada evento podem ser encontradas subtraindo o elemento seguinte (`lead(x)`) do elemento atual (`x`). Quando essa diferença é `-1` temos o fim de um evento, o que pode ser visualizado na tabela abaixo. 

```{r, echo = FALSE}
view_evts <- rbind(
  elemento = seq_along(x),
  x, 
  #`lag(x)` = lag(x),
  `lead(x)` = lead(x), 
  #pos_ini = lag(x) - x, 
  pos_fim = lead(x) - x
  )
view_evts <- as.data.frame(view_evts) %>%
  setNames(., nm = rep(" ", ncol(.)))
kable(view_evts)
```

```{r}
pos_fim <- which(lead(x) - x < 0)
# ajuste do último elemento de pos_fim
pos_ult <- ifelse(
  test = x[length(x)] == 1,
  yes = length(x),
  no = 0
)
(pos_fim <- c(pos_fim, pos_ult))
# datas do fim dos eventos
dts[pos_fim]
```



O último índice do vetor de posições finais requer tratamento similar ao do 1° elemento das posições iniciais. Ele deve ser ajustado para tratar dos casos com eventos no último elemento de `x`.

A duração de cada evento é facilmente obtida do fim e início de cada evento:

```{r}
duracao <- pos_fim - pos_ini + 1
duracao
# rbind(x, atras = lag(x), adiant = lead(x), pos_ini = lag(x)-x, pos_fim = lead(x) - x)
```

Eventualmente você pode precisar de um vetor identificando cada evento, o que pode ser feito usando:

```{r}
evts_id <- evts
evts_id[evts > 0] <- rep(seq_along(duracao), times = duracao)
evts_id
```

Este vetor pode ser usado, para obter estatísticas de cada evento. Por exemplo, a precipitação média em cada evento pode ser determinada passando este vetor como argumento da função `tapply()`. Como só queremos informação nos eventos vamos substituir os valores = 0 por NA em `evts_id`. Assim, a `tapply()` retornará a média só para os eventos de interesse. 

```{r}
evts_id <- ifelse(evts_id == 0, NA, evts_id)
# prec média em cada evento
tapply(
  X = prec,
  INDEX = evts_id,
  FUN = mean
)
```

A `tapply()` tem três argumentos:

- `X`: dados que queremos aplicar a função

- `INDEX:` vetor de índices com os grupos para os quais a função será aplicada separadamente.

- `FUN`: a função que desejamos aplicar aos dados (e.g.: `mean()`, ``)


<!--
# Forma alternativa de resolução
acum_eventos <- cumsum(eventos)
# mantém valores de cumsum qdo não é evento
# e zera qdo é evento
entre_eventos <- acum_eventos * (!eventos)
# sequencia das ocorrência dentro de um evento
(seq_eventos <- acum_eventos - cummax(entre_eventos))
# identificador da ordem cronológica de cada evento
(ordem_eventos <- cumsum(seq_eventos == 1) * eventos)
# Com os vetores que identificam cada evento e quantificam suas ocorrências em 
# cada evento, podemos extrair os índices de início, fim e a duração de cada 
# evento.
pos_ult <- ifelse(eventos[length(eventos)] == TRUE, length(eventos), 0)
#replace(pos_ult, is.na(pos_ult), NULL)
(fim <- c(which(c(NA, diff(eventos) < 0) == 1) - 1, pos_ult))
(inicio <- which(seq_eventos == 1))
(dur <- seq_eventos[fim])
unique(ordem_eventos[ordem_eventos > 0])

# freq <- table(ordem_eventos[ordem_eventos > 0])
# duracao <- unname(rep(freq, times = freq))
# dur <- ordem_eventos
# dur[ordem_eventos != 0] <- duracao
-->


<!---
- table()
frequência de ocorrência, contagens, porcentagem e proporção
- prop.table()*100
--->

## Frequência de ocorrência de dados discretos

Uma forma muito comum de resumir dados é contar quantos valores de uma variável caem dentro de diferentes classes ou intervalos. Podemos usar o exemplo anterior para contabilizar a duração de cada evento através da função `table()`.


```{r}
evts_id
freq_tab <- table(evts_id)
freq_tab
names(freq_tab)
```

Quando aplicada a dados numéricos, a função `table()` retorna o número de vezes que cada valor único aparece. Os nomes correspondem aos diferentes valores individuais. Neste caso, o número de ocorrências de cada eventos corresponde a duração deles. 

Por padrão, a `table()` não incluirá valores faltantes. Se for de interesse incluí-los, use o argumento `exclude = NULL`.

```{r}
table(evts_id, exclude = NULL)
```

A saída da função `table()` é um objeto do tipo `table`. O que pode ser tratado como um vetor com nomes.

```{r}
class(freq_tab)
```

Eventualmente você pode querer esta tabela na forma de um vetor, o que pode ser realizado simplemente concatenando a tabela: 

```{r}
c(freq_tab)
```

Alternativamente é possível converter a tabela em um quadro de dados (`data.frame`, estrutura de dados que será vista posteriormente).


```{r}
as.data.frame(freq_tab)
```

A função table() pode lidar com mais de um vetor. Por exemplo, podemos contar o números que foram acima ou abaixo da normal climatológica com a seguinte expressão:

```{r}
freq_prec <- table(Prec_acima_normal = prec > mean(prec_clim),
      mes = format(dts, "%m"))
freq_prec
#ftable
```

Verifica-se que somente os meses de Dezembro e de Janeiro Março foram acima da normal climatológica mensal nos 2 anos. Enquanto Outubro e Novembro foram somente em 1 dos 2 anos de dados.

Outra função útil neste contexto é a `cut()`. Ela separa os dados em classes ou intervalos.

```{r}
prec_classes <- cut(prec, breaks = seq(0, 250, by = 50))
prec_classes
table(prec_classes)
```


## Exercícios

1. Crie um vetor com os valores de $e^{x}cos{x}$ para os valores de $x = (3, 3.1, 3.2, ..., 6$).


- - - 


2. Crie os seguintes vetores.
    a. $(0.1^{3}\times0.2^{1}, 0.1^{6}\times0.2^{4}, ..., 0.1^{36}\times0.2^{34})$  
    
`r paste(" ")`
    b. $(2, \frac{2^{2}}{2}, \frac{2^{3}}{3}, ..., \frac{2^{25}}{25})$  
    


- - -

3. Reproduza a criação do vetor dias da semana (`dds`) mostrado abaixo.

```
domingo segunda   terca  quarta  quinta   sexta   sabado
      1       2       3       4       5       6        7
```

- - - 

4. Interprete o resultado da seguinte operação:

```{r, eval = FALSE}
dds_nums <- c(
  5L, 2L, 5L, 2L, 7L, 7L, 2L,
  6L, 6L, 3L, 7L, 1L, 2L, 2L,
  5L, 7L, 3L, 2L, 6L, 4L, 1L
)
names(dds)[dds_nums]
```

- - -

5. a. Escreva o código necessário para determinar o vetor lógico indicando quais números são pares na sequência de valores `r set.seed(2); paste0(paste( (nums <- sample(1:100, 10)) , collapse = ", "))`. b. Calcule o total de números ímpares.


- - - 

6. Para um ano ser bissexto, ele deve ser:

- divísivel por 4 (a divisão é exata com resto igual a zero)

- não pode ser divisível por 100 (a divisão não é exata, ou seja, o resto é diferente de zero)

- pode ser que seja divisível por 400: caso seja divisível por 400, a divisão deve ser exata, deixando o resto igual a zero.

`r paste("  ")`Com os critérios definidos acima, construa o código para:

`r paste("  ")`a. Verificar se os anos `r set.seed(3); paste( (anos <- c(sample(1890:2015, 10), 2100, 2300)) , collapse = ", ")` são bissextos.

`r paste("  ")`b. Mostre quais anos são bissextos.

`r paste("  ")`c. Usando o código para verificar se o ano é bissexto, gere um vetor nomeado `ndias` com o número de dias do ano para os anos do item (a).

`r paste("  ")`d. Programe como obter o total de anos com 366 dias?



- - -

7. Quais códigos para gerar os seguintes dados:

  a.
  
```
[1] -30   0   5  10  15  20  30
```
  b.

```
[1] 1.0 0.8 0.6 0.4 0.2 0.0
```  
  
  c.

```
[1] -3.1415927 -2.4434610 -1.7453293 -1.0471976 -0.3490659  0.3490659
[7]  1.0471976  1.7453293  2.4434610  3.1415927
```

  
  d.

```
[1] -1 -1  0  0  0  1  1  1  1  2  2  2  2  2  3  3  3  3  3  3  4  4  4
[24]  4  4  4  4  5  5  5  5  5  5  5  5
```

  e.

```
[1] 5 5 5 5 5 4 4 4 4 3 3 3 2 2 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5
```
  

- - - 

8. Usando o mesmo código para solução em todos os itens abaixo, obtenha as seguintes sequências usando os vetores fornecidos.

```{r , eval=TRUE,echo=FALSE}
v3 <- c(11, 0.25, 7, 2)
``` 

 a. v3 = `r paste0("(", paste(v3 , collapse = ", "), ")")`

```
[1] 1 2 3 4
``` 


  b. v2 = `r paste0("(", paste(v3[1:2] , collapse = ", "), ")")`

```
[1] 1 2
```


  c. v1 = `r paste0("(", paste(v3[1] , collapse = ", "), ")")`


```
[1] 1
```

```{r Chunk7d, eval=TRUE,echo=FALSE,comment=""}
v0 <- c()
``` 

  d. v0 = `r paste0("(", paste(v0 , collapse = ", "), ")")`

```
integer(0)
```

- - -

9. Considere os seguintes dados horários de temperatura do ar ($T_{ar}$) registrados em duas estações meteorológicas, entre as 0 e 23 horas de um dado dia.

```{r prep-tar-data}
tar_est1 <- c(
  14.92, 14.61, 14.32, 14.07, 13.84, 13.65, 13.56, 13.97, 15.08,
  16.5, 17.88, 19.08, 20.02, 20.66, 21.01, 21.05, 20.76, 20.05,
  18.77, 17.51, 16.67, 16.11, 15.66, 15.27
)
tar_est2 <- c(
  13.13, 13.01, 12.93, 12.87, 12.82, 12.81, 13.2, 14.22, 15.77,
  17.49, 19.2, 20.57, 21.49, 22.01, 22.03, 21.71, 20.84, 18.77,
  16.54, 15.13, 14.34, 13.81, 13.49, 13.28
)
```

> Dica: Faça um gráfico para visualizar as temperaturas das duas estações. Isso facilitará a solução.

`r paste("   ")`**a.** Determine a média diária da $T_{ar}$ das duas estações arrendondando para uma casa decimal. Salve a média de cada estação nas variáveis `tmed_est1` e `tmed_est2`. 


`r paste("   ")`**b**. Utilizando as variáveis do item anterior, verifique usando comparação lógica, em qual estação o ambiente é mais quente?


`r paste("   ")`**c**. Obtenha a 3ª maior temperatura do dia em cada estação.


`r paste("   ")`**d**. Calcule a amplitude térmica diária ($ATD = T_{max}-T_{min}$, onde $T_{max}$: temperatura máxima dária e $T_{min}$: temperatura mínima dária) das estações 1 e 2, arrendondando para uma casa decimal. Salve os resultados nas variaveis `atd_est1` e `atd_est2`.


`r paste("   ")`**e**. Qual o horário de ocorrência das temperaturas máximas e mínimas em cada estação? Salve os resultados nas variáveis `hmax_est{i}` e `hmin_est{i}`, com $i = 1, 2$.


`r paste("   ")`**f**. Quando `tar_est2` é maior que `tar_est1` qual a maior diferença absoluta de temperatura entre as duas estações?


`r paste("   ")`**g**. Qual a hora correspondende a ocorrência daquela maior diferença absoluta de temperatura obtida no item anterior?

`r paste("   ")`**h**. O horário do pôr do sol pode ser estimado a partir da $T_{ar}$. Para o período após o horário de ocorrência da $T_{max}$ determina-se em qual hora ocorre a maior queda de $T_{ar}$ em relação a hora anterior. Estime o horário do pôr do sol para as duas estações (`hps_est{i}`). 


`r paste("   ")`**i**. Em quais horas as temperaturas das duas estações estão mais próximas uma da outra, ou seja com menos de 0,5°C de diferença ?


`r paste("   ")`**j**. Calcule a temperatura média diária usando os seguintes métodos para estação 2.

$T_{med_{1}} = (T_{max} + T_{min})/2$, salvando em uma variável `tar_met1`.


$T_{med_{2}} = (T_{max} + T_{min} + T_{9} + 2T_{21})/5$, salvando em uma variável `tar_met2`.


$T_{med_{3}} = (T_{7} + T_{14} + 2T_{21})/4$, salvando em uma variável `tar_met2`.


`r paste("   ")`**k**.Compare este resultados com aqueles obtidos no item **a**. Qual é melhor?

- - -

10. Calcule a temperatura do ar horária usando o **modelo de onda** para representação do ciclo diário da temperatura do ar, descrito pelas seguintes equações:

$$\left\{\begin{matrix}
h_{T_{min}}\leq h < h_{T_{max}}, & T_{calc} =  \bar{T} - A \, cos\left ( arg \right )\\ 
demais\; horas, & T_{calc} =  \bar{T} + A \, cos\left ( arg \right )
\end{matrix}\right.$$

`r paste("   ")`onde:

$$\bar{T} = \left ( \frac{T_{max} + T_{min}}{2} \right )$$

`r paste("   ")`e 

$$A =\left ( \frac{T_{max}-T_{min}}{2} \right ) $$

`r paste("   ")`O argumento do cosseno ($arg$) é definido por:

$$\left\{\begin{matrix}
h <  h_{T_{min}}, & arg = \pi  \left ( \frac{h+10}{10+h_{Tmin}} \right )\\ 
h_{T_{min}}\leq h < h_{T_{max}}, & arg = \pi  \left ( \frac{h-h_{T_{min}}}{14-h_{T_{min}}} \right )\\ 
h > h_{T_{max}},  & arg = \pi\left ( \frac{14-h}{10+h_{Tmin}} \right )
\end{matrix}\right. $$

`r paste("   ")`**a**. Aplique o método acima para estação 1 e 2 substituindo os valores de $T_{max}$, $T_{min}$, $h_{T_{max}}$, $h_{T_{max}}$, adequadamente.


`r paste("   ")`**b**. Calcule o RMSE nos dois casos. $RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^{n}\left (T_{calc}-T_{obs}  \right )^{2}}$

`r paste("   ")`**c**. Calcule a correlação ($r$) nos dois casos. A barra representa a média aritmética. Confira seu resultado com a saída da função `cor(tar_obs, tar_calc)`. 

$$r = \frac{\sum_{i=1}^{n} (T_{obs}-\bar{T}_{obs})(T_{calc}-\bar{T}_{calc}))}{\sqrt{\sum_{i = 1}^{n} (T_{obs}-\bar{T}_{obs})^{2}(T_{calc}-\bar{T}_{calc})^{2})}}$$





- - -

11. Os dados abaixo são de precipitação horária de um evento severo ocorrido em 03/12/2012 em Santa Maria-RS. 

```{r, echo = FALSE}
hora <- (12:24) - 3
prec_h <- c(0, 0, 0, 0, 0, 0, 0, 21.4, 41.2, 2.6, 1, 0.4, 0)
evento <- data.frame(hora, prec = prec_h)
knitr::kable(evento, align = "c", longtable = TRUE)
```

`r paste("  ")`a. Como seria o código para determinar a soma cumulativa da precipitação horária? Salve o resultado em um vetor chamado `prec_acum`. Interprete o resultado de `c(NA, diff(prec_acum))`.



`r paste("  ")`b. Mostre o código para encontrar o horário de ocorrência da precipitação máxima?



`r paste("  ")`c. Mostre o código para obter a hora de início e fim do evento de  precipitação severa. Qual foi a duração do evento?



`r paste("  ")`d. Qual foi a precipitação total do evento? Quanto da precipitação total do evento, em %, ocorreu até às 17 h?


- - -

12. Considere o vetor `x` definido pelos números descritos abaixo. Mostre como  encontrar o primeiro número positivo localizado após o último número negativo. Por exemplo, seja o vetor `z` definido pelos valores (11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14). Os valores selecionados seriam 5 e 30.


- - -

13. Considerando o vetor `prec` com valores de precipitação diária indicado abaixo. Escreva o código para resolver as seguintes tarefas.

```{r prep-data-prec, echo=FALSE, eval=FALSE}
# como gerar vetor de precipitações
vprec <- c(
  0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
  0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
  1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
  1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0
)
prec <- vprec
prec[vprec > 0] <- runif(sum(vprec > 0)) * sample(c(0.1, 1, 5, 10, 20), size = sum(vprec > 0), replace = TRUE, prob = c(0.1, 0.30, 0.3, 0.2, 0.1))
prec
dput(round(prec, 2))
```

```{r data-q13, message=FALSE, echo=TRUE, eval=TRUE}
prec <- c(
  0, 0, 0, 0.8, 0, 0.01, 0.75, 0,
  0, 0, 0, 0.35, 0.08, 0, 0, 0, 0, 0.31, 0, 3.57, 12.17, 0, 0,
  0, 0.04, 3.16, 0, 0.95, 0.79, 0, 0, 0, 0, 0, 3.51, 0, 0, 0.16,
  0, 0, 8.16, 0.54, 4.39, 1.24, 0, 0, 0, 0, 0, 2.43, 0, 0, 0, 0,
  0, 7.18, 0, 0, 0.26, 0, 0, 0.28, 0, 0, 0.09, 0.38, 0, 0, 0, 0,
  0, 0, 0.51, 0, 0, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0.15, 0, 0.82,
  0, 0, 0, 0, 0, 0, 0, 0, 0.37, 0, 0.58, 4.95, 0, 0, 0, 0, 0, 7.68,
  0, 0, 0.37, 0, 1.56, 0, 0, 0, 0.34, 0.48, 0, 4.21, 2.28, 4.3,
  0, 3.38, 0, 0, 0, 0, 7.28, 0, 4.89, 3.91, 0, 0, 0, 0, 0, 0, 2.93,
  0, 2.49, 0.77, 0, 2.9, 3.53, 0.83, 0, 0, 0, 0.94, 0.59, 0, 0,
  0, 0, 0.04, 0, 0.65, 0, 0, 0, 6.23, 0.09, 0, 0.66, 0, 0, 0, 4.42,
  0, 0, 0, 0.84, 0, 0, 0, 0, 0, 0.09, 0, 0, 0.08, 0, 0.66, 0, 0,
  0, 0.06, 0, 0, 0, 3.28, 0, 0.8, 5.69, 0.8, 0
)
```

`r paste("   ")`(a) Quantos dias ocorreram no intervalo 0 < prec < 0.25?
  

`r paste("   ")`(b) Substitua os valores de chuva registrados no intervalo 0 < prec < 0.25 por 0.
  

`r paste("   ")`(c) Crie um vetor denominado `prec01` indicando o estado da precipitação (chuvoso = 1, seco = 0) baseado no limiar de 0.25 mm para detecção de chuva pelo pluviômetro. 


`r paste("   ")`(d) Qual a probabilidade de chuva dessa série de precipitação diária?
  

`r paste("   ")`(e) Qual a probabilidade de chover dois dias consecutivos (`p11`)? Calcule a probabilidade de chover em qualquer um de dois dias consecutivos (`p01 + p10`)?



`r paste("   ")`(f) Determine a duração de cada evento chuvoso (número de dias consecutivos).
   

O resultado esperado é um vetor que identifique o evento e sua duração.

```{r Chunk10f1, eval=TRUE, results = 'hide'}
duracao <- c(evento1 = 1, evento2 = 1, evento3 = 1, evento4 = 1, evento5 = 2, 
evento6 = 1, evento7 = 2, evento8 = 1, evento9 = 4, evento10 = 1, 
evento11 = 1, evento12 = 1, evento13 = 1, evento14 = 1, evento15 = 1, 
evento16 = 1, evento17 = 1, evento18 = 1, evento19 = 2, evento20 = 1, 
evento21 = 1, evento22 = 1, evento23 = 2, evento24 = 3, evento25 = 1, 
evento26 = 1, evento27 = 2, evento28 = 1, evento29 = 2, evento30 = 3, 
evento31 = 2, evento32 = 1, evento33 = 1, evento34 = 1, evento35 = 1, 
evento36 = 1, evento37 = 1, evento38 = 1, evento39 = 3)
```

```{r}
duracao
```


- - -

14. Dado o vetor `dados` mostrado abaixo.

```{r prep-data-gaps, echo=FALSE, eval=TRUE}
dados <- sample(0:30, 30)
dados[2:4] <- NA
dados[10:15] <- NA
dados[23:29] <- NA
# dput(dados)
dados <- c(
  NA, NA, 27L, 7L, 4L, 0L, 26L, 15L, 25L, NA, NA, NA, NA, 6L,
  29L, 18L, 17L, 23L, 20L, 1L, 30L, 13L, NA, NA, NA, NA, NA, NA,
  NA, 19L
)
```

```{r Chunk112}
dados <- c(
  NA, NA, 27L, 7L, 4L, 0L, 26L, 15L, 25L, NA, NA, NA, NA, 6L,
  29L, 18L, 17L, 23L, 20L, 1L, 30L, 13L, NA, NA, NA, NA, NA, NA,
  NA, 19L
)
```

`r paste("  ")`a. Como você pode codificar a obtenção de um vetor com zeros nos valores válidos e com números sequenciais dentro das falhas?


`r paste("  ")`b. Como a partir do vetor resultante do item anterior você pode obter um vetor cujo os valores
dentro das falhas indique a ordem de ocorrência da falha.


`r paste("  ")`c. Qual o código para determinar o tamanho de cada falha?
   

`r paste("  ")`d. Como determinar o tamanho da maior falha?


- - -

15. Para os valores de velocidade ($V_h$) e a direção do vento ($\theta$) (na convenção meteorológica):

```{r Chunk12, include=FALSE}
ws <- c(10, 10, 10, 10, 14.142, 14.142, 14.142, 14.142, 0)
wd <- c(270, 180, 360, 90, 225, 315, 135, 45, 0)
```

$V_h$ = `r paste0("(", paste(ws , collapse = ", "), ")")`

$\theta$ = `r paste0("(", paste(wd , collapse = ", "), ")")`

`r paste("  ")`a. Determine as componentes zonal e meridional do vento.
   
   $$u = -V_{h} \cdot sin(\theta_{rad})$$
   $$v = -V_{h} \cdot cos(\theta_{rad})$$



`r paste("  ")`b. Faça os cálculos necessários para reconstruir $V_h$ e $\theta$, a partir de $u$ e $v$ determinados no item **a**. Por convenção, a direção do vento $\theta$ em condições calmas ($V_h$ < 0.5 m s^-1^) é assumida como 0°.

$$V_{h} = \sqrt{(u^2 + v^2)}$$
$$\theta_{mat} = {\rm atan2}(-u, -v)\cdot\frac{180}{\pi}$$
$$
\theta = \left\{\begin{matrix}
\theta_{mat} + 360 & se & \theta_{mat} < 0 \\ 
0 & se & u = 0,\:  v = 0 \: \:  ou \: \:  V_{h} < 0.5\\
\end{matrix}\right.
$$


A tabela abaixo apresenta o resultado esperado para as variáveis derivadas.

```{r, eval = TRUE, echo = FALSE}
uv_df <- structure(list(u = c(10, 0, 0, -10, 10, 10, -10, -10, 0), v = c(0, 
10, -10, 0, 10, -10, 10, -10, 0), ws = c(10, 10, 10, 10, 14.142, 
14.142, 14.142, 14.142, 0), wd = c(270, 180, 360, 90, 225, 315, 
135, 45, 0), wd_uv = c(270, 180, 360, 90, 225, 315, 135, 45, 
0), dir = structure(c(6L, 9L, 5L, 2L, 8L, 4L, 7L, 3L, 1L), .Label = c("Calmo", 
"Leste", "Nordeste", "Noroeste", "Norte", "Oeste", "Sudeste", 
"Sudoeste", "Sul"), class = "factor")), class = "data.frame", row.names = c(NA, 
-9L))
knitr::kable(uv_df)
```



> Dica: ver figura abaixo.

![](images/wind_components.png)


- - -


16. Para as séries de `prec_obs` e `prec_sim` calcule:

`r paste("    ")`a. A proporção corretamente prevista $PC = \frac{wc+dc}{n}$ 

`r paste("    ")`b. O índice de sucesso crítico $CSI=\frac{wc}{wc+wi+di}$. 

Onde $wc$ e $dc$ são as previsões corretas de dias úmidos ($prec > 0.25$ mm dia^-1^) e secos respectivamente, $wi$ e $di$ são as previsões incorretas de dias úmidos e secos respectivamente. $n$ é o n° total de previsões.

```{r, echo = TRUE}
prec_obs <- c(
  0, 0, 0, 0.5, 1, 6, 9, 0.2, 1, 0, 0, 0.25,
  10, 15, 8, 3, 0, 0, 0, 0, 0, 0, 0.25, 0,
  0, 0, 1, 5, 0, 20, 0, 0, 0, 0, 1, 1,
  0, 2, 12, 1, 0, 0, 0, 0, 0, 0, 5, 5
)
prec_sim <- c(
  0, 0.2, 0.1, 0, 0, 3, 1, 1, 1, 1, 0, 3,
  0, 10, 4, 1, 0.3, 0.5, 0.5, 0.5, 0.5, 0, 0.25, 0.25,
  0.25, 0, 0.5, 3, 0, 5, 0, 0, 0, 0, 0.5, 0,
  0.25, 0.2, 0, 0.2, 0, 0, 0, 0, 1, 2, 1, 0
)
```


- - -

17. Escreva o código para calcular as estatísticas abaixo, entre os vetores de valores observados (`obs`) e previstos (`prev`) por um dado modelo atmosférico, em um dado local.

`r paste("  ")`a. O Viés relativo (%)[^vies].  

$$PBIAS = 100\frac{\sum_{i=1}^{n}(Prev_{i}-Obs_{i})}{\sum_{i=1}^{n}(Obs_{i})}$$. 


[^vies]: Mede a tendência média dos valores previstos (ou simulados) em serem maiores (superestimativa) ou menores (subestiva) que os observados. O valor ótimo é 0, menores valores indicam melhor desempenho. Valores positivos indicam tendência de superestimativa e negativos de subestimativa.


`r paste("  ")`b. Coeficente de eficiência de Nash-Sutcliffe (NSE)[^nse].

[^nse]: NSE é uma estatística normalizada que que determina a magnitude relativa da variância residual (ruído) comparada a variância dos dados medidos (informação). NSE varia de -Inf a 1. Essencialmente, quanto mais próximo a 1, melhor o modelo. 


$$NSE = 1 - \frac{\sum_{i=1}^{n} (Obs_{i}-Sim_{i})^{2}}{\sum_{i = 1}^{n} (Obs_{i}-\bar{Obs}_{i})^{2}}$$





```{r , include=TRUE}
v_obs <- c(
  -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16,
  0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73,
  -0.49, -0.04, -0.11, 0.46, 2.02, -1.05
)
v_prev <- c(
  NA, -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16,
  0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73,
  -0.49, -0.04, -0.11, 0.46, 2.02
)
```






