[
["estrutura-dados.html", "7 Estrutura de dados", " 7 Estrutura de dados Existem diferentes formas de armazenar dados no R. Algumas vezes os dados precisam ser armazenados de forma mais complexa do que por exemplo vetores. O possui uma variedade de estruturas (Figura 7.1). Dentre elas as fundamentais que serão vistas neste capítulo são: dataframe (tabela de dados) matrix (matriz) list (lista) array e vector (vetor) Figure 7.1: Principais estruturas de dados no R. "],
["vetor.html", "7.1 Vetor", " 7.1 Vetor Um vetor é uma coleção de elementos. Os vetores são amplamente usados e compõem a estrutura básica de dados do R, por ser uma linguagem vetorizada. Os vetores podem ser de dois tipos: vetores atômicos e listas. 7.1.1 Vetores atômicos Os vetores atômicos são constituem a estrutura de dados mais simples do R (como se fossem os átomos do R). Um vetor atômico é uma coleção de elementos, em que todos são do mesmo tipo de dado (todos double, ou integer, ou logical, etc). Como linguagem vetorizada, as operações são aplicadas a cada elemento do vetor automaticamente, sem a necessidade de laços (ou loopings) ao longo do vetor. Esse conceito pode ser estranho para quem vem de outras linguagens, mas é uma das grandes vantagens do R. Vetores não tem dimensões, ou seja não existem é um vetor linha ou vetor coluna. 7.1.1.1 Propriedades typeof() para descobrir o tipo de dado length() para descobrir o tamanho de um tipo de dado attributes (informações acionais específicas do dado), entre eles o atributo mais comum está o names(). 7.1.1.2 Criação Vetores atômicos são geralmente criados com c(), abreviatura para o verbo combinar ou concatenar. # vetor numérico vetor_num &lt;- c(5, 2.5, 4.5) # Note o sufixo L que distingue variaveis &quot;double&quot; de &quot;integers&quot; vetor_int &lt;- c(1L, 6L, 10L) # Vetor logico vetor_log &lt;- c(TRUE, FALSE, TRUE, FALSE) # Vetor de caracteres vetor_char &lt;- c(&quot;Analise de dados&quot;, &quot;ambientais com o R&quot;) Vetores atômicos podem ser criados a partir de outros vetores aninhados entre si pela função c(). v1 &lt;- 1 # vetor com 1 elemento v2 &lt;- c(2) # vetor com 1 elemento v3 &lt;- c(4, 6) # vetor com 2 elemento Formas diferentes para criação de vetor que resultam num mesmo vetor: (v_123 &lt;- c(v1, v2, v3)) #&gt; [1] 1 2 4 6 (v_123a &lt;- c(1, c(v2, v3))) #&gt; [1] 1 2 4 6 (v_123b &lt;- c(vetor_num, c(v1, v2), v3)) #&gt; [1] 5.0 2.5 4.5 1.0 2.0 4.0 6.0 v &lt;- c(1, 2, 4, 6) v #&gt; [1] 1 2 4 6 7.1.1.3 Coerção de vetores c(&quot;a&quot;, 1) #&gt; [1] &quot;a&quot; &quot;1&quot; as.numeric(c(FALSE, FALSE, TRUE)) #&gt; [1] 0 0 1 Você pode manualmente forçar um tipo de vetor para outro usando funções de coerção: as.character(), as.double(),as.integer(), as.logical(). Coerção frequentemente acontece automaticamente, mas geralmente será mostrada uma mensagem quando ocorrer. Vamos usar a coerção no seguinte caso. Imagine um vetor com valores de chuva mensal de um ano e outro vetor com os meses do ano. Note a diferença da forma como criamos o vetor meses e o vetor months. Como descobrir o número de meses sem chuva nesse ano? # vetor com nomes criados com 1 comando meses &lt;- c( jan = 1, fev = 2, mar = 3, abr = 4, mai = 5, jun = 6, jul = 7, ago = 8, set = 9, out = 10, nov = 11, dez = 12 ) meses #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 # vetor definido e depois adiciona-se o nome das variáveis months &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) names(months) &lt;- c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;) months #&gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 # o atibuto mais comum de um vetor attributes(meses) #&gt; $names #&gt; [1] &quot;jan&quot; &quot;fev&quot; &quot;mar&quot; &quot;abr&quot; &quot;mai&quot; &quot;jun&quot; &quot;jul&quot; &quot;ago&quot; &quot;set&quot; &quot;out&quot; &quot;nov&quot; #&gt; [12] &quot;dez&quot; length(meses) #&gt; [1] 12 # Vetor com dados de prec chuva &lt;- c(100, 0, 20, 140, 110, 50, 90, 0, 0, 10, 0, 6) length(chuva) #&gt; [1] 12 # quando nao choveu? seco &lt;- chuva == 0 seco #&gt; [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE TRUE #&gt; [12] FALSE # coerção de lógico para numérico seco01 &lt;- as.numeric(seco) # seco01 &lt;- as.integer(seco) seco01 #&gt; [1] 0 1 0 0 0 0 0 1 1 0 1 0 # total de meses secos no ano sum(seco01) #&gt; [1] 4 # também funciona com vetores lógicos sum(seco) #&gt; [1] 4 7.1.1.4 Nomeando vetores Nós podemos nomear um vetor de 3 formas: Durante a criação Modificando um vetor Criando um vetor modificado Nomes devem ser únicos (sem repetições), porque para filtragem de elementos de um vetor ou a seleção de um subconjunto (razão pela qual usam-se os names) retornará somente o primeiro elemento que tiver nome repetido. # Durante a criação: x &lt;- c(a = 1, b = 2, c = 3) x #&gt; a b c #&gt; 1 2 3 # Modificando um vetor: x &lt;- 1:3 names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x #&gt; a b c #&gt; 1 2 3 # Criando um vetor modificado x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) x #&gt; a b c #&gt; 1 2 3 Nem todos elementos precisam ter nomes. Se os nomes são faltantes, names() retornará um string vazia (“”) para aqueles elementos. Se todos forem faltantes, names() retornará NULL. y &lt;- c(a = 1, 2, 3) names(y) #&gt; [1] &quot;a&quot; &quot;&quot; &quot;&quot; z &lt;- c(1, 2, 3) names(z) #&gt; NULL Podemos criar um vetor sem nomes usando a função unname(x), ou remover names com names(x) &lt;- NULL. a &lt;- c(dia1 = 12, dia2 = 20, dia3 = 10) a #&gt; dia1 dia2 dia3 #&gt; 12 20 10 names(a) #&gt; [1] &quot;dia1&quot; &quot;dia2&quot; &quot;dia3&quot; a_sn &lt;- unname(a) a_sn #&gt; [1] 12 20 10 names(a_sn) #&gt; NULL 7.1.2 Operações com vetores Para multiplicar cada elemento de um vetor por um valor é usar o operador de multiplicação (*). O mesmo procedimento se aplica as demais operações de soma, subtração, divisão, exponenciação e etc. x &lt;- 1:10 x * 3 #&gt; [1] 3 6 9 12 15 18 21 24 27 30 x + 2 #&gt; [1] 3 4 5 6 7 8 9 10 11 12 x - 3 #&gt; [1] -2 -1 0 1 2 3 4 5 6 7 x / 4 #&gt; [1] 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2 ^ (x / 4) #&gt; [1] 1.189207 1.414214 1.681793 2.000000 2.378414 2.828427 3.363586 #&gt; [8] 4.000000 4.756828 5.656854 x ^ 2 #&gt; [1] 1 4 9 16 25 36 49 64 81 100 sqrt(x) #&gt; [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 #&gt; [8] 2.828427 3.000000 3.162278 Operações vetoriais podem ser estendidas para mais de um vetor. # criando 2 vetores de mesmo tamanho x &lt;- 1:10 y &lt;- -5:4 # somando-os x + y #&gt; [1] -4 -2 0 2 4 6 8 10 12 14 x - y #&gt; [1] 6 6 6 6 6 6 6 6 6 6 x * y #&gt; [1] -5 -8 -9 -8 -5 0 7 16 27 40 x / y #&gt; [1] -0.2 -0.5 -1.0 -2.0 -5.0 Inf 7.0 4.0 3.0 2.5 x ^ y #&gt; [1] 1.000000e+00 6.250000e-02 3.703704e-02 6.250000e-02 2.000000e-01 #&gt; [6] 1.000000e+00 7.000000e+00 6.400000e+01 7.290000e+02 1.000000e+04 2 ^ x #&gt; [1] 2 4 8 16 32 64 128 256 512 1024 x %% y #&gt; [1] -4 -2 0 0 0 NA 0 0 0 2 # tamanho dos vetores length(x) #&gt; [1] 10 length(y) #&gt; [1] 10 length(x + y) #&gt; [1] 10 Uma peculiaridade do R é o tratamento de operações com vetores de tamanhos diferentes. O vetor menor é reciclado, de forma que seus elementos sejam repetidos em ordem até atingirem o tamanho do vetor mais longo envolvido na operação. v1 &lt;- c(3, 5, 88, 90) v2 &lt;- c(2, 1) v1 + v2 #&gt; [1] 5 6 90 91 Se o vetor mais longo não é múltiplo do mais curto, o R imprime um aviso. v1 &lt;- c(3, 5, 88, 90) v2 &lt;- c(2, 1, 3) v1 + v2 #&gt; Warning in v1 + v2: longer object length is not a multiple of shorter #&gt; object length #&gt; [1] 5 6 91 92 A reciclagem é intrinsecamente usada em operações envolvendo vetores. v1 #&gt; [1] 3 5 88 90 cte &lt;- 4 v1 * cte #&gt; [1] 12 20 352 360 O número 4 nesse caso é reciclado 4 vezes e então multiplicado por cada elemento do vetor v1. Avisos e erros: v1 &lt;- c(3, 5, 88, 90) srt(v1) #&gt; Error in srt(v1): could not find function &quot;srt&quot; sqrt(-v1) #&gt; Warning in sqrt(-v1): NaNs produced #&gt; [1] NaN NaN NaN NaN Comparações também funcionam com vetores. x &lt;= 5 #&gt; [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE x &gt; y #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE x &lt; y #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE Entre os operadores lógicos vistos (Tabela ??) alguns deles não foram aplicados em exemplos. Vamos então usar o operador %in% para verificar se um vetor está contido parcial ou totalmente em outro vetor. # operador está contido em 2:4 %in% x #&gt; [1] TRUE TRUE TRUE # 2:4 são elementos de x? is.element(2:4, x) #&gt; [1] TRUE TRUE TRUE A função nchar() também funciona sobre cada elemento do vetor. Esse é mais um exemplo de função vetorizada do R. nchar(month.name) #&gt; [1] 7 8 5 5 3 4 4 6 9 7 8 8 nchar(y) #&gt; [1] 2 2 2 2 2 1 1 1 1 1 7.1.2.1 Operadores any e all vetor &lt;- c(0, 1, -1, -2, 3, 5, -5) all(vetor &lt; 0) # todas as posições são maiores que 0 ? #&gt; [1] FALSE any(vetor &gt; 0) # alguma posição é maior que 0? #&gt; [1] TRUE Ambas as funções sintetizam a informação: all() verifica se a condição avaliada é válida para todos elementos do vetor; any() verifica se a condição avaliada é válida para pelo menos um dos elementos do vetor; As funções fornecem um único valor (vetor lógico de tamanho 1) para resumir ou descrever o resultado da condição aplicada ao vetor. 7.1.3 Sequências Vimos nas seções anteriores que é muito simples criar sequências de números inteiros com o operador :. Nesta seção veremos outras formas de gerar sequências, como uma sequência de números não inteiros e sequências de números repetidos. 7.1.3.1 Sequências de números inteiros Sequências de números formam um vetor. Há diversas formas de se gerar sequências no R. Para gerar uma sequência de 1 até 365, em vez de escrevermos cada número e combiná-los usando c(1,2,3,...,365), podemos usar o operador : da seguinte forma: # dias do ano dda &lt;- 1:365 dda #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #&gt; [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #&gt; [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #&gt; [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #&gt; [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #&gt; [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #&gt; [103] 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #&gt; [120] 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #&gt; [137] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #&gt; [154] 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 #&gt; [171] 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 #&gt; [188] 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 #&gt; [205] 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #&gt; [222] 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 #&gt; [239] 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 #&gt; [256] 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 #&gt; [273] 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 #&gt; [290] 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 #&gt; [307] 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #&gt; [324] 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 #&gt; [341] 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 #&gt; [358] 358 359 360 361 362 363 364 365 # sequencia de anos anos &lt;- 1961:1990 anos #&gt; [1] 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 #&gt; [15] 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 #&gt; [29] 1989 1990 # sequencia de inteiros decrescente si_dec &lt;- 10:-10 si_dec #&gt; [1] 10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 #&gt; [18] -7 -8 -9 -10 # sequencia de numeros não inteiros seqn &lt;- 1.5:10 seqn #&gt; [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 c(seqn, 10) #&gt; [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.0 7.1.3.2 Sequências de números não inteiros Mas para gerar uma sequencia de números não inteiros há uma função específica para tal tarefa. # igual a c(snum, 10), mas usando o seq (snum_b &lt;- seq(from = 1.5, to = 10, by = 0.5)) #&gt; [1] 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 #&gt; [15] 8.5 9.0 9.5 10.0 Exemplos de sequência de anos, meses e dias. # vetor com de anos decimais (2 valores por dia) anos_dec &lt;- seq(2010, 2011, length.out = 365 * 2) # para ver só o início do vetor ao invés de todo o vetor head(anos_dec) #&gt; [1] 2010.000 2010.001 2010.003 2010.004 2010.005 2010.007 # mas não dá pra ver a parte decimal, vamos alterar as opções # aumentando as casas decimais options(digits = 6) # verifique agora head(anos_dec) #&gt; [1] 2010.00 2010.00 2010.00 2010.00 2010.01 2010.01 # só os primeiros 30 elementos head(anos_dec, 30) #&gt; [1] 2010.00 2010.00 2010.00 2010.00 2010.01 2010.01 2010.01 2010.01 #&gt; [9] 2010.01 2010.01 2010.01 2010.02 2010.02 2010.02 2010.02 2010.02 #&gt; [17] 2010.02 2010.02 2010.02 2010.03 2010.03 2010.03 2010.03 2010.03 #&gt; [25] 2010.03 2010.03 2010.04 2010.04 2010.04 2010.04 # para ver só o final do vetor yrFrac tail(anos_dec) #&gt; [1] 2010.99 2010.99 2011.00 2011.00 2011.00 2011.00 # para ver só os último 50 elementos do yrFrac tail(anos_dec, 50) #&gt; [1] 2010.93 2010.93 2010.94 2010.94 2010.94 2010.94 2010.94 2010.94 #&gt; [9] 2010.94 2010.95 2010.95 2010.95 2010.95 2010.95 2010.95 2010.95 #&gt; [17] 2010.95 2010.96 2010.96 2010.96 2010.96 2010.96 2010.96 2010.96 #&gt; [25] 2010.97 2010.97 2010.97 2010.97 2010.97 2010.97 2010.97 2010.98 #&gt; [33] 2010.98 2010.98 2010.98 2010.98 2010.98 2010.98 2010.98 2010.99 #&gt; [41] 2010.99 2010.99 2010.99 2010.99 2010.99 2010.99 2011.00 2011.00 #&gt; [49] 2011.00 2011.00 # pentadas pent &lt;- seq(from = 1, to = 365, by = 5) # dencendios decd &lt;- seq(from = 1, to = 365, by = 10) # fracoes de dia frac_d30mn &lt;- seq(0, 365, length.out = 365 * 48) + 1 head(frac_d30mn, 48 * 2) #&gt; [1] 1.00000 1.02083 1.04167 1.06250 1.08334 1.10417 1.12501 1.14584 #&gt; [9] 1.16668 1.18751 1.20835 1.22918 1.25001 1.27085 1.29168 1.31252 #&gt; [17] 1.33335 1.35419 1.37502 1.39586 1.41669 1.43752 1.45836 1.47919 #&gt; [25] 1.50003 1.52086 1.54170 1.56253 1.58337 1.60420 1.62504 1.64587 #&gt; [33] 1.66670 1.68754 1.70837 1.72921 1.75004 1.77088 1.79171 1.81255 #&gt; [41] 1.83338 1.85422 1.87505 1.89588 1.91672 1.93755 1.95839 1.97922 #&gt; [49] 2.00006 2.02089 2.04173 2.06256 2.08340 2.10423 2.12506 2.14590 #&gt; [57] 2.16673 2.18757 2.20840 2.22924 2.25007 2.27091 2.29174 2.31257 #&gt; [65] 2.33341 2.35424 2.37508 2.39591 2.41675 2.43758 2.45842 2.47925 #&gt; [73] 2.50009 2.52092 2.54175 2.56259 2.58342 2.60426 2.62509 2.64593 #&gt; [81] 2.66676 2.68760 2.70843 2.72927 2.75010 2.77093 2.79177 2.81260 #&gt; [89] 2.83344 2.85427 2.87511 2.89594 2.91678 2.93761 2.95845 2.97928 tail(frac_d30mn, 48 * 2) #&gt; [1] 364.021 364.042 364.062 364.083 364.104 364.125 364.146 364.167 #&gt; [9] 364.187 364.208 364.229 364.250 364.271 364.292 364.312 364.333 #&gt; [17] 364.354 364.375 364.396 364.417 364.437 364.458 364.479 364.500 #&gt; [25] 364.521 364.542 364.562 364.583 364.604 364.625 364.646 364.667 #&gt; [33] 364.687 364.708 364.729 364.750 364.771 364.792 364.812 364.833 #&gt; [41] 364.854 364.875 364.896 364.917 364.937 364.958 364.979 365.000 #&gt; [49] 365.021 365.042 365.062 365.083 365.104 365.125 365.146 365.167 #&gt; [57] 365.187 365.208 365.229 365.250 365.271 365.292 365.312 365.333 #&gt; [65] 365.354 365.375 365.396 365.417 365.437 365.458 365.479 365.500 #&gt; [73] 365.521 365.542 365.562 365.583 365.604 365.625 365.646 365.667 #&gt; [81] 365.687 365.708 365.729 365.750 365.771 365.792 365.812 365.833 #&gt; [89] 365.854 365.875 365.896 365.917 365.937 365.958 365.979 366.000 # diferentes funções para gerar uma sequência an &lt;- c(1, 7, 2, 5, 3, 2) # gerando uma sequencia a partir de um número seq_len(length.out = 6) #&gt; [1] 1 2 3 4 5 6 # gerando uma sequência a partir de um número seq(6) #&gt; [1] 1 2 3 4 5 6 # de acordo com o tamanho do vetor gera-se uma sequencia seq(along = an) #&gt; [1] 1 2 3 4 5 6 seq(along = 0) # ! melhor opção para gerar sequencias do tamanho do vetor #&gt; [1] 1 seq(0) # ! cuidado, veja ?seq para entender a razão desse resultado inusitado #&gt; [1] 1 0 # conflito entre parâmetros # a &lt;-seq(from = -5, to = 5, by = 0.05, length.out=200) s5by &lt;- seq(from = -5, to = 5, by = 0.05) length(s5by) #&gt; [1] 201 tail(s5by) #&gt; [1] 4.75 4.80 4.85 4.90 4.95 5.00 s5len &lt;- seq(from = -5, to = 5, length.out = 200) length(s5len) #&gt; [1] 200 tail(s5len) #&gt; [1] 4.74874 4.79899 4.84925 4.89950 4.94975 5.00000 7.1.3.3 Sequências de números repetidos rep_t4 &lt;- rep(1:2, times = 4) rep_t4 #&gt; [1] 1 2 1 2 1 2 1 2 rep_e31 &lt;- rep(1:12, each = 31) rep_e31 #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [24] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [47] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 #&gt; [70] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #&gt; [93] 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 #&gt; [116] 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 #&gt; [139] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 #&gt; [162] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 #&gt; [185] 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #&gt; [208] 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 #&gt; [231] 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 #&gt; [254] 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 #&gt; [277] 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 #&gt; [300] 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 #&gt; [323] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 #&gt; [346] 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 #&gt; [369] 12 12 12 12 rep_t13 &lt;- rep(c(&quot;chuva&quot;, &quot;sol&quot;), times = c(1, 3)) rep_t13 #&gt; [1] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; rep_t13_t4 &lt;- rep(rep(c(&quot;chuva&quot;, &quot;sol&quot;), times = c(1, 3)), times = 4) rep_t13_t4 #&gt; [1] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; #&gt; [9] &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; &quot;chuva&quot; &quot;sol&quot; &quot;sol&quot; &quot;sol&quot; 7.1.4 Indexação de vetores Os elementos de um vetor são indexados e para acessá-los usamos a notação de índices do R. Podemos selecionar partes de um vetor por números (posição do elemento), caracteres (nome) e vetores lógicos. Através do operador [ podemos acessar ou filtrar elementos de um vetor. O operador colchete [ aplicado a um vetor retornará um vetor. Considere os seguintes vetores como exemplo: # vetor de chuva mensal para um dado ano prec &lt;- c(300, 150, 210, 12, 0, 0, 12, 22, 80, 100, 0, 280) meses &lt;- c(&quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;, &quot;Abr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;, &quot;Set&quot;, &quot;Out&quot;, &quot;Nov&quot;, &quot;Dez&quot;) names(prec) &lt;- meses prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # gráfico de barras barplot(prec) box() # temperatura do ar média mensal para um dado ano temp &lt;- c(25, 23.2, 22.5, 21, 19, 17.6, 18, 19.7, 21.3, 22, 24, 26.8) names(temp) &lt;- meses temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 plot(temp, type = &quot;o&quot;) Como selecionar o valor de chuva e temperatura só para janeiro? Usando a seguinte sintaxe: vetor[i] onde i representa os elementos a serem selecionados. 7.1.4.1 Indexação por vetores inteiros 7.1.4.1.1 Positivos Para selecionar o valor de chuva e temperatura só para janeiro, digitamos: prec_jan &lt;- prec[1] prec_jan #&gt; Jan #&gt; 300 temp_jan &lt;- temp[1] temp_jan #&gt; Jan #&gt; 25 Como selecionar os últimos valores dos vetores de chuva e temperatura? # vetor de temperatura do ar média mensal de um ano qualquer temp_dez &lt;- temp[length(temp)] temp_dez #&gt; Dez #&gt; 26.8 prec_dez &lt;- prec[length(prec)] prec_dez #&gt; Dez #&gt; 280 Como selecionar os valores de chuva do trimestre JJA e de temperatura para o trimestre DJF? sel_prec &lt;- c(6, 7, 8) # vetor de chuva JJA prec_jja &lt;- prec[sel_prec] prec_jja #&gt; Jun Jul Ago #&gt; 0 12 22 # total de chuva trimestral nesse ano prect_jja_tot &lt;- sum(prec_jja) prect_jja_tot #&gt; [1] 34 # vetor de temperatura DJF sel_temp &lt;- c(12, 1, 2) temp_djf &lt;- temp[sel_temp] temp_djf #&gt; Dez Jan Fev #&gt; 26.8 25.0 23.2 # temp média trimestral nesse ano temp_djf_med &lt;- mean(temp_djf) temp_djf_med #&gt; [1] 25 7.1.4.1.2 Negativos Como selecionar todos valores menos o primeiro e o último? # exceto o primeiro e ultimo prec[-c(1, length(prec))] #&gt; Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; 150 210 12 0 0 12 22 80 100 0 # exceto os 3 primeiros meses temp[-c(1:3)] #&gt; Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # exceto os 3 últimos meses temp[-c(length(temp):(length(temp) - 2))] #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 7.1.4.2 Indexação por nomes prec[&quot;Jan&quot;] #&gt; Jan #&gt; 300 prec[c(&quot;Dez&quot;, &quot;Fev&quot;, &quot;Jun&quot;)] #&gt; Dez Fev Jun #&gt; 280 150 0 7.1.4.3 Indexação por vetores lógicos Vamos criar um vetor lógico e usá-lo para exemplificar a seleção lógica de elementos de um vetor. vetor_l &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Abr&quot; &quot;Mai&quot; &quot;Jul&quot; &quot;Set&quot; &quot;Dez&quot; Os elementos de vetor_l correspondentes a TRUE foram selecionados. Aplicando-se a função sum() a um vetor lógico obtemos o total de elementos verdadeiros: sum(vetor_l) #&gt; [1] 6 Vamos considerar agora a seguinte forma do vetor lógico (vetor_l) e relembrar da coerção de vetores. # vetor lógico vetor_l &lt;- c(TRUE, FALSE) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Mar&quot; &quot;Mai&quot; &quot;Jul&quot; &quot;Set&quot; &quot;Nov&quot; vetor_l &lt;- c(TRUE, FALSE, FALSE) meses[vetor_l] #&gt; [1] &quot;Jan&quot; &quot;Abr&quot; &quot;Jul&quot; &quot;Out&quot; prec[c(TRUE, FALSE)] #&gt; Jan Mar Mai Jul Set Nov #&gt; 300 210 0 12 80 0 temp[c(rep(FALSE, 3), TRUE)] #&gt; Abr Ago Dez #&gt; 21.0 19.7 26.8 A indexação pode ser feita também por comparações: # vetor prec prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # teste para chuva &gt; 80 mm/mês prec &gt; 80 #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE # salvando resultado do teste above80 &lt;- prec &gt; 80 # extraindo valores atendidos ao teste prec[above80] #&gt; Jan Fev Mar Out Dez #&gt; 300 150 210 100 280 # teste para meses com chuva abaixo da média mensal (prec_med &lt;- mean(prec)) #&gt; [1] 97.1667 # salvando resultado do teste (below_avg &lt;- prec &lt; prec_med) #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE # extraindo valores que atendem a condição prec[below_avg] #&gt; Abr Mai Jun Jul Ago Set Nov #&gt; 12 0 0 12 22 80 0 # extraindo os 3 primeiros meses com prec abaixo da média prec[below_avg][1:3] #&gt; Abr Mai Jun #&gt; 12 0 0 # forma equivalente em uma linha só prec[prec &lt; mean(prec)][1:3] #&gt; Abr Mai Jun #&gt; 12 0 0 # teste para meses com prec diferente de zero prec[prec != 0] #&gt; Jan Fev Mar Abr Jul Ago Set Out Dez #&gt; 300 150 210 12 12 22 80 100 280 7.1.4.4 Indexação com múltiplas condições Nos exemplo acima vimos como buscar os os elementos de um vetor para apenas uma condição. Entretanto frequentemente precisamos testar mais condições. Por exemplo, para condições do tipo: \\(0.5 &lt; prec \\leq 100\\) \\(temp &lt; 5\\) ou \\(temp \\geq 25\\) precisamos usar os operadores relacionais: &amp; e &amp;&amp; (&quot;e“) | e || (&quot;ou“) A ordem das operações pode ser controladas por parênteses. Os operadores &amp; e | são vetorizados (retornam vetores de mesmo tamanho que os vetores testados). As diferenças entre os operadores são mostradas nos exemplos a seguir. # prec prec #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 300 150 210 12 0 0 12 22 80 100 0 280 # combinação de operador lógico e relacional below100 &lt;- prec &gt; 0 &amp; prec &lt;= 100 prec_cond1 &lt;- prec[below100] prec_cond1 #&gt; Abr Jul Ago Set Out #&gt; 12 12 22 80 100 A forma dupla (&amp;&amp; ou ||) compara somente um elemento de cada lado, enquanto a forma normal (&amp; e |), compara cada elemento dos vetores em cada lado. a &lt;- c(1, 1, 0, 1) b &lt;- c(2, 1, 0, 1) # forma normal verifica cada elemento de a e cada elemento de b a == 1 &amp; b == 1 #&gt; [1] FALSE TRUE FALSE TRUE # forma dupla verifica somente o primeiro elemento de a e o primeiro # elemento de b retornando somente um resultado a == 1 &amp;&amp; b == 1 #&gt; [1] FALSE Demostração da diferença entre &amp; e &amp;&amp;. a b a==1 b==1 a == 1 &amp; b == 1 a == 1 &amp;&amp; b == 1 1 2 TRUE FALSE FALSE FALSE 1 1 TRUE TRUE TRUE 0 0 FALSE FALSE FALSE 1 1 TRUE TRUE TRUE Podem haver mais que duas condições a serem testadas. As condições podem ser combinadas usando múltiplos &amp; ou |. As diferentes condições podem ser agrupadas por parênteses assim como operações matemáticas. Sem parênteses, a ordem das operações é semelhante a das operações matemáticas: PEMDAS: Parênteses &gt; Expoentes &gt; Multiplicação &gt; Divisão &gt; Adição e Subtração Onde &amp;é equivalente à multiplicação e | é equivalente à adição, logo e tem precedência sobre ou. # vetor de horas horas &lt;- 0:23 # vetor de temperaturas horárias tar_hor &lt;- c( 19.9, 19.8, 19.5, 19.4, 19.4, 19.3, 19.2, 19, 19.2, 19.5, 20.1, 20.6, 20.9, 21.8, 22.5, 22.6, 22.5, 22, 21.4, 20.1, 20, 19.8, 19.6, 19.4 ) # gráfico do varição horária da temperatura do ar plot(horas, tar_hor, type = &quot;o&quot;, pch = 20) # temperaturas noturnas abaixo de 20ºC (night_below20 &lt;- (horas &lt; 6 | horas &gt; 18) &amp; tar_hor &lt; 20) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE #&gt; [23] TRUE TRUE tar_hor[night_below20] #&gt; [1] 19.9 19.8 19.5 19.4 19.4 19.3 19.8 19.6 19.4 # destacando no gráfico points( x = horas[night_below20], y = tar_hor[night_below20], pch = 20, # tipo de símbolo para os ponts col = &quot;blue&quot;, # cor do símbolo cex = 2 ) # tamanho do ponto # temperaturas abaixo de 20ºC que não ocorreram a noite day_below20 &lt;- tar_hor &lt; 20 &amp; !night_below20 points(horas[day_below20], tar_hor[day_below20], pch = 20, col = &quot;red&quot;, cex = 2) # adicionando linha horizontal ao longo da temperatura = 20ºC abline(h = 20, col = &quot;gray&quot;) Vimos que a filtragem consiste em extrair elementos de um vetor que satisfaça uma (ou várias) condição(ões). Entretanto, em alguns casos, o interesse é na posição dentro do vetor na qual a condição é verdadeira Nós podemos localizar essas ocorrências usando a função which(): # prec sem nomes names(prec) &lt;- NULL # combinação de operador lógico e relacional below100 #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE which(below100) #&gt; Abr Jul Ago Set Out #&gt; 4 7 8 9 10 # qual os meses em que a chuva foi acima da media which(prec &gt; prec_med) #&gt; [1] 1 2 3 10 12 prec[which(prec &gt; prec_med)] #&gt; [1] 300 150 210 100 280 # Qual a temp quando a chuva ou a temp foi acima da media? sel &lt;- which(prec &gt; prec_med | !temp &lt; mean(temp)) sel #&gt; Jan Fev Mar Out Nov Dez #&gt; 1 2 3 10 11 12 prec[sel] #&gt; [1] 300 150 210 100 0 280 # quais posições do vetor prec não choveu which(prec == 0) #&gt; [1] 5 6 11 # quando ocorreu a prec max which(prec == max(prec)) #&gt; [1] 1 # equivalente a ... which.max(prec) #&gt; [1] 1 # seleciona só a primeira ocorrência! which.min(prec) #&gt; [1] 5 prec #&gt; [1] 300 150 210 12 0 0 12 22 80 100 0 280 Um outro operador útil para comparação entre vetores é o operador %in%, que pode ser interpretado como &quot;está contido em&quot;. O resultado é um vetor de mesmo tamanho que o vetor à esquerda do teste. # compare o tamanho dos vetores resultantes which(meses %in% c(&quot;JAN&quot;, &quot;Feb&quot;, &quot;Mar&quot;)) #&gt; [1] 3 # note a diferença which(c(&quot;JAN&quot;, &quot;Feb&quot;, &quot;Mar&quot;) %in% meses) #&gt; [1] 3 cond &lt;- names(temp) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;) quais &lt;- which(cond) quais #&gt; [1] 6 7 8 prec[cond] #&gt; [1] 0 12 22 prec[quais] #&gt; [1] 0 12 22 7.1.5 Substituição de elementos de um vetor # posição a ser alterada pos &lt;- 10 # valor da temperatura naquela posição old_temp &lt;- temp[pos] old_temp #&gt; Out #&gt; 22 # vetor de temperatura temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # substituição do valor original por um novo valor new_temp &lt;- 30 # alterando temperatura do mês de outubro temp[pos] &lt;- new_temp temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 30.0 24.0 26.8 A substituição também pode ser feita também pelo nome das variáveis. prec #&gt; [1] 300 150 210 12 0 0 12 22 80 100 0 280 prec[&quot;Mai&quot;] &lt;- 5 temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 30.0 24.0 26.8 temp[c(&quot;Mai&quot;, &quot;Jul&quot;)] &lt;- temp[c(&quot;Mai&quot;, &quot;Jul&quot;)] + 2 temp #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; 25.0 23.2 22.5 21.0 21.0 17.6 20.0 19.7 21.3 30.0 24.0 26.8 7.1.6 Criação de vetores com vector Outra forma de se criar vetores é através da função vector(). # criação de vetor v v &lt;- 3 v #&gt; [1] 3 # adicionando elementos v[2] &lt;- 100 v #&gt; [1] 3 100 v[5] &lt;- 6 v #&gt; [1] 3 100 NA NA 6 # adicionando elementos de vetores x &lt;- c(88, 5, 12, 13) x &lt;- c(x[1:3], 168, x[4]) # insere 168 antes do 13 x #&gt; [1] 88 5 12 168 13 # outra opção k &lt;- vector() class(k) #&gt; [1] &quot;logical&quot; # vetor k existe? ls() #&gt; [1] &quot;a&quot; &quot;above80&quot; &quot;an&quot; &quot;anos&quot; #&gt; [5] &quot;anos_dec&quot; &quot;a_sn&quot; &quot;b&quot; &quot;below100&quot; #&gt; [9] &quot;below_avg&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; &quot;meses&quot; #&gt; [21] &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; &quot;old_temp&quot; #&gt; [25] &quot;oper&quot; &quot;pcks&quot; &quot;pent&quot; &quot;pos&quot; #&gt; [29] &quot;prec&quot; &quot;prec_cond1&quot; &quot;prec_dez&quot; &quot;prec_jan&quot; #&gt; [33] &quot;prec_jja&quot; &quot;prec_med&quot; &quot;prect_jja_tot&quot; &quot;quais&quot; #&gt; [37] &quot;rblue&quot; &quot;rep_e31&quot; &quot;rep_t13&quot; &quot;rep_t13_t4&quot; #&gt; [41] &quot;rep_t4&quot; &quot;s5by&quot; &quot;s5len&quot; &quot;seco&quot; #&gt; [45] &quot;seco01&quot; &quot;sel&quot; &quot;sel_prec&quot; &quot;sel_temp&quot; #&gt; [49] &quot;seqn&quot; &quot;si_dec&quot; &quot;snum_b&quot; &quot;tar_hor&quot; #&gt; [53] &quot;temp&quot; &quot;temp_dez&quot; &quot;temp_djf&quot; &quot;temp_djf_med&quot; #&gt; [57] &quot;temp_jan&quot; &quot;v&quot; &quot;v1&quot; &quot;v_123&quot; #&gt; [61] &quot;v_123a&quot; &quot;v_123b&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [65] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [69] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [73] &quot;z&quot; # alocando o valor 45 no 3º elemento de k k[3] &lt;- 45 k #&gt; [1] NA NA 45 class(k) #&gt; [1] &quot;numeric&quot; # diminuindo o tamanho de k length(k) #&gt; [1] 3 length(k) &lt;- 2 k #&gt; [1] NA NA length(k) &lt;- 0 k #&gt; numeric(0) class(k) #&gt; [1] &quot;numeric&quot; is.null(k) #&gt; [1] FALSE # exemplo temp &lt;- c(25, 23.2, 22.5, 21, 19, 17.6, 18, 19.7, 21.3, 22, 24, 26.8) temp_orig &lt;- temp # mostrando o vetor temp temp #&gt; [1] 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 temp[] #&gt; [1] 25.0 23.2 22.5 21.0 19.0 17.6 18.0 19.7 21.3 22.0 24.0 26.8 # substituir todos elementos do vetor temp por um vetor com apenas um valor temp &lt;- 0 temp #&gt; [1] 0 # vamos redefinir temp e comparar o anterior com o obtido com o próximo # comando temp &lt;- temp_orig temp[1:length(temp)] &lt;- 0 temp #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 # qual diferença de x &lt;- 0 e x[] &lt;-0 ? temp &lt;- temp_orig temp[] &lt;- 0 temp #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 # Um vetor com tamanho pre-definido e do tipo numeric umvetor &lt;- vector(mode = &quot;numeric&quot;, length = 100) umvetor #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [36] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [71] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 # populando o vetor umvetor[1] &lt;- 10 umvetor[10] &lt;- 100 umvetor #&gt; [1] 10 0 0 0 0 0 0 0 0 100 0 0 0 0 0 0 0 #&gt; [18] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [35] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [52] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [69] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [86] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7.1.7 Vetores nulos e elementos faltantes Seja qual for a razão, ao realizar um experimento em condições reais sempre haverá situações em que não conhecemos o valor de uma determinada variável. Por exemplo, a série de uma variável meteorológica medida em estação de superfície, sempre ocorrem datas em que não há registro da variável. Falha instrumental, dado não coletado pelo observador, falta de energia, são causas inerentes de falhas em séries climáticas de longo prazo. No R dados faltantes são representados pela string NA. v1 &lt;- c(1:8, NA) v1 &gt; 5 # NA sai na resposta #&gt; [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE NA # teste lógico com o operador idêntico &quot;==&quot; v1 == NA #&gt; [1] NA NA NA NA NA NA NA NA NA # não funcionou, porque há funções específicas para vetores com NA onde_falta &lt;- is.na(v1) # função apropriada p/ checar se tem NAs faltante &lt;- which(is.na(v1)) v1[-faltante] #&gt; [1] 1 2 3 4 5 6 7 8 # ou v1[!onde_falta] #&gt; [1] 1 2 3 4 5 6 7 8 # vamos calcular a média de v1 sum(v1) / length(v1) #&gt; [1] NA # vamos remover valores NA sum(v1[-faltante]) / length(v1[-faltante]) #&gt; [1] 4.5 sum(v1[!onde_falta]) / length(v1[!onde_falta]) #&gt; [1] 4.5 # mas o R possui a função mean mean(v1) #&gt; [1] NA # não retornou o que desejamos, removendo as posicoes dos dados faltantes mean(v1[-faltante]) #&gt; [1] 4.5 # ok, mas olhando o help ... # ?mean mean(v1, na.rm = TRUE) #&gt; [1] 4.5 # definir como faltante todos elementos de v1 v1[] &lt;- NA v1 #&gt; [1] NA NA NA NA NA NA NA NA NA length(v1) #&gt; [1] 9 # vetor com dados faltantes indicados por -999 # substituir onde é -999 por NA x &lt;- c(-999, 10, 15, -999, 50) x == -999 #&gt; [1] TRUE FALSE FALSE TRUE FALSE x[x == -999] &lt;- NA # total de dados faltantes sum(!is.na(x)) #&gt; [1] 3 7.1.8 Diferença entre NA e NULL O NULL é um tipo de dado especial do R. # v1 existe ? ls() #&gt; [1] &quot;a&quot; &quot;above80&quot; &quot;an&quot; &quot;anos&quot; #&gt; [5] &quot;anos_dec&quot; &quot;a_sn&quot; &quot;b&quot; &quot;below100&quot; #&gt; [9] &quot;below_avg&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;faltante&quot; &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; #&gt; [21] &quot;meses&quot; &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; #&gt; [25] &quot;old_temp&quot; &quot;onde_falta&quot; &quot;oper&quot; &quot;pcks&quot; #&gt; [29] &quot;pent&quot; &quot;pos&quot; &quot;prec&quot; &quot;prec_cond1&quot; #&gt; [33] &quot;prec_dez&quot; &quot;prec_jan&quot; &quot;prec_jja&quot; &quot;prec_med&quot; #&gt; [37] &quot;prect_jja_tot&quot; &quot;quais&quot; &quot;rblue&quot; &quot;rep_e31&quot; #&gt; [41] &quot;rep_t13&quot; &quot;rep_t13_t4&quot; &quot;rep_t4&quot; &quot;s5by&quot; #&gt; [45] &quot;s5len&quot; &quot;seco&quot; &quot;seco01&quot; &quot;sel&quot; #&gt; [49] &quot;sel_prec&quot; &quot;sel_temp&quot; &quot;seqn&quot; &quot;si_dec&quot; #&gt; [53] &quot;snum_b&quot; &quot;tar_hor&quot; &quot;temp&quot; &quot;temp_dez&quot; #&gt; [57] &quot;temp_djf&quot; &quot;temp_djf_med&quot; &quot;temp_jan&quot; &quot;temp_orig&quot; #&gt; [61] &quot;umvetor&quot; &quot;v&quot; &quot;v1&quot; &quot;v_123&quot; #&gt; [65] &quot;v_123a&quot; &quot;v_123b&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [69] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [73] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [77] &quot;z&quot; exists(&quot;v1&quot;) #&gt; [1] TRUE # vamos anular todo v1 v1 &lt;- NULL ls() #&gt; [1] &quot;a&quot; &quot;above80&quot; &quot;an&quot; &quot;anos&quot; #&gt; [5] &quot;anos_dec&quot; &quot;a_sn&quot; &quot;b&quot; &quot;below100&quot; #&gt; [9] &quot;below_avg&quot; &quot;chuva&quot; &quot;cond&quot; &quot;cte&quot; #&gt; [13] &quot;day_below20&quot; &quot;dda&quot; &quot;decd&quot; &quot;desc&quot; #&gt; [17] &quot;faltante&quot; &quot;frac_d30mn&quot; &quot;horas&quot; &quot;k&quot; #&gt; [21] &quot;meses&quot; &quot;months&quot; &quot;new_temp&quot; &quot;night_below20&quot; #&gt; [25] &quot;old_temp&quot; &quot;onde_falta&quot; &quot;oper&quot; &quot;pcks&quot; #&gt; [29] &quot;pent&quot; &quot;pos&quot; &quot;prec&quot; &quot;prec_cond1&quot; #&gt; [33] &quot;prec_dez&quot; &quot;prec_jan&quot; &quot;prec_jja&quot; &quot;prec_med&quot; #&gt; [37] &quot;prect_jja_tot&quot; &quot;quais&quot; &quot;rblue&quot; &quot;rep_e31&quot; #&gt; [41] &quot;rep_t13&quot; &quot;rep_t13_t4&quot; &quot;rep_t4&quot; &quot;s5by&quot; #&gt; [45] &quot;s5len&quot; &quot;seco&quot; &quot;seco01&quot; &quot;sel&quot; #&gt; [49] &quot;sel_prec&quot; &quot;sel_temp&quot; &quot;seqn&quot; &quot;si_dec&quot; #&gt; [53] &quot;snum_b&quot; &quot;tar_hor&quot; &quot;temp&quot; &quot;temp_dez&quot; #&gt; [57] &quot;temp_djf&quot; &quot;temp_djf_med&quot; &quot;temp_jan&quot; &quot;temp_orig&quot; #&gt; [61] &quot;umvetor&quot; &quot;v&quot; &quot;v1&quot; &quot;v_123&quot; #&gt; [65] &quot;v_123a&quot; &quot;v_123b&quot; &quot;v2&quot; &quot;v3&quot; #&gt; [69] &quot;vetor&quot; &quot;vetor_char&quot; &quot;vetor_int&quot; &quot;vetor_l&quot; #&gt; [73] &quot;vetor_log&quot; &quot;vetor_num&quot; &quot;x&quot; &quot;y&quot; #&gt; [77] &quot;z&quot; v1 #&gt; NULL # NULL vetor1 &lt;- c() vetor2 &lt;- NULL is.null(c(vetor1, vetor2)) #&gt; [1] TRUE # vetor1 e vetor2 são equivalentes? identical(vetor1, vetor2) #&gt; [1] TRUE # remoção de elementos de um vetor com NULL a &lt;- c(10, 2, NA, 20) a #&gt; [1] 10 2 NA 20 typeof(a) #&gt; [1] &quot;double&quot; # remover de a o dado faltante a &lt;- a[!is.na(a)] a #&gt; [1] 10 2 20 # é possível remover um elemento com o NULL? a[length(a)] &lt;- NULL #&gt; Error in a[length(a)] &lt;- NULL: replacement has length zero a #&gt; [1] 10 2 20 a &lt;- a[-length(a)] a #&gt; [1] 10 2 typeof(a) #&gt; [1] &quot;double&quot; # anulando a a &lt;- NULL # qual modo de um objeto nulo? typeof(a) #&gt; [1] &quot;NULL&quot; # qual modo de NA? b &lt;- NA b #&gt; [1] NA typeof(b) #&gt; [1] &quot;logical&quot; length(a) #&gt; [1] 0 length(b) #&gt; [1] 1 "],
["matriz.html", "7.2 Matriz", " 7.2 Matriz Vetores são dados unidimensionais. Vetores multidimensionais são denominados arranjos (tradução do termo em inglês array). As matrizes são um caso especial de array em que o número de dimensões é igual a 2, uma dimensão corresponde as linhas e a outra as colunas. Os dados armazenados em uma matriz só podem ser de um tipo de dado (ou numeric, ou character, por exemplo). 7.2.1 Criação de matrizes 7.2.1.1 Função matrix() Uma forma mais clara de se criar uma matriz é usando a função matrix(). Ao aplicarmos a função matrix() a um vetor sem especificar nenhum argumento ela produz uma matriz de uma coluna. # atribuindo novas dimensões ao vetor m &lt;- matrix(vetor) # matriz de uma coluna m #&gt; [,1] #&gt; [1,] 0 #&gt; [2,] 1 #&gt; [3,] -1 #&gt; [4,] -2 #&gt; [5,] 3 #&gt; [6,] 5 #&gt; [7,] -5 Se desejamos construir uma matriz com 3 linhas e 4 colunas a partir do vetor vetor podemos fazer da seguinte forma: # criando a matriz gerada com dim mat &lt;- matrix(vetor, nrow = 3, ncol = 4) #&gt; Warning in matrix(vetor, nrow = 3, ncol = 4): data length [7] is not a sub- #&gt; multiple or multiple of the number of rows [3] mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 -2 -5 -1 #&gt; [2,] 1 3 0 -2 #&gt; [3,] -1 5 1 3 # não há necessidade de especificar ambos ncol e nrow mat &lt;- matrix(vetor, nrow = 3) #&gt; Warning in matrix(vetor, nrow = 3): data length [7] is not a sub-multiple #&gt; or multiple of the number of rows [3] mat #&gt; [,1] [,2] [,3] #&gt; [1,] 0 -2 -5 #&gt; [2,] 1 3 0 #&gt; [3,] -1 5 1 No exemplo a seguir os dados do vetor aparecem distribuídos ao longo das linhas e não das colunas como no caso acima. Nós definimos isso com o argumento byrow = TRUE da função matrix(): mat &lt;- matrix(vetor, ncol = 4, byrow = TRUE) #&gt; Warning in matrix(vetor, ncol = 4, byrow = TRUE): data length [7] is not a #&gt; sub-multiple or multiple of the number of rows [2] mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 1 -1 -2 #&gt; [2,] 3 5 -5 0 7.2.2 Nomes das linhas e colunas de uma matriz Nas matrizes, assim como nos vetores, também é possível dar nomes aos elementos para tornar a leitura da informação mais clara. Vamos usar os vetores de temperatura mensal dos anos de 1990:1992para construir uma matriz com os meses ao longo das colunas e os anos ao longo das linhas. # temperatura do ar média mensal do ano de 1990 temp90 &lt;- c(25, 23.2, 22.5, 21, 19, 17.6, 18, 19.7, 21.3, 22, 24, 26.8) # temperatura do ar média mensal do ano de 1991 temp91 &lt;- c(24.89, 24.07, 23.56, 23.11, 18.29, 18.22, 16.72, 19.37, 20.08, 21.45, 26.61, 25.99) # temperatura do ar média mensal do ano de 1992 temp92 &lt;- c(23.2, 26.61, 18, 23.11, 26.8, 21.3, 18.22, 21.45, 19.7, 22.5, 24.07, 20.08) # vetor com as temperaturas dos 3 anos vtemp &lt;- c(temp90, temp91, temp92) vtemp #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 # arranjar matrix com meses ao longo das colunas e anos ao longo das linhas temp_mat &lt;- matrix(vtemp, ncol = 12, byrow = TRUE) temp_mat #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; [1,] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [2,] 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; [3,] 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; [1,] 26.80 #&gt; [2,] 25.99 #&gt; [3,] 20.08 # cópia da matriz temp_mat (sem nomes) temp_matO &lt;- temp_mat Atribuindo nomes às linhas (rownames()) e colunas (colnames()) da matriz criada dos vetores de temperatura mensal (temp_mat). # atribuindo nomes as colunas e linhas da temp_mat rownames(temp_mat) &lt;- c(&quot;ano1990&quot;, &quot;ano1991&quot;, &quot;ano1992&quot;) colnames(temp_mat) &lt;- c(&quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;, &quot;Abr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;, &quot;Set&quot;, &quot;Out&quot;, &quot;Nov&quot;, &quot;Dez&quot;) temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 7.2.3 Indexação de matrizes Como acessamos o valor de temperatura de maio de 1991 na matriz temp_mat? temp_mat # matriz de temperaturas com nomes #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 temp_matO # matriz de temperaturas sem nomes #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; [1,] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [2,] 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; [3,] 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; [1,] 26.80 #&gt; [2,] 25.99 #&gt; [3,] 20.08 # qual a linha do ano de 1991 linha &lt;- 2 # qual a coluna do mês de maio coluna &lt;- 5 # extraindo temp_mat[linha, coluna] #&gt; [1] 18.29 # ou usando os nomes temp_mat[&quot;ano1991&quot;, &quot;Mai&quot;] #&gt; [1] 18.29 Com o operador [ podemos usar todos os esquemas de indexação vistos em vetores. # temperaturas de todos janeiros temp_mat[, 1] #&gt; ano1990 ano1991 ano1992 #&gt; 25.00 24.89 23.20 temp_mat[, &quot;Jan&quot;] #&gt; ano1990 ano1991 ano1992 #&gt; 25.00 24.89 23.20 # só as temperaturas de 1990 e 1993 temp_mat[-2, ] #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez #&gt; ano1990 25.0 23.20 22.5 21.00 19.0 17.6 18.00 19.70 21.3 22.0 24.00 26.80 #&gt; ano1992 23.2 26.61 18.0 23.11 26.8 21.3 18.22 21.45 19.7 22.5 24.07 20.08 # só as temperaturas dos verões temp_mat[, c(12, 1, 2)] #&gt; Dez Jan Fev #&gt; ano1990 26.80 25.00 23.20 #&gt; ano1991 25.99 24.89 24.07 #&gt; ano1992 20.08 23.20 26.61 # invertendo ordem das colunas temp_mat[, ncol(temp_mat):1] #&gt; Dez Nov Out Set Ago Jul Jun Mai Abr Mar Fev #&gt; ano1990 26.80 24.00 22.00 21.30 19.70 18.00 17.60 19.00 21.00 22.50 23.20 #&gt; ano1991 25.99 26.61 21.45 20.08 19.37 16.72 18.22 18.29 23.11 23.56 24.07 #&gt; ano1992 20.08 24.07 22.50 19.70 21.45 18.22 21.30 26.80 23.11 18.00 26.61 #&gt; Jan #&gt; ano1990 25.00 #&gt; ano1991 24.89 #&gt; ano1992 23.20 # invertendo ordem das colunas e das linhas temp_mat[3:1, 12:1] #&gt; Dez Nov Out Set Ago Jul Jun Mai Abr Mar Fev #&gt; ano1992 20.08 24.07 22.50 19.70 21.45 18.22 21.30 26.80 23.11 18.00 26.61 #&gt; ano1991 25.99 26.61 21.45 20.08 19.37 16.72 18.22 18.29 23.11 23.56 24.07 #&gt; ano1990 26.80 24.00 22.00 21.30 19.70 18.00 17.60 19.00 21.00 22.50 23.20 #&gt; Jan #&gt; ano1992 23.20 #&gt; ano1991 24.89 #&gt; ano1990 25.00 # invertendo ordem das colunas e das linhas temp_mat[c(2, 1, 3), c(6:1, 12, 10:8)] #&gt; Jun Mai Abr Mar Fev Jan Dez Out Set Ago #&gt; ano1991 18.22 18.29 23.11 23.56 24.07 24.89 25.99 21.45 20.08 19.37 #&gt; ano1990 17.60 19.00 21.00 22.50 23.20 25.00 26.80 22.00 21.30 19.70 #&gt; ano1992 21.30 26.80 23.11 18.00 26.61 23.20 20.08 22.50 19.70 21.45 # só as temperaturas dos invernos temp_mat[, colnames(temp_mat) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;)] #&gt; Jun Jul Ago #&gt; ano1990 17.60 18.00 19.70 #&gt; ano1991 18.22 16.72 19.37 #&gt; ano1992 21.30 18.22 21.45 # exceto as temperaturas dos invernos temp_mat[, -which(colnames(temp_mat) %in% c(&quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;))] #&gt; Jan Fev Mar Abr Mai Set Out Nov Dez #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 21.30 22.00 24.00 26.80 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 20.08 21.45 26.61 25.99 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 19.70 22.50 24.07 20.08 # seleção de colunas intercaladas da matriz: mês sim, mês nao temp_mat[, c(TRUE, FALSE)] #&gt; Jan Mar Mai Jul Set Nov #&gt; ano1990 25.00 22.50 19.00 18.00 21.30 24.00 #&gt; ano1991 24.89 23.56 18.29 16.72 20.08 26.61 #&gt; ano1992 23.20 18.00 26.80 18.22 19.70 24.07 # 2 meses sim, 1 mes não temp_mat[, c(TRUE, TRUE, FALSE)] #&gt; Jan Fev Abr Mai Jul Ago Out Nov #&gt; ano1990 25.00 23.20 21.00 19.00 18.00 19.70 22.00 24.00 #&gt; ano1991 24.89 24.07 23.11 18.29 16.72 19.37 21.45 26.61 #&gt; ano1992 23.20 26.61 23.11 26.80 18.22 21.45 22.50 24.07 Podemos fazer uso do operador [ de forma aninhada: temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 temp_mat[, 1:6] #&gt; Jan Fev Mar Abr Mai Jun #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 temp_mat[, 1:6][&quot;ano1991&quot;, ] #&gt; Jan Fev Mar Abr Mai Jun #&gt; 24.89 24.07 23.56 23.11 18.29 18.22 temp_mat[, 1:6][&quot;ano1991&quot;, ][2:4] #&gt; Fev Mar Abr #&gt; 24.07 23.56 23.11 Podemos substituir valores de uma submatriz da matriz: M &lt;- temp_mat M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 # 1990 e 1992 os meses de jan e dez M[c(1, 3), c(1, 12)] #&gt; Jan Dez #&gt; ano1990 25.0 26.80 #&gt; ano1992 23.2 20.08 # matriz com novos valores matrix(c(21, 22, 23, 24), ncol = 2) #&gt; [,1] [,2] #&gt; [1,] 21 23 #&gt; [2,] 22 24 # substituindo M[c(1, 3), c(1, 12)] &lt;- matrix(c(21, 22, 23, 24), ncol = 2) M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 21.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 22.00 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 23.00 #&gt; ano1991 25.99 #&gt; ano1992 24.00 7.2.4 Número de linhas e colunas de uma matriz M #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 21.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 22.00 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 23.00 #&gt; ano1991 25.99 #&gt; ano1992 24.00 ncol(temp_mat) #&gt; [1] 12 nrow(temp_mat) #&gt; [1] 3 dim(temp_mat) #&gt; [1] 3 12 Existem funções específicas para saber a coluna e a linha de cada elemento de uma matriz. # colunas de cada elemento da matriz col(temp_mat) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 11 12 #&gt; [2,] 1 2 3 4 5 6 7 8 9 10 11 12 #&gt; [3,] 1 2 3 4 5 6 7 8 9 10 11 12 # linhas de cada elemento da matriz row(temp_mat) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; [1,] 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [2,] 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [3,] 3 3 3 3 3 3 3 3 3 3 3 3 7.2.5 Adição de linhas e colunas a uma matriz Na construção de um vetor concatenaram-se valores com a função c(). A concatenação por linhas ou colunas em uma matriz pode ser feita com as funções rbind() e cbind(), respectivamente. No exemplo abaixo concatenam-se vetores de temperaturas mensais de 3 anos (ver seção 7.2.2), primeiro por linhas e depois por colunas. (temp_mat_lin &lt;- rbind(temp90, temp91, temp92)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #&gt; temp90 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; temp91 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; temp92 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; [,12] #&gt; temp90 26.80 #&gt; temp91 25.99 #&gt; temp92 20.08 (temp_mat_col &lt;- cbind(temp90, temp91, temp92)) #&gt; temp90 temp91 temp92 #&gt; [1,] 25.0 24.89 23.20 #&gt; [2,] 23.2 24.07 26.61 #&gt; [3,] 22.5 23.56 18.00 #&gt; [4,] 21.0 23.11 23.11 #&gt; [5,] 19.0 18.29 26.80 #&gt; [6,] 17.6 18.22 21.30 #&gt; [7,] 18.0 16.72 18.22 #&gt; [8,] 19.7 19.37 21.45 #&gt; [9,] 21.3 20.08 19.70 #&gt; [10,] 22.0 21.45 22.50 #&gt; [11,] 24.0 26.61 24.07 #&gt; [12,] 26.8 25.99 20.08 7.2.6 Matriz transposta e diagonal A primeira entre as diversas funções de álgebra matricial no R é a transposta t(). temp_mat #&gt; Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov #&gt; ano1990 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; ano1991 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 26.61 #&gt; ano1992 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 22.50 24.07 #&gt; Dez #&gt; ano1990 26.80 #&gt; ano1991 25.99 #&gt; ano1992 20.08 t(temp_mat) #&gt; ano1990 ano1991 ano1992 #&gt; Jan 25.0 24.89 23.20 #&gt; Fev 23.2 24.07 26.61 #&gt; Mar 22.5 23.56 18.00 #&gt; Abr 21.0 23.11 23.11 #&gt; Mai 19.0 18.29 26.80 #&gt; Jun 17.6 18.22 21.30 #&gt; Jul 18.0 16.72 18.22 #&gt; Ago 19.7 19.37 21.45 #&gt; Set 21.3 20.08 19.70 #&gt; Out 22.0 21.45 22.50 #&gt; Nov 24.0 26.61 24.07 #&gt; Dez 26.8 25.99 20.08 # diagonal diag(temp_mat) #&gt; [1] 25.00 24.07 18.00 Operações matriciais adicionais são apresentadas no Apêndice ??. 7.2.7 Conversão de matriz para vetor Frequentemente é mais conveniente trabalhar com um vetor do que com uma matriz, por isso precisamos saber como fazer o caminho inverso. Quando criamos uma matriz (p. ex.: temp_mat) no início da seção ela foi baseada em um vetor (vtemp). Como fazemos para voltar aquele vetor original a partir da matriz? temp_mat[1:nrow(temp_mat) * ncol(temp_mat) ] #&gt; [1] 23.11 21.45 20.08 # vetor de temperaturas vtemp &lt;- temp_mat[1:(ncol(temp_mat) * nrow(temp_mat))] vtemp #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # outra forma de converte temp_mat para vetor c(temp_mat) #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # função formal para converter as.vector(temp_mat) #&gt; [1] 25.00 24.89 23.20 23.20 24.07 26.61 22.50 23.56 18.00 21.00 23.11 #&gt; [12] 23.11 19.00 18.29 26.80 17.60 18.22 21.30 18.00 16.72 18.22 19.70 #&gt; [23] 19.37 21.45 21.30 20.08 19.70 22.00 21.45 22.50 24.00 26.61 24.07 #&gt; [34] 26.80 25.99 20.08 # para desmanchar a matriz com os elementos seguindo a ordem das linhas c(t(temp_mat)) #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 as.vector(t(temp_mat)) #&gt; [1] 25.00 23.20 22.50 21.00 19.00 17.60 18.00 19.70 21.30 22.00 24.00 #&gt; [12] 26.80 24.89 24.07 23.56 23.11 18.29 18.22 16.72 19.37 20.08 21.45 #&gt; [23] 26.61 25.99 23.20 26.61 18.00 23.11 26.80 21.30 18.22 21.45 19.70 #&gt; [34] 22.50 24.07 20.08 # serie temporal de temp_mat stemp &lt;- c(t(temp_mat)) plot(stemp, type = &quot;o&quot;) # criar matriz com colunas temp e meses 1:12 cbind(rep(1:12, nrow(temp_mat)), stemp) #&gt; stemp #&gt; [1,] 1 25.00 #&gt; [2,] 2 23.20 #&gt; [3,] 3 22.50 #&gt; [4,] 4 21.00 #&gt; [5,] 5 19.00 #&gt; [6,] 6 17.60 #&gt; [7,] 7 18.00 #&gt; [8,] 8 19.70 #&gt; [9,] 9 21.30 #&gt; [10,] 10 22.00 #&gt; [11,] 11 24.00 #&gt; [12,] 12 26.80 #&gt; [13,] 1 24.89 #&gt; [14,] 2 24.07 #&gt; [15,] 3 23.56 #&gt; [16,] 4 23.11 #&gt; [17,] 5 18.29 #&gt; [18,] 6 18.22 #&gt; [19,] 7 16.72 #&gt; [20,] 8 19.37 #&gt; [21,] 9 20.08 #&gt; [22,] 10 21.45 #&gt; [23,] 11 26.61 #&gt; [24,] 12 25.99 #&gt; [25,] 1 23.20 #&gt; [26,] 2 26.61 #&gt; [27,] 3 18.00 #&gt; [28,] 4 23.11 #&gt; [29,] 5 26.80 #&gt; [30,] 6 21.30 #&gt; [31,] 7 18.22 #&gt; [32,] 8 21.45 #&gt; [33,] 9 19.70 #&gt; [34,] 10 22.50 #&gt; [35,] 11 24.07 #&gt; [36,] 12 20.08 # dados de temp e meses tempdat &lt;- cbind(1:12, stemp) # plot da temperatura pelos meses (os meses repetem) plot( tempdat, type = &quot;p&quot;, # tipo de grafico: pontos pch = 20, # codigo numérico do simbolo do ponto col = rep(1:3, each = ncol(temp_mat)), # cores dos pontos cex = rep(seq(1, 2, by = 0.5), each = ncol(temp_mat)), # aumenta tamanho dos pontos las = 1, # orientação dos labels dos eixos perpendiculares ao eixo ylab = expression(Tar ~ (degree ~ C)), # label da variável y xlab = &quot;meses&quot;, # label da variavel x main = &quot;Temperatura mensal (1990-1992)&quot; # título ) # end plot # para entender a variação nas cores e símbolos usadas no gráfico cbind( meses = 1:12, temp = stemp, cores = rep(1:3, each = ncol(temp_mat)), # cores simb_tam = rep(seq(1, 2, by = 0.5), each = ncol(temp_mat)) ) # tamanho dos símbolos #&gt; meses temp cores simb_tam #&gt; [1,] 1 25.00 1 1.0 #&gt; [2,] 2 23.20 1 1.0 #&gt; [3,] 3 22.50 1 1.0 #&gt; [4,] 4 21.00 1 1.0 #&gt; [5,] 5 19.00 1 1.0 #&gt; [6,] 6 17.60 1 1.0 #&gt; [7,] 7 18.00 1 1.0 #&gt; [8,] 8 19.70 1 1.0 #&gt; [9,] 9 21.30 1 1.0 #&gt; [10,] 10 22.00 1 1.0 #&gt; [11,] 11 24.00 1 1.0 #&gt; [12,] 12 26.80 1 1.0 #&gt; [13,] 1 24.89 2 1.5 #&gt; [14,] 2 24.07 2 1.5 #&gt; [15,] 3 23.56 2 1.5 #&gt; [16,] 4 23.11 2 1.5 #&gt; [17,] 5 18.29 2 1.5 #&gt; [18,] 6 18.22 2 1.5 #&gt; [19,] 7 16.72 2 1.5 #&gt; [20,] 8 19.37 2 1.5 #&gt; [21,] 9 20.08 2 1.5 #&gt; [22,] 10 21.45 2 1.5 #&gt; [23,] 11 26.61 2 1.5 #&gt; [24,] 12 25.99 2 1.5 #&gt; [25,] 1 23.20 3 2.0 #&gt; [26,] 2 26.61 3 2.0 #&gt; [27,] 3 18.00 3 2.0 #&gt; [28,] 4 23.11 3 2.0 #&gt; [29,] 5 26.80 3 2.0 #&gt; [30,] 6 21.30 3 2.0 #&gt; [31,] 7 18.22 3 2.0 #&gt; [32,] 8 21.45 3 2.0 #&gt; [33,] 9 19.70 3 2.0 #&gt; [34,] 10 22.50 3 2.0 #&gt; [35,] 11 24.07 3 2.0 #&gt; [36,] 12 20.08 3 2.0 "],
["arranjo.html", "7.3 Arranjo", " 7.3 Arranjo Arranjo é uma estrutura de dados multidimensional. A matriz é um caso particular de arranjo com 2 dimensões: linhas e colunas. Mas podemos ter dados com n dimensões. Por exemplo, imagine o campo espacial representado por uma grade de espaçamento horizontal regular de uma variável meteorológica. Nessa situação podemos usar uma matriz com valores de temperatura, onde as colunas representam as longitudes e as linhas as latitudes dos pontos da grade. Em um dados tempo, a matriz da variável com valores de temperatura do ar, por exemplo, representa o estado térmico espacial daquele momento. Então podemos dizer que esse arranjo possui 3 dimensões: latitude (linha), longitude (coluna) e tempo (camadas). 7.3.1 Criação Suponha que os campos espaciais médios mensais de temperatura sejam dados pelo vetor temp_vetor abaixo. temp_vetor &lt;- c( 18, 24, 19, 23, 19, 27, 24, 18, 13, 20, 25, 19, 18, 22, 17, 9, 17, 22, 13, 19, 29, 18, 19, 18, 11, 18, 19, 17, 13, 17, 26, 21, 22, 20, 14, 17 ) O vetor temp_vetor pode ser convertido em um arranjo dos campos espaciais usando a função array(), com o argumento dim especificando as dimensões. temp_array &lt;- array(data = temp_vetor, dim = c(3, 4, 3)) temp_array #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 18 23 24 20 #&gt; [2,] 24 19 18 25 #&gt; [3,] 19 27 13 19 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 18 9 13 18 #&gt; [2,] 22 17 19 19 #&gt; [3,] 17 22 29 18 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 11 17 26 20 #&gt; [2,] 18 13 21 14 #&gt; [3,] 19 17 22 17 dim(temp_array) #&gt; [1] 3 4 3 class(temp_array) #&gt; [1] &quot;array&quot; O arranjo também pode ter atributos, como o nomes das linhas, colunas e camadas. colnames(temp_array) &lt;- -(45:42) rownames(temp_array) &lt;- -(19:21) # nomes das dimensões dimnames(temp_array) #&gt; [[1]] #&gt; [1] &quot;-19&quot; &quot;-20&quot; &quot;-21&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;-45&quot; &quot;-44&quot; &quot;-43&quot; &quot;-42&quot; #&gt; #&gt; [[3]] #&gt; NULL # nomes para camadas dimnames(temp_array)[[3]] &lt;- c(&quot;Jan&quot;, &quot;Fev&quot;, &quot;Mar&quot;) temp_array #&gt; , , Jan #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 18 23 24 20 #&gt; -20 24 19 18 25 #&gt; -21 19 27 13 19 #&gt; #&gt; , , Fev #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 18 9 13 18 #&gt; -20 22 17 19 19 #&gt; -21 17 22 29 18 #&gt; #&gt; , , Mar #&gt; #&gt; -45 -44 -43 -42 #&gt; -19 11 17 26 20 #&gt; -20 18 13 21 14 #&gt; -21 19 17 22 17 7.3.2 Indexação Os mesmo procedimentos de indexação usados para matriz são aplicados a um arranjo (A), mas com a seguinte convenção de índices A[linha, coluna, camada]. # serie temporal do 1º ponto temp_array[1, 1, ] #&gt; Jan Fev Mar #&gt; 18 18 11 temp_array[&quot;-19&quot;, &quot;-45&quot;, ] #&gt; Jan Fev Mar #&gt; 18 18 11 # para 1a faixa de latitude (-19), # os valores de temp das longitudes em todos tempos temp_array[1, , ] #&gt; Jan Fev Mar #&gt; -45 18 18 11 #&gt; -44 23 9 17 #&gt; -43 24 13 26 #&gt; -42 20 18 20 # para 2a faixa de longitude (-44), todas longitudes e tempos temp_array[, 2, ] #&gt; Jan Fev Mar #&gt; -19 23 9 17 #&gt; -20 19 17 13 #&gt; -21 27 22 17 # média meridional colMeans(temp_array[, 2, ]) #&gt; Jan Fev Mar #&gt; 23.0000 16.0000 15.6667 # subdominio &quot;espacial&quot; temp_array[2:3, 2:3, ] #&gt; , , Jan #&gt; #&gt; -44 -43 #&gt; -20 19 18 #&gt; -21 27 13 #&gt; #&gt; , , Fev #&gt; #&gt; -44 -43 #&gt; -20 17 19 #&gt; -21 22 29 #&gt; #&gt; , , Mar #&gt; #&gt; -44 -43 #&gt; -20 13 21 #&gt; -21 17 22 # média espacial do 1o mês mean(temp_array[, , 1]) #&gt; [1] 20.75 # média espacial do segundo mês mean(temp_array[, , &quot;Jan&quot;]) #&gt; [1] 20.75 # demanchando o arranjo (conversão para vetor) c(temp_array) #&gt; [1] 18 24 19 23 19 27 24 18 13 20 25 19 18 22 17 9 17 22 13 19 29 18 19 #&gt; [24] 18 11 18 19 17 13 17 26 21 22 20 14 17 c(temp_array[, , 1]) #&gt; [1] 18 24 19 23 19 27 24 18 13 20 25 19 # para entender a forma como a matriz é convertida para vetor mat_temp &lt;- cbind( mes = rep(1:3, each = 20), elemat = rep(1:20, times = 6), valores = c(temp_array), elearr = 1:(cumprod(dim(temp_array))[3]) ) #&gt; Warning in cbind(mes = rep(1:3, each = 20), elemat = rep(1:20, times = #&gt; 6), : number of rows of result is not a multiple of vector length (arg 3) mat_temp #&gt; mes elemat valores elearr #&gt; [1,] 1 1 18 1 #&gt; [2,] 1 2 24 2 #&gt; [3,] 1 3 19 3 #&gt; [4,] 1 4 23 4 #&gt; [5,] 1 5 19 5 #&gt; [6,] 1 6 27 6 #&gt; [7,] 1 7 24 7 #&gt; [8,] 1 8 18 8 #&gt; [9,] 1 9 13 9 #&gt; [10,] 1 10 20 10 #&gt; [11,] 1 11 25 11 #&gt; [12,] 1 12 19 12 #&gt; [13,] 1 13 18 13 #&gt; [14,] 1 14 22 14 #&gt; [15,] 1 15 17 15 #&gt; [16,] 1 16 9 16 #&gt; [17,] 1 17 17 17 #&gt; [18,] 1 18 22 18 #&gt; [19,] 1 19 13 19 #&gt; [20,] 1 20 19 20 #&gt; [21,] 2 1 29 21 #&gt; [22,] 2 2 18 22 #&gt; [23,] 2 3 19 23 #&gt; [24,] 2 4 18 24 #&gt; [25,] 2 5 11 25 #&gt; [26,] 2 6 18 26 #&gt; [27,] 2 7 19 27 #&gt; [28,] 2 8 17 28 #&gt; [29,] 2 9 13 29 #&gt; [30,] 2 10 17 30 #&gt; [31,] 2 11 26 31 #&gt; [32,] 2 12 21 32 #&gt; [33,] 2 13 22 33 #&gt; [34,] 2 14 20 34 #&gt; [35,] 2 15 14 35 #&gt; [36,] 2 16 17 36 #&gt; [37,] 2 17 18 1 #&gt; [38,] 2 18 24 2 #&gt; [39,] 2 19 19 3 #&gt; [40,] 2 20 23 4 #&gt; [41,] 3 1 19 5 #&gt; [42,] 3 2 27 6 #&gt; [43,] 3 3 24 7 #&gt; [44,] 3 4 18 8 #&gt; [45,] 3 5 13 9 #&gt; [46,] 3 6 20 10 #&gt; [47,] 3 7 25 11 #&gt; [48,] 3 8 19 12 #&gt; [49,] 3 9 18 13 #&gt; [50,] 3 10 22 14 #&gt; [51,] 3 11 17 15 #&gt; [52,] 3 12 9 16 #&gt; [53,] 3 13 17 17 #&gt; [54,] 3 14 22 18 #&gt; [55,] 3 15 13 19 #&gt; [56,] 3 16 19 20 #&gt; [57,] 3 17 29 21 #&gt; [58,] 3 18 18 22 #&gt; [59,] 3 19 19 23 #&gt; [60,] 3 20 18 24 #&gt; [61,] 1 1 11 25 #&gt; [62,] 1 2 18 26 #&gt; [63,] 1 3 19 27 #&gt; [64,] 1 4 17 28 #&gt; [65,] 1 5 13 29 #&gt; [66,] 1 6 17 30 #&gt; [67,] 1 7 26 31 #&gt; [68,] 1 8 21 32 #&gt; [69,] 1 9 22 33 #&gt; [70,] 1 10 20 34 #&gt; [71,] 1 11 14 35 #&gt; [72,] 1 12 17 36 #&gt; [73,] 1 13 18 1 #&gt; [74,] 1 14 24 2 #&gt; [75,] 1 15 19 3 #&gt; [76,] 1 16 23 4 #&gt; [77,] 1 17 19 5 #&gt; [78,] 1 18 27 6 #&gt; [79,] 1 19 24 7 #&gt; [80,] 1 20 18 8 #&gt; [81,] 2 1 13 9 #&gt; [82,] 2 2 20 10 #&gt; [83,] 2 3 25 11 #&gt; [84,] 2 4 19 12 #&gt; [85,] 2 5 18 13 #&gt; [86,] 2 6 22 14 #&gt; [87,] 2 7 17 15 #&gt; [88,] 2 8 9 16 #&gt; [89,] 2 9 17 17 #&gt; [90,] 2 10 22 18 #&gt; [91,] 2 11 13 19 #&gt; [92,] 2 12 19 20 #&gt; [93,] 2 13 29 21 #&gt; [94,] 2 14 18 22 #&gt; [95,] 2 15 19 23 #&gt; [96,] 2 16 18 24 #&gt; [97,] 2 17 11 25 #&gt; [98,] 2 18 18 26 #&gt; [99,] 2 19 19 27 #&gt; [100,] 2 20 17 28 #&gt; [101,] 3 1 13 29 #&gt; [102,] 3 2 17 30 #&gt; [103,] 3 3 26 31 #&gt; [104,] 3 4 21 32 #&gt; [105,] 3 5 22 33 #&gt; [106,] 3 6 20 34 #&gt; [107,] 3 7 14 35 #&gt; [108,] 3 8 17 36 #&gt; [109,] 3 9 18 1 #&gt; [110,] 3 10 24 2 #&gt; [111,] 3 11 19 3 #&gt; [112,] 3 12 23 4 #&gt; [113,] 3 13 19 5 #&gt; [114,] 3 14 27 6 #&gt; [115,] 3 15 24 7 #&gt; [116,] 3 16 18 8 #&gt; [117,] 3 17 13 9 #&gt; [118,] 3 18 20 10 #&gt; [119,] 3 19 25 11 #&gt; [120,] 3 20 19 12 "],
["lista.html", "7.4 Lista", " 7.4 Lista Listas são o segundo tipo de vetor. O primeiro tipo nós já vimos, são os vetores atômicos, nos quais todos os elementos devem ser de uma mesma classe de objeto. Listas são uma estrutura de dados muito versátil por pelo menos 3 razões: Os elementos podem ser de diferentes classes de objetos (p.ex.: um elemento numeric, outro character); Cada elemento pode ter um tamanho diferente; Os elementos podem conter diferentes estrutura de dados (p.ex.: um elemento matrix, outro vector); Dentro da lista o conjunto de objetos são ordenados e cada elemento pode conter sub-elementos. 7.4.1 Criação As vezes precisamos de um container para armazenar diferentes tipos de dados do R e com diferente tamanhos. As listas servem para isso e permitem armazenar qualquer número de itens de qualquer tipo. Uma lista pode conter números, caracteres ou uma mistura de dataframes, sub-listas, matrizes e vetores. Listas podem ser criadas com a função list(). A especificação do conteúdo de uma lista é muito similar a da função c() vista anteriormente. Nós simplesmente listamos os elementos da lista separados por uma vírgula dentro da função list(). # lista de dados heterogêneos lst &lt;- list(1:4, c(1.1, 2.3, 5.9), c(TRUE, FALSE), &quot;R&quot;, list(0, 1)) lst #&gt; [[1]] #&gt; [1] 1 2 3 4 #&gt; #&gt; [[2]] #&gt; [1] 1.1 2.3 5.9 #&gt; #&gt; [[3]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[4]] #&gt; [1] &quot;R&quot; #&gt; #&gt; [[5]] #&gt; [[5]][[1]] #&gt; [1] 0 #&gt; #&gt; [[5]][[2]] #&gt; [1] 1 # estrutura da lista str(lst) #&gt; List of 5 #&gt; $ : int [1:4] 1 2 3 4 #&gt; $ : num [1:3] 1.1 2.3 5.9 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : chr &quot;R&quot; #&gt; $ :List of 2 #&gt; ..$ : num 0 #&gt; ..$ : num 1 # tamanho da lista (num. de componentes ou elementos) length(lst) #&gt; [1] 5 # atribuindo nomes a lista names(lst) #&gt; NULL names(lst) &lt;- c(&quot;vetor_int&quot;, &quot;vetor_num&quot;, &quot;logico&quot;, &quot;char&quot;, &quot;lista&quot;) Os índices em colchetes duplos [[]] identificam o elemento ou a componente da lista. Os índices em colchete simples [] indicam qual sub-elemento da lista está sendo mostrado. Por exemplo 1.1 é o primeiro sub-elemento do segundo elemento da lista lst. Desse aninhamento de elementos surge o sistema de indexação de listas. A estrutura de uma lista pode se tornar complicada com o aumento do grau de sub-elementos. Mas essa flexibilidade, faz das listas uma ferramenta de armazenamento de dados para todos propósitos. Veremos que no R, listas são frequentemente usadas para armazenar a saída de funções com diversos resultados. Como por exemplo a saída das funções rle(). Para verificar se uma lista é aninhada usamos a função is.recursive(). is.recursive(lst) #&gt; [1] TRUE Vamos ver um exemplo onde criamos uma lista com informações de duas estações meteorológicas. # matriz de dados meteorológicos da estação de Santa Maria dados_sm &lt;- cbind( tar = c(31, 35, 21, 23, 33, 17), prec = c(300, 200, 150, 120, 210, 110) ) dados_sm #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # lista com informações da estação de santa maria sm_l &lt;- list( c(-45, -23), &quot;Santa Maria&quot;, dados_sm ) sm_l #&gt; [[1]] #&gt; [1] -45 -23 #&gt; #&gt; [[2]] #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; [[3]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # adicionar nomes aos elementos names(sm_l) &lt;- c(&quot;coords&quot;, &quot;cidade&quot;, &quot;dados&quot;) sm_l #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # matriz de dados meteorológicos da estação de Júlio de Castilhos dados_jc &lt;- cbind( tar = c(22.5, 20, 18.75, 18, 20.25, 17.75), prec = c(360, 310, 285, 270, 315, 265) ) # criando lista de JC, mas nomeando de forma diferente jc_l &lt;- list( coords = c(-45.1, -23.2), cidade = &quot;Júlio de Castilhos&quot;, dados = dados_jc ) # adicionar nomes as componentes names(jc_l) &lt;- names(sm_l) jc_l #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 As informações de cada estação estão armazenadas em 2 listas. Mas é mais prático termos todas estações em um única lista: # combinando listas mantendo os elementos separadamente dados_l &lt;- list(sm_l, jc_l) dados_l #&gt; [[1]] #&gt; [[1]]$coords #&gt; [1] -45 -23 #&gt; #&gt; [[1]]$cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; [[1]]$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; [[2]]$cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; [[2]]$dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 names(dados_l) #&gt; NULL names(dados_l) &lt;- c(&quot;sm&quot;, &quot;jc&quot;) dados_l #&gt; $sm #&gt; $sm$coords #&gt; [1] -45 -23 #&gt; #&gt; $sm$cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $sm$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; #&gt; $jc #&gt; $jc$coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $jc$cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $jc$dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 # como a lista é um tipo vetor, a função length() # fornece o número de elementos da lista length(dados_l) #&gt; [1] 2 Para resumir a estrutura de uma lista (ou dataframe) podemos usar a função str(): str(dados_l) #&gt; List of 2 #&gt; $ sm:List of 3 #&gt; ..$ coords: num [1:2] -45 -23 #&gt; ..$ cidade: chr &quot;Santa Maria&quot; #&gt; ..$ dados : num [1:6, 1:2] 31 35 21 23 33 17 300 200 150 120 ... #&gt; .. ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. .. ..$ : NULL #&gt; .. .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; #&gt; $ jc:List of 3 #&gt; ..$ coords: num [1:2] -45.1 -23.2 #&gt; ..$ cidade: chr &quot;Júlio de Castilhos&quot; #&gt; ..$ dados : num [1:6, 1:2] 22.5 20 18.8 18 20.2 ... #&gt; .. ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. .. ..$ : NULL #&gt; .. .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; As listas também poderiam ser combinadas com função concatena ou combina c(). dados_l2 &lt;- c(sm_l, jc_l) dados_l2 #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 str(dados_l2) #&gt; List of 6 #&gt; $ coords: num [1:2] -45 -23 #&gt; $ cidade: chr &quot;Santa Maria&quot; #&gt; $ dados : num [1:6, 1:2] 31 35 21 23 33 17 300 200 150 120 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : NULL #&gt; .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; #&gt; $ coords: num [1:2] -45.1 -23.2 #&gt; $ cidade: chr &quot;Júlio de Castilhos&quot; #&gt; $ dados : num [1:6, 1:2] 22.5 20 18.8 18 20.2 ... #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 2 #&gt; .. ..$ : NULL #&gt; .. ..$ : chr [1:2] &quot;tar&quot; &quot;prec&quot; 7.4.2 Indexação 7.4.2.1 Operador [ Assim como em vetores, podemos acessar os elementos de uma lista usando os colchetes [ com índices numéricos positivos, negativos, caracteres (nomes dos elementos) e lógicos. As expressões abaixo, ilustram o uso dessas diferentes formas de seleção de elementos e produzem o mesmo resultado. sm_l[1:2] #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; sm_l[c(&quot;coords&quot;, &quot;alt&quot;)] #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $&lt;NA&gt; #&gt; NULL O resultado da seleção do 1º e 2º elemento é uma lista menor que a original. Isso não é muito útil, uma vez que muitas funções do R não lidam com listas. Por exemplo, se quiséssemos calcular a soma do vetor contido do primeiro elemento da lista lst obtém-se um erro. # seleção do 1º elemento da lst lst[1] #&gt; $vetor_int #&gt; [1] 1 2 3 4 # o resultado da seleção é uma lista mode(lst[1]) #&gt; [1] &quot;list&quot; # a função sum() espera como entrada um vetor sum(lst[1]) #&gt; Error in sum(lst[1]): invalid &#39;type&#39; (list) of argument # acessando elemento inexistente lst[6] #&gt; $&lt;NA&gt; #&gt; NULL Então ao selecionar elementos de uma lista com o operador [ o resultado preserva a estrutura original do objeto. lst é uma lista e o resultado da seleção lst[1] também é uma lista. Portanto, a seleção de elementos com o operador [ preserva a estrutura do objeto original. 7.4.2.2 Operador [[ e $ Entretanto na maioria das vezes estamos interessados no conteúdo dos elementos de uma lista. Para fazer isso há dois operadores: o duplo colchetes [[ e o $. Para acessar elementos individuais de uma lista usamos o duplo colchetes [[ especificando o número do elemento ou o nome. Essa forma de seleção de dados permite o acesso a um elemento por vez. # 1º elemento de sm_l sm_l[[1]] #&gt; [1] -45 -23 sm_l[[&quot;coords&quot;]] #&gt; [1] -45 -23 # modo de sm_l mode(sm_l) #&gt; [1] &quot;list&quot; # ultimo elemento de sm_l sm_l[[length(sm_l)]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 sm_l[[&quot;dados&quot;]] #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # subelementos dados_l[[&quot;sm&quot;]][[&quot;cidade&quot;]] #&gt; [1] &quot;Santa Maria&quot; Para acessar o conteúdo de elementos de uma lista que possui nomes podemos também usar o operador $. Ele funciona de forma similar ao duplo colchetes usado com o nome do elemento da lista. Mas esse operador tem duas vantagens: a IDE RStudio autocompleta o nome do elemento (usando a tecla &lt;tab&gt;) e o R aceita o nome parcial dos nomes dos elementos. # seleção de dados por nomes usando o símbolo $ dados_l$s #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 dados_l$j #&gt; $coords #&gt; [1] -45.1 -23.2 #&gt; #&gt; $cidade #&gt; [1] &quot;Júlio de Castilhos&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 22.50 360 #&gt; [2,] 20.00 310 #&gt; [3,] 18.75 285 #&gt; [4,] 18.00 270 #&gt; [5,] 20.25 315 #&gt; [6,] 17.75 265 dados_l$sm$dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 dados_l$sm$dados[3:5, 1:2] #&gt; tar prec #&gt; [1,] 21 150 #&gt; [2,] 23 120 #&gt; [3,] 33 210 dados_l$sm$dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 dados_l$sm$dados[, &quot;tar&quot;, drop = FALSE] #&gt; tar #&gt; [1,] 31 #&gt; [2,] 35 #&gt; [3,] 21 #&gt; [4,] 23 #&gt; [5,] 33 #&gt; [6,] 17 7.4.2.3 Lista de condimentos É fácil de confundir quando usar ] e ]]. A tabela abaixo ajuda lembrar da diferença entre eles. descrição código resultado frasco de pimenta frasco frasco de pimenta com apenas 1 pacote de pimenta frasco[1] 1 pacote de pimenta frasco[[1]] conteúdo de um pacote de pimenta frasco[[1]][[1]] 7.4.3 Conversão de lista para vetor e vice-versa. vet &lt;- 1:10 vet #&gt; [1] 1 2 3 4 5 6 7 8 9 10 vet.list &lt;- as.list(vet) vet.list #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 #&gt; #&gt; [[6]] #&gt; [1] 6 #&gt; #&gt; [[7]] #&gt; [1] 7 #&gt; #&gt; [[8]] #&gt; [1] 8 #&gt; #&gt; [[9]] #&gt; [1] 9 #&gt; #&gt; [[10]] #&gt; [1] 10 # desmanchando a lista unlist(vet.list) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # deletando um elemento de uma lista length(vet.list) #&gt; [1] 10 vet.list[8] &lt;- NULL vet.list #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 #&gt; #&gt; [[6]] #&gt; [1] 6 #&gt; #&gt; [[7]] #&gt; [1] 7 #&gt; #&gt; [[8]] #&gt; [1] 9 #&gt; #&gt; [[9]] #&gt; [1] 10 length(vet.list) #&gt; [1] 9 7.4.4 Conversão de list para data.frame Vamos modificar a lista sm_l para convertê-la em um dataframe. sm_l #&gt; $coords #&gt; [1] -45 -23 #&gt; #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 # ao invés da componente coords, criamos uma lon e lat sm_l$lon &lt;- sm_l$coords[1] sm_l$lat &lt;- sm_l$coords[2] sm_l$coords &lt;- NULL sm_l #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $lon #&gt; [1] -45 #&gt; #&gt; $lat #&gt; [1] -23 # converter para dataframe sm_df &lt;- data.frame(sm_l) sm_df #&gt; cidade dados.tar dados.prec lon lat #&gt; 1 Santa Maria 31 300 -45 -23 #&gt; 2 Santa Maria 35 200 -45 -23 #&gt; 3 Santa Maria 21 150 -45 -23 #&gt; 4 Santa Maria 23 120 -45 -23 #&gt; 5 Santa Maria 33 210 -45 -23 #&gt; 6 Santa Maria 17 110 -45 -23 "],
["dataframe.html", "7.5 Dataframe", " 7.5 Dataframe Um dataframe é o objeto mais usado para guardar conjunto de dados na forma de tabela (tabulares ou planos). A estrutura de um dataframe é retangular como a de uma matriz. Mas tem a vantagem de armazenar vetores de diferentes tipos (character, numeric, logical e etc) nas suas colunas. O que não é possível em uma matriz. Ou seja é uma estrutura de armazenamento de dados heterogênea. Matrix, arrays e vector só armazenam dados homogêneos. Cada linha do dataframe corresponde a um registro da tabela. Cada coluna corresponde a uma variável a ser armazenada para cada registro da tabela. 7.5.1 Criação Uma das formas mais simples de se criar um dataframe é através da função data.frame(). # criando um dataframe dados &lt;- data.frame( datas = c( &quot;2013-01-01&quot;, &quot;2013-01-02&quot;, &quot;2013-01-03&quot;, &quot;2013-01-04&quot;, &quot;2013-01-05&quot;, &quot;2013-01-06&quot;, &quot;2013-01-07&quot;, &quot;2013-01-08&quot;, &quot;2013-01-09&quot;, &quot;2013-01-10&quot;, &quot;2013-01-11&quot;, &quot;2013-01-12&quot;, &quot;2013-01-13&quot;, &quot;2013-01-14&quot;, &quot;2013-01-15&quot; ), cidade = rep(&quot;Santa Maria&quot;, 15), tar = c(31, 35, 21, 23, 33, 17, 18, 16, 34, 27, 15, 28, 22, 29, 32) ) dados #&gt; datas cidade tar #&gt; 1 2013-01-01 Santa Maria 31 #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 #&gt; 15 2013-01-15 Santa Maria 32 class(dados) #&gt; [1] &quot;data.frame&quot; is.data.frame(dados) #&gt; [1] TRUE Para um diagnóstico rápido das variáveis de um dataframe usamos a função str(): # descrição geral do conjunto de dados str(dados) #&gt; &#39;data.frame&#39;: 15 obs. of 3 variables: #&gt; $ datas : Factor w/ 15 levels &quot;2013-01-01&quot;,&quot;2013-01-02&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ cidade: Factor w/ 1 level &quot;Santa Maria&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tar : num 31 35 21 23 33 17 18 16 34 27 ... A saída da função str()indica que há duas variáveis da classe factor. Em um dataframe vetores do tipo character são automaticamente convertidos em factor. Este é o comportamento default da função data.frame(). Para que essa conversão não seja feita você deve definir o parâmetro stringsAsFactors = FALSE na função data.frame(). Vamos recriar o dataframe dados sem a conversão de character para factor. # criando um dataframe dados &lt;- data.frame( datas = c( &quot;2013-01-01&quot;, &quot;2013-01-02&quot;, &quot;2013-01-03&quot;, &quot;2013-01-04&quot;, &quot;2013-01-05&quot;, &quot;2013-01-06&quot;, &quot;2013-01-07&quot;, &quot;2013-01-08&quot;, &quot;2013-01-09&quot;, &quot;2013-01-10&quot;, &quot;2013-01-11&quot;, &quot;2013-01-12&quot;, &quot;2013-01-13&quot;, &quot;2013-01-14&quot;, &quot;2013-01-15&quot; ), cidade = rep(&quot;Santa Maria&quot;, 15), tar = c(31, 35, 21, 23, 33, 17, 18, 16, 34, 27, 15, 28, 22, 29, 32), stringsAsFactors = FALSE ) str(dados) #&gt; &#39;data.frame&#39;: 15 obs. of 3 variables: #&gt; $ datas : chr &quot;2013-01-01&quot; &quot;2013-01-02&quot; &quot;2013-01-03&quot; &quot;2013-01-04&quot; ... #&gt; $ cidade: chr &quot;Santa Maria&quot; &quot;Santa Maria&quot; &quot;Santa Maria&quot; &quot;Santa Maria&quot; ... #&gt; $ tar : num 31 35 21 23 33 17 18 16 34 27 ... A função summary() fornece um resumo estatístico das variáveis (colunas) de um dataframe. # resumo estatístico dos dados summary(dados) #&gt; datas cidade tar #&gt; Length:15 Length:15 Min. :15.0 #&gt; Class :character Class :character 1st Qu.:19.5 #&gt; Mode :character Mode :character Median :27.0 #&gt; Mean :25.4 #&gt; 3rd Qu.:31.5 #&gt; Max. :35.0 7.5.2 Atributos de um dataframe dataframe é uma estrutura de dados avançada e possui diversos atributos. # atributos attributes(dados) #&gt; $names #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; # atributos armazenados em uma lista str(attributes(dados)) #&gt; List of 3 #&gt; $ names : chr [1:3] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; #&gt; $ row.names: int [1:15] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ class : chr &quot;data.frame&quot; # número de colunas ncol(dados) #&gt; [1] 3 # número de linhas nrow(dados) #&gt; [1] 15 # dimensões dim(dados) #&gt; [1] 15 3 # nomes podem ser atribuídos as linhas e as colunas rownames(dados) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; #&gt; [15] &quot;15&quot; # novos nomes para as linhas de dados rownames(dados) &lt;- paste0(&quot;linha&quot;, rownames(dados)) dados #&gt; datas cidade tar #&gt; linha1 2013-01-01 Santa Maria 31 #&gt; linha2 2013-01-02 Santa Maria 35 #&gt; linha3 2013-01-03 Santa Maria 21 #&gt; linha4 2013-01-04 Santa Maria 23 #&gt; linha5 2013-01-05 Santa Maria 33 #&gt; linha6 2013-01-06 Santa Maria 17 #&gt; linha7 2013-01-07 Santa Maria 18 #&gt; linha8 2013-01-08 Santa Maria 16 #&gt; linha9 2013-01-09 Santa Maria 34 #&gt; linha10 2013-01-10 Santa Maria 27 #&gt; linha11 2013-01-11 Santa Maria 15 #&gt; linha12 2013-01-12 Santa Maria 28 #&gt; linha13 2013-01-13 Santa Maria 22 #&gt; linha14 2013-01-14 Santa Maria 29 #&gt; linha15 2013-01-15 Santa Maria 32 # removendo nomes das linhas rownames(dados) &lt;- NULL dados #&gt; datas cidade tar #&gt; 1 2013-01-01 Santa Maria 31 #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 #&gt; 15 2013-01-15 Santa Maria 32 # mesmo que names(dados) colnames(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; # ou simplesmente names(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; 7.5.3 Acesso as variáveis de um dataframe Existem várias formas de acessar as variáveis de um dataframe. Os operadores para extração de elementos são os mesmos utilizados para extração de elementos de uma lista: [, [[ e $. Mas observe a diferença nos resultados extraídos com cada operador. # variáveis do dataframe names(dados) #&gt; [1] &quot;datas&quot; &quot;cidade&quot; &quot;tar&quot; # acessando os dados de temperatura dados[, 3] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 # ou dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 # ou dados$tar #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 is.vector(dados$tar) #&gt; [1] TRUE # note a diferença no resultado da extração dados[&quot;tar&quot;] #&gt; tar #&gt; 1 31 #&gt; 2 35 #&gt; 3 21 #&gt; 4 23 #&gt; 5 33 #&gt; 6 17 #&gt; 7 18 #&gt; 8 16 #&gt; 9 34 #&gt; 10 27 #&gt; 11 15 #&gt; 12 28 #&gt; 13 22 #&gt; 14 29 #&gt; 15 32 class(dados[&quot;tar&quot;]) #&gt; [1] &quot;data.frame&quot; dados[[&quot;tar&quot;]] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 class(dados[[&quot;tar&quot;]]) #&gt; [1] &quot;numeric&quot; dados[, &quot;tar&quot;] #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 class(dados[, &quot;tar&quot;]) #&gt; [1] &quot;numeric&quot; Portanto dataframes tem estrutura retangular similar a das matrizes e algumas de listas (diferentes colunas podem conter diferentes tipos de objetos). 7.5.3.1 Função with() O acesso as variáveis de um dataframe também é possível com a função with(data, expr). # acesso a variáveis de um dataframe with(data = dados, expr = tar) #&gt; [1] 31 35 21 23 33 17 18 16 34 27 15 28 22 29 32 tarK &lt;- with(data = dados, expr = tar + 273.15) tarK #&gt; [1] 304.15 308.15 294.15 296.15 306.15 290.15 291.15 289.15 307.15 300.15 #&gt; [11] 288.15 301.15 295.15 302.15 305.15 # gráfico de uma variável usando with() with(data = dados, # parâmetro expr geralmente não é mostrado plot(tar + 273.15, type = &quot;o&quot;) ) O argumento pode ser substituído por qualquer expressão ou conjunto de expressões que envolvam as variáveis do dataframe de entrada. Quando houver uma expressão com mais de uma linha você agrupa o código usando chaves {}. with(dados, { dates &lt;- as.Date(datas) plot(dates, tar) } ) 7.5.4 Indexação, seleção e substituição Todos esquemas de indexação usados para matrizes (seleção por índices, nomes, vetores lógicos - ver Aula9) podem ser usados com dataframes. # exclui a primeiro e a última observação para todas variáveis dados[-c(1, nrow(dados)), ] #&gt; datas cidade tar #&gt; 2 2013-01-02 Santa Maria 35 #&gt; 3 2013-01-03 Santa Maria 21 #&gt; 4 2013-01-04 Santa Maria 23 #&gt; 5 2013-01-05 Santa Maria 33 #&gt; 6 2013-01-06 Santa Maria 17 #&gt; 7 2013-01-07 Santa Maria 18 #&gt; 8 2013-01-08 Santa Maria 16 #&gt; 9 2013-01-09 Santa Maria 34 #&gt; 10 2013-01-10 Santa Maria 27 #&gt; 11 2013-01-11 Santa Maria 15 #&gt; 12 2013-01-12 Santa Maria 28 #&gt; 13 2013-01-13 Santa Maria 22 #&gt; 14 2013-01-14 Santa Maria 29 # temperatura dos primeiros 5 dias dados[1:5, 3] #&gt; [1] 31 35 21 23 33 # temperatura no dia 2013-01-09 dados[dados$datas == &quot;2013-01-09&quot;, &quot;tar&quot;] #&gt; [1] 34 # acrescentar uma nova variavel dados$prec &lt;- c(rep(0, 5), 10, 18, 4, 0, 0, 5, 0, 0, 2, 0) dados #&gt; datas cidade tar prec #&gt; 1 2013-01-01 Santa Maria 31 0 #&gt; 2 2013-01-02 Santa Maria 35 0 #&gt; 3 2013-01-03 Santa Maria 21 0 #&gt; 4 2013-01-04 Santa Maria 23 0 #&gt; 5 2013-01-05 Santa Maria 33 0 #&gt; 6 2013-01-06 Santa Maria 17 10 #&gt; 7 2013-01-07 Santa Maria 18 18 #&gt; 8 2013-01-08 Santa Maria 16 4 #&gt; 9 2013-01-09 Santa Maria 34 0 #&gt; 10 2013-01-10 Santa Maria 27 0 #&gt; 11 2013-01-11 Santa Maria 15 5 #&gt; 12 2013-01-12 Santa Maria 28 0 #&gt; 13 2013-01-13 Santa Maria 22 0 #&gt; 14 2013-01-14 Santa Maria 29 2 #&gt; 15 2013-01-15 Santa Maria 32 0 Uma função específica para gerar subconjunto de dados em dataframes é a subset(). # subconjunto baseado em condição lógica ss1 &lt;- subset(dados, datas == &quot;2013-01-09&quot;, select = &quot;tar&quot;) ss1 #&gt; tar #&gt; 9 34 # subconjunto baseado em condição lógica ss2 &lt;- subset(dados, tar &gt; 26 &amp; prec &gt; 0) ss2 #&gt; datas cidade tar prec #&gt; 14 2013-01-14 Santa Maria 29 2 # subconjunto baseado em condição lógica ss3 &lt;- subset(dados, tar &gt; 26 | prec &gt; 0) ss3 #&gt; datas cidade tar prec #&gt; 1 2013-01-01 Santa Maria 31 0 #&gt; 2 2013-01-02 Santa Maria 35 0 #&gt; 5 2013-01-05 Santa Maria 33 0 #&gt; 6 2013-01-06 Santa Maria 17 10 #&gt; 7 2013-01-07 Santa Maria 18 18 #&gt; 8 2013-01-08 Santa Maria 16 4 #&gt; 9 2013-01-09 Santa Maria 34 0 #&gt; 10 2013-01-10 Santa Maria 27 0 #&gt; 11 2013-01-11 Santa Maria 15 5 #&gt; 12 2013-01-12 Santa Maria 28 0 #&gt; 14 2013-01-14 Santa Maria 29 2 #&gt; 15 2013-01-15 Santa Maria 32 0 # subconjunto baseado em condição lógica ss4 &lt;- subset(dados, datas %in% c(&quot;2013-01-09&quot;, &quot;2013-01-13&quot;, &quot;2013-01-15&quot;), select = -cidade ) ss4 #&gt; datas tar prec #&gt; 9 2013-01-09 34 0 #&gt; 13 2013-01-13 22 0 #&gt; 15 2013-01-15 32 0 # subconjunto baseado em condição lógica ss4 &lt;- subset(dados, !datas %in% c(&quot;2013-01-09&quot;, &quot;2013-01-13&quot;, &quot;2013-01-15&quot;), select = -cidade ) ss4 #&gt; datas tar prec #&gt; 1 2013-01-01 31 0 #&gt; 2 2013-01-02 35 0 #&gt; 3 2013-01-03 21 0 #&gt; 4 2013-01-04 23 0 #&gt; 5 2013-01-05 33 0 #&gt; 6 2013-01-06 17 10 #&gt; 7 2013-01-07 18 18 #&gt; 8 2013-01-08 16 4 #&gt; 10 2013-01-10 27 0 #&gt; 11 2013-01-11 15 5 #&gt; 12 2013-01-12 28 0 #&gt; 14 2013-01-14 29 2 Uma função específica para alteração, remoção e inclusão de variáveis em um dataframe é a transform(). Essa função é mais indicada para alteração de mais de uma variável (ao mesmo tempo) de um dataframe. # mudança do dataframe, alteração de várias variáveis dados &lt;- transform(dados, cidade = ifelse(1:nrow(dados) &gt; 8, &quot;Sao Sepe&quot;, cidade), datas = c(datas[1:8], datas[1:7]), anomalias = ifelse(cidade == &quot;Santa Maria&quot;, tar - mean(tar[cidade == &quot;Santa Maria&quot;]), tar - mean(tar[cidade == &quot;Sao Sepe&quot;]) ) ) dados #&gt; datas cidade tar prec anomalias #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 # alterar só uma variavel, anomalia normalizada dados$anomalias.norm &lt;- ifelse(dados$cidade == &quot;Santa Maria&quot;, dados$anomalias / sd(dados$anomalias[dados$cidade == &quot;Santa Maria&quot;]), dados$anomalias / sd(dados$anomalias[dados$cidade == &quot;Sao Sepe&quot;]) ) dados #&gt; datas cidade tar prec anomalias anomalias.norm #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 7.5.5 Combinando dataframes coords_df &lt;- data.frame( lon = c(rep(-45, 8), rep(-45.1, 7)), # longitudes lat = c(rep(-23, 8), rep(-23.1, 7)) ) # latitudes d &lt;- cbind(dados, coords_df) d #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 # usando a própria função data.frame() d2 &lt;- data.frame(dados, coords_df, stringsAsFactors = FALSE) d2 #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 # verificando se os dois dataframes são idênticos identical(d, d2) #&gt; [1] TRUE # dados de Caçapava cacapava &lt;- data.frame( datas = &quot;2013-01-01&quot;, cidade = &quot;Cacapava&quot;, tar = 19, prec = 0, anomalias = NA, anomalias.norm = NA, lon = -45.1, lat = -23.2 ) d &lt;- rbind(d, cacapava) d #&gt; datas cidade tar prec anomalias anomalias.norm lon lat #&gt; 1 2013-01-01 Santa Maria 31 0 5.6 0.732167 -45.0 -23.0 #&gt; 2 2013-01-02 Santa Maria 35 0 9.6 1.255143 -45.0 -23.0 #&gt; 3 2013-01-03 Santa Maria 21 0 -4.4 -0.575274 -45.0 -23.0 #&gt; 4 2013-01-04 Santa Maria 23 0 -2.4 -0.313786 -45.0 -23.0 #&gt; 5 2013-01-05 Santa Maria 33 0 7.6 0.993655 -45.0 -23.0 #&gt; 6 2013-01-06 Santa Maria 17 10 -8.4 -1.098250 -45.0 -23.0 #&gt; 7 2013-01-07 Santa Maria 18 18 -7.4 -0.967506 -45.0 -23.0 #&gt; 8 2013-01-08 Santa Maria 16 4 -9.4 -1.228994 -45.0 -23.0 #&gt; 9 2013-01-01 Sao Sepe 34 0 8.6 1.339211 -45.1 -23.1 #&gt; 10 2013-01-02 Sao Sepe 27 0 1.6 0.249156 -45.1 -23.1 #&gt; 11 2013-01-03 Sao Sepe 15 5 -10.4 -1.619512 -45.1 -23.1 #&gt; 12 2013-01-04 Sao Sepe 28 0 2.6 0.404878 -45.1 -23.1 #&gt; 13 2013-01-05 Sao Sepe 22 0 -3.4 -0.529456 -45.1 -23.1 #&gt; 14 2013-01-06 Sao Sepe 29 2 3.6 0.560600 -45.1 -23.1 #&gt; 15 2013-01-07 Sao Sepe 32 0 6.6 1.027767 -45.1 -23.1 #&gt; 16 2013-01-01 Cacapava 19 0 NA NA -45.1 -23.2 7.5.6 Teste e Coerção Podemos converter um objeto para dataframe com as.data.frame(): Um vetor é transformado em um dataframe de uma coluna; Uma lista terá uma coluna para elemento, se os elementos não forem de mesmo tamanho haverá um erro; Uma matriz cria um dataframe com mesma estrutura de uma matriz; # convertendo lista para dataframe sm_l #&gt; $cidade #&gt; [1] &quot;Santa Maria&quot; #&gt; #&gt; $dados #&gt; tar prec #&gt; [1,] 31 300 #&gt; [2,] 35 200 #&gt; [3,] 21 150 #&gt; [4,] 23 120 #&gt; [5,] 33 210 #&gt; [6,] 17 110 #&gt; #&gt; $lon #&gt; [1] -45 #&gt; #&gt; $lat #&gt; [1] -23 sm_l_df &lt;- as.data.frame(sm_l) sm_l_df #&gt; cidade dados.tar dados.prec lon lat #&gt; 1 Santa Maria 31 300 -45 -23 #&gt; 2 Santa Maria 35 200 -45 -23 #&gt; 3 Santa Maria 21 150 -45 -23 #&gt; 4 Santa Maria 23 120 -45 -23 #&gt; 5 Santa Maria 33 210 -45 -23 #&gt; 6 Santa Maria 17 110 -45 -23 # convertendo array para dataframe v #&gt; [1] 3 100 NA NA 6 v_df &lt;- as.data.frame(v) # convertendo vetor para dataframe temp90_df &lt;- as.data.frame(temp90) # convertendo matrix para dataframe mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0 1 -1 -2 #&gt; [2,] 3 5 -5 0 mat_df &lt;- as.data.frame(mat) names(mat_df) #&gt; [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; mat_df #&gt; V1 V2 V3 V4 #&gt; 1 0 1 -1 -2 #&gt; 2 3 5 -5 0 # testes is.data.frame(mat_df) #&gt; [1] TRUE class(v_df) #&gt; [1] &quot;data.frame&quot; "],
["exercicios-1.html", "7.6 Exercícios", " 7.6 Exercícios Crie um vetor com os valores de \\(e^{x}cos{x}\\) para os valores de \\(x = (3, 3.1, 3.2, ..., 6\\)). Crie os seguintes vetores. \\((0.1^{3}0.2^{1}, 0.1^{6}0.2^{4}, ..., 0.1^{36}0.2^{34})\\) \\((2, \\frac{2^{2}}{2}, \\frac{2^{3}}{3}, ..., \\frac{2^{25}}{25})\\) Reproduza a criação do vetor dias da semana (dds) mostrado abaixo. Domingo Segunda-feira Terça-feira Quarta-feira Quinta-feira 1 2 3 4 5 Sexta-feira Sábado 6 7 Escreva os códigos necessários para determinar: o vetor lógico indicando quais números são pares na sequência de valores 19, 70, 57, 17, 91, 90, 13, 78, 44, 51. Calcule o total de números ímpares. Se um ano é bissexto. Verifique os resultados de seu código para os anos 1913, 1977, 1961, 1910, 2005, 2004, 1905, 1989, 1945, 1954. Calcule o total de anos com 365 dias. Quais códigos para gerar os seguintes dados: [1] -20 0 10 20 30 40 [1] -1.00 -0.75 -0.50 -0.25 0.00 0.25 0.50 0.75 1.00 [1] -3.141593 -2.570394 -1.999195 -1.427997 -0.856798 -0.285599 0.285599 [8] 0.856798 1.427997 1.999195 2.570394 3.141593 [1] 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5 [1] 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1 Dica: lembre da função rep() e seus argumentos each e times. Experimente usar vetores nesses argumentos. [,1] [,2] [,3] [,4] [1,] 1 1 2 2 [2,] 1 1 2 2 [3,] 3 3 4 4 [4,] 3 3 4 4 Como a partir da matriz gerada na letra f você pode obter a matriz abaixo? [,1] [,2] [,3] [,4] [1,] 1 1 3 3 [2,] 1 1 3 3 [3,] 2 2 4 4 [4,] 2 2 4 4 Qual o código para converter a matriz gerada na letra g no vetor abaixo? [1] 1 1 3 3 1 1 3 3 2 2 4 4 2 2 4 4 Como obter as seguintes sequências a partir dos vetores fornecidos usando a mesma solução para todos casos? v3 = (10, 0.5, 8, 4) [1] 1 2 3 4 v2 = (10, 0.5) [1] 1 2 v1 = (10) [1] 1 v0 = () integer(0) Calcule a soma cumulativa dos números 2, 3, 4, 5, 6. Dica: ver a função cumsum(). (b) Calcule a soma cumulativa destes números mas na ordem reversa. Dica: ver a função rev(). Os dados abaixo são de precipitação horária de um evento severo ocorrido em 03/12/2012. hora prec 9 0.0 10 0.0 11 0.0 12 0.0 13 0.0 14 0.0 15 0.0 16 21.4 17 41.2 18 2.6 19 1.0 20 0.4 21 0.0 Como seria o código para determinar a soma cumulativa da precipitação horária? Salve seu resultado em um vetor chamado prec_acum. Interprete o resultado c(NA, diff(prec_acum)). Mostre o código para encontrar o horário de ocorrência da precipitação máxima? Mostre o código para obter a hora de início e fim do evento de precipitação severa. Qual foi a duração do evento? Qual foi a precipitação total do evento? Quanto da precipitação total do evento, em %, ocorreu até às 17 h? EXERCÍCIO RESOLVIDO. Considere o vetor x definido pelos números descritos abaixo. Mostre como encontrar o primeiro número positivo localizado após o último número negativo. Por exemplo, seja o vetor z definido pelos valores (11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14). Os valores selecionados seriam 5 e 30. Um possível código para chegar a esse resultado seria: x &lt;- c(11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14) #x1 &lt;- ifelse(x &gt; 0, 1, 0) # cópia de x x01 &lt;- x # substituo x positivo por 1 e x negativo por 0 x01[x &gt; 0] &lt;- 1 x01[!x &gt; 0] &lt;- 0 res &lt;- x[which(diff(x01) == 1) + 1] res #&gt; [1] 5 30 Mostre o código para resolver as seguintes tarefas. Considere o vetor prec com valores de precipitação diária indicado abaixo. prec &lt;- c(0, 0, 0, 0.8, 0, 0.01, 0.75, 0, 0, 0, 0, 0.35, 0.08, 0, 0, 0, 0, 0.31, 0, 3.57, 12.17, 0, 0, 0, 0.04, 3.16, 0, 0.95, 0.79, 0, 0, 0, 0, 0, 3.51, 0, 0, 0.16, 0, 0, 8.16, 0.54, 4.39, 1.24, 0, 0, 0, 0, 0, 2.43, 0, 0, 0, 0, 0, 7.18, 0, 0, 0.26, 0, 0, 0.28, 0, 0, 0.09, 0.38, 0, 0, 0, 0, 0, 0, 0.51, 0, 0, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0.15, 0, 0.82, 0, 0, 0, 0, 0, 0, 0, 0, 0.37, 0, 0.58, 4.95, 0, 0, 0, 0, 0, 7.68, 0, 0, 0.37, 0, 1.56, 0, 0, 0, 0.34, 0.48, 0, 4.21, 2.28, 4.3, 0, 3.38, 0, 0, 0, 0, 7.28, 0, 4.89, 3.91, 0, 0, 0, 0, 0, 0, 2.93, 0, 2.49, 0.77, 0, 2.9, 3.53, 0.83, 0, 0, 0, 0.94, 0.59, 0, 0, 0, 0, 0.04, 0, 0.65, 0, 0, 0, 6.23, 0.09, 0, 0.66, 0, 0, 0, 4.42, 0, 0, 0, 0.84, 0, 0, 0, 0, 0, 0.09, 0, 0, 0.08, 0, 0.66, 0, 0, 0, 0.06, 0, 0, 0, 3.28, 0, 0.8, 5.69, 0.8, 0) Quantos dias ocorreram no intervalo 0 &lt; prec &lt; 0.25? Substitua os valores de chuva registrados no intervalo 0 &lt; prec &lt; 0.25 por 0. Crie um vetor denominado prec01 indicando o estado da precipitação (chuvoso = 1, seco = 0) baseado no limiar de 0.25 mm para detecção de chuva pelo pluviômetro. Qual a probalidade de chuva dessa série de precipitação diária? Qual a probabilidade de chover dois dias consecutivos (p11)? Calcule a probabilidade de chover em qualquer um de dois dias consecutivos (p01 + p10)? Determine a duração de cada evento chuvoso (número de dias consecutivos). Dica: comece encontrando a posição do início do evento e depois a posição final do envento. A diferença entre as posições fornece a duração do evento. O exercício resolvido (9) é análogo a esse exercício. O resultado esperado é um vetor que identifique o evento e sua duração. duracao #&gt; evento1 evento2 evento3 evento4 evento5 evento6 evento7 evento8 #&gt; 1 1 1 1 2 1 2 1 #&gt; evento9 evento10 evento11 evento12 evento13 evento14 evento15 evento16 #&gt; 4 1 1 1 1 1 1 1 #&gt; evento17 evento18 evento19 evento20 evento21 evento22 evento23 evento24 #&gt; 1 1 2 1 1 1 2 3 #&gt; evento25 evento26 evento27 evento28 evento29 evento30 evento31 evento32 #&gt; 1 1 2 1 2 3 2 1 #&gt; evento33 evento34 evento35 evento36 evento37 evento38 evento39 #&gt; 1 1 1 1 1 1 3 EXERCÍCIO RESOLVIDO. Dado o vetor temp mostrado abaixo. c(NA, NA, 27L, 7L, 4L, 0L, 26L, 15L, 25L, NA, NA, NA, NA, 6L, 29L, 18L, 17L, 23L, 20L, 1L, 30L, 13L, NA, NA, NA, NA, NA, NA, NA, 19L) Como você pode codificar a obtenção de um vetor com zeros nos valores válidos e com números sequenciais dentro das falhas? # vetor lógico de falhas eh_faltante &lt;- is.na(temp) # soma cumulativa de falhas cums_gaps &lt;- cumsum(eh_faltante) # calculando soma a partir do início da falha tamanho_falhas &lt;- cums_gaps - cummax((!eh_faltante) * cums_gaps) tamanho_falhas [1] 1 2 0 0 0 0 0 0 0 1 2 3 4 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 0 Determine o tamanho da maior falha? max_falha &lt;- max(tamanho_falhas) max_falha [1] 7 Para os valores de velocidade (\\(V_h\\)) e a direção do vento (\\(\\theta\\)) (na convenção meteorológica): \\(V_h\\) = (10, 10, 10, 10, 14.142, 14.142, 14.142, 14.142, 0) \\(\\theta\\) = (270, 180, 360, 90, 225, 315, 135, 45, 0) Determine as componentes zonal e meridional do vento. \\[u = -V_{h} \\cdot sin(\\theta_{rad})\\] \\[v = -V_{h} \\cdot cos(\\theta_{rad})\\] Faça os cálculos necessários para reconstruir \\(V_h\\) e \\(\\theta\\) a partir de \\(u\\) e \\(v\\) determinados no item a. Por convenção, a direção do vento \\(\\theta\\) em condições calmas (\\(V_h\\) &lt; 0.5 m s-1) é assumida como 0°. \\[V_{h} = \\sqrt{(u^2 + v^2)}\\] \\[\\theta_{mat} = {\\rm atan2}(-u, -v)\\cdot\\frac{180}{\\pi}\\] \\[ \\theta = \\left\\{\\begin{matrix} \\theta_{mat} + 360 &amp; se &amp; \\theta_{mat} &lt; 0 \\\\ 0 &amp; se &amp; u = 0,\\: v = 0 \\end{matrix}\\right. \\] Como resultado monte um dataframe com todas variáveis derivadas. u v ws wd wd_uv dir 10 0 10.000 270 270 Oeste 0 10 10.000 180 180 Sul 0 -10 10.000 360 360 Norte -10 0 10.000 90 90 Leste 10 10 14.142 225 225 Sudoeste 10 -10 14.142 315 315 Noroeste -10 10 14.142 135 135 Sudeste -10 -10 14.142 45 45 Nordeste 0 0 0.000 0 0 Calmo Dica: ver figura abaixo. Para as séries de prec_obs e prec_sim calcule: a proporção corretamente prevista \\(PC = \\frac{wc+dc}{n}\\) o índice de sucesso crítico \\(CSI=\\frac{wc}{wc+wi+di}\\). Onde \\(wc\\) e \\(dc\\) são as previsões corretas de dias úmidos (\\(prec &gt; 0.25\\) mm dia-1) e secos respectivamente, \\(wi\\) e \\(di\\) são as previsões incorretas de dias úmidos e secos respectivamente. \\(n\\) é o n° total de previsões. prec_obs &lt;- c( 0, 0, 0, 0.5, 1, 6, 9, 0.2, 1, 0, 0, 0.25, 10, 15, 8, 3, 0, 0, 0, 0, 0, 0, 0.25, 0, 0, 0, 1, 5, 0, 20, 0, 0, 0, 0, 1, 1, 0, 2, 12, 1, 0, 0, 0, 0, 0, 0, 5, 5) prec_sim &lt;- c( 0, 0.2,0.1, 0, 0, 3, 1, 1, 1, 1, 0, 3, 0, 10, 4, 1,0.3,0.5,0.5, 0.5, 0.5, 0, 0.25, 0.25, 0.25, 0,0.5, 3, 0, 5, 0, 0, 0, 0, 0.5, 0, 0.25, 0.2, 0, 0.2, 0, 0, 0, 0, 1, 2, 1, 0) Escreva o código para calcular o coeficiente de correlação de Pearson (r) entre os vetores obs e prev. Confira seu resultado com a saída da função cor(obs, prev). obs &lt;- c(-0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16, 0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73, -0.49, -0.04, -0.11, 0.46, 2.02, -1.05) prev &lt;- c(NA, -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16, 0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73, -0.49, -0.04, -0.11, 0.46, 2.02) Construa uma função para converter valores de temperatura em K para °C e outra para converter ângulos de radianos para graus. Utilize dois exemplos para mostrar que suas funções funcionam corretamente. "]
]
