[
["data-wrangle.html", "9 Processamento de dados", " 9 Processamento de dados Neste capítulo veremos: um data frame aperfeiçoado, denominado tibble como arrumar seus dados em uma estrutura conveniente para a análise e visualização de dados como reestruturar os dados de uma forma versátil e fácil de entender como manipular os dados com uma ferramenta intuitiva e padronizada Existem diversas ferramentas da base do para realizar as operações listadas acima. Entretanto, elas não foram construídas para um objetivo comum e foram feitas por diferentes desenvolvedores e em diferentes fases da evolução do R. Por isso, elas podem parecer confusas, não seguem uma codificação consistente e não foram construídas pensando em uma interface integrada para o processamento de dados. Consequentemere, para usá-las é necessários um esforço significativo para entender a estrutura de dados de entrada de cada uma. A seguir, precisamos padronizar suas saídas para que sirvam de entrada para outra função (às vezes de outro pacote) que facilita a realização de uma próxima etapa do fluxo de trabalho. Muitas coisas no que foram desenvolvidas há 20 anos atrás são úteis até hoje. Mas as mesmas ferramentas podem não ser a melhor solução para os problemas contemporâneos. Alterar os códigos da base do é uma tarefa complicada devido a cadeia de dependências do código fonte e dos pacotes dos milhares de contribuidores. Então, grande parte das inovações no estão ocorrendo na forma de pacotes. Um exemplo é o conjunto de pacotes tidyverse desenvolvido para suprir a necessidade de ferramentas efetivas e integradas para ciência de dados (Figura 9.1). Figure 9.1: Modelo de ferramentas empregadas em ciência de dados. Adaptado de Wickham and Grolemund (2017). O termo tidyverse pode ser traduzido como ‘universo arrumado’ e consiste em um pacote do que agrupa pacotes (Figura 9.2) que compartilham uma filosofia comum de design, gramática (Wickham et al. 2017) e estrutura de dados (Wickham 2014). Consequentemente, o tidyverse tem sido amplamente utilizado pela comunidade de usuários e desenvolvedores do . Além de uma abordagem mais coesa e consistente para realizar as tarefas envolvidas no processamento de dados, os códigos são mais eficientes (que a base do ), legíveis e com sintaxe mais fácil de lembrar. Figure 9.2: Coleção de pacotes do tidyverse. References "],
["pre-requisitos-2.html", "9.1 Pré-requisitos", " 9.1 Pré-requisitos O pacote tidyverse torna fácil de instalar e carregar os pacotes do tidyverse com apenas uma chamada à função: install.packages(&quot;tidyverse&quot;) E da mesma forma carregamos o conjunto de pacotes com: library(tidyverse) #&gt; + ggplot2 2.2.1 Date: 2018-06-24 #&gt; + tibble 1.4.2 R: 3.4.4 #&gt; + tidyr 0.8.1 OS: Ubuntu 14.04.5 LTS #&gt; + readr 1.1.1 GUI: X11 #&gt; + purrr 0.2.5 Locale: en_US.UTF-8 #&gt; + dplyr 0.7.5 TZ: America/Sao_Paulo #&gt; + stringr 1.3.1 #&gt; + forcats 0.3.0 #&gt; ── Conflicts ──────────────────────────────────────────────────── #&gt; * filter(), from dplyr, masks stats::filter() #&gt; * lag(), from dplyr, masks stats::lag() Ao carregar o pacote tidyverse é mostrado no console os pacotes que foram carregados. À direita são mostradas as configurações e informações sobre o seu sistema operacional. Na parte inferior, há uma mensagem sobre os conflitos entre as funções da base do R (ou de outros pacotes) que tem mesmo nome que as de algum pacote do tidyverse. A função do pacote carregado mais recentemente terá prioridade de uso. No caso acima, a função filter() do dplyr sobrepôs a função filter() do pacote stats da base do R. Em situações como esta é melhor deixar explícito no seu código a chamada à função usando pacote::funcao(). Neste capítulo além do tidyverse usaremos outros pacotes que já podemos instalar: pacotes &lt;- c(&quot;openair&quot;, &quot;lubridate&quot;, &quot;scales&quot;, &quot;rio&quot;) easypackages::libraries(pacotes) 9.1.1 Dados Para este capítulo utilizaremos alguns conjuntos de dados para exemplificar o uso das principais ferramentas de maniulação de dados do tidyverse. Dados climatológicos de precipitação e temperatura máxima anual de estações meteorológicas do INMET localizadas no estado do Rio Grande do Sul. clima_file_url &lt;- &quot;https://github.com/lhmet/adar-ufsm/blob/master/data/clima-rs.RDS?raw=true&quot; # dados de exemplo clima_rs &lt;- import(clima_file_url, format = &quot;RDS&quot;) clima_rs codigo estacao uf prec tmax 83931 Alegrete RS 1492.2 25.4 83980 Bagé RS 1299.9 24.1 83941 Bento Gonçalves RS 1683.7 23.0 83919 Bom Jesus RS 1807.3 20.3 83963 Cachoeira do Sul RS 1477.1 25.1 83942 Caxias do Sul RS 1823.0 21.8 83912 Cruz Alta RS 1630.7 24.5 83964 Encruzilhada do Sul RS 1510.8 22.5 83915 Guaporé RS 1758.7 24.7 83881 Iraí RS 1806.7 27.1 83929 Itaqui RS 1369.4 26.2 83916 Lagoa Vermelha RS 1691.1 23.0 83880 Palmeira das Missões RS 1747.8 24.0 83914 Passo Fundo RS 1803.1 23.6 83967 Porto Alegre RS 1320.2 24.8 83995 Rio Grande RS 1233.6 21.7 83936 Santa Maria RS 1616.8 24.9 83997 Santa Vitória do Palmar RS 1228.9 21.8 83957 São Gabriel RS 1313.9 25.0 83907 São Luiz Gonzaga RS 1770.9 26.1 83966 Tapes RS 1349.8 23.8 83948 Torres RS 1363.2 22.3 83927 Uruguaiana RS 1647.4 25.8 Um exemplo minimalista de dados referentes a séries temporais de precipitação anual observada em estações meteorológicas. prec_anual &lt;- data.frame( site = c( &quot;A001&quot;, &quot;A001&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A003&quot;, &quot;A803&quot;, &quot;A803&quot; ), ano = c(2000:2001, 2000:2002, 2004, 2005, 2006), prec = c(1800, 1400, 1750, 1470, 1630, 1300, 1950, 1100) ) prec_anual site ano prec A001 2000 1800 A001 2001 1400 A002 2000 1750 A002 2001 1470 A002 2002 1630 A003 2004 1300 A803 2005 1950 A803 2006 1100 "],
["tibble-um-data-frame-aperfeicoado.html", "9.2 tibble: um data frame aperfeiçoado", " 9.2 tibble: um data frame aperfeiçoado Data frames são a unidade fundamental de armazenamento de dados retangulares no R. O pacote tibble estende a classe data frame da base do com aperfeiçoamentos relacionados a impressão de dados (mais amigável e versátil), a seleção de dados e a manipulação de dados do tipo factor. O novo objeto é chamdo de tibble e sua classde de tbl_df. 9.2.1 Funcionalidades do tibble Para ilustrar algumas vantagens do tibble, vamos usar o data frame prec_anual. A criação destes dados como tibble é feita com a função de mesmo nome do pacote: tibble(). prec_anual_tbl &lt;- tibble( site = c( &quot;A001&quot;, &quot;A001&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A003&quot;, &quot;A803&quot;, &quot;A803&quot; ), ano = c(2000:2001, 2000:2002, 2004, 2005, 2006), prec = c(1800, 1400, 1750, 1470, 1630, 1300, 1950, 1100) ) O exemplo acima é ilustrativo, pois um data frame pode ser convertido em um tibble simplesmente com a função as_tibble(): prec_anual_tbl &lt;- as_tibble(prec_anual) prec_anual_tbl #&gt; # A tibble: 8 x 3 #&gt; site ano prec #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2000 1800 #&gt; 2 A001 2001 1400 #&gt; 3 A002 2000 1750 #&gt; 4 A002 2001 1470 #&gt; 5 A002 2002 1630 #&gt; 6 A003 2004 1300 #&gt; 7 A803 2005 1950 #&gt; 8 A803 2006 1100 Com o tibble acima, as principais diferenças entre um tibble e um data frame podem ser enfatizadas. quando impresso no console do R, o tibble já mostra a classe de cada variável. vetores caracteres não são interpretados como factors em um tibble, em contraste a data.frame() que faz a coerção para factor e não conserva o nome das variáveis. Este comportamento padrão pode causar problemas aos usuários desavisados em análises posteriores. str(data.frame(&quot;temp. do ar&quot; = &quot;18&quot;)) #&gt; &#39;data.frame&#39;: 1 obs. of 1 variable: #&gt; $ temp..do.ar: Factor w/ 1 level &quot;18&quot;: 1 permite usar seus próprios argumentos prévios para definir variáveis durante a criação do tibble; veja o exemplo abaixo, onde a int prec(intensidade da precipitação) é baseada na razão da precipitação (prec) pelo número de dias no ano. prec_anual_tbl &lt;- tibble( site = c( &quot;A001&quot;, &quot;A001&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A002&quot;, &quot;A003&quot;, &quot;A803&quot;, &quot;A803&quot; ), ano = c(2000:2001, 2000:2002, 2004, 2005, 2006), prec = c(1800, 1400, 1750, 1470, 1630, 1300, 1950, 1100), &quot;int prec&quot; = prec / 365.25 ) prec_anual_tbl #&gt; # A tibble: 8 x 4 #&gt; site ano prec `int prec` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2000 1800 4.93 #&gt; 2 A001 2001 1400 3.83 #&gt; 3 A002 2000 1750 4.79 #&gt; 4 A002 2001 1470 4.02 #&gt; 5 A002 2002 1630 4.46 #&gt; 6 A003 2004 1300 3.56 #&gt; 7 A803 2005 1950 5.34 #&gt; 8 A803 2006 1100 3.01 nunca adiciona nomes às linhas (row.names) # nomes das linhas de um data frame são carregados adiante subset(prec_anual, ano == 2001) #&gt; site ano prec #&gt; 2 A001 2001 1400 #&gt; 4 A002 2001 1470 # tibble não possui nome de linhas (rownames) subset(prec_anual_tbl, ano == 2001) #&gt; # A tibble: 2 x 4 #&gt; site ano prec `int prec` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2001 1400 3.83 #&gt; 2 A002 2001 1470 4.02 a impressão de um tibble mostra as dez primeiras linhas e a quantidade de colunas mostradas é ajustada ao tamanho da janela do console. As opções de controle default da impressão de tibbles no console pode ser configuradas através da função de opções de configuração global do R: m &lt;- 15 n &lt;- 3 options( tibble.print_max = m, tibble.print_min = n ) Com a configuração acima, será impresso no console do R n = 3 linhas do tibble se ele tiver mais de m = 15 linhas. nrow(clima_rs) &gt; 15 #&gt; [1] TRUE # coersão do data.frame clima_rs para tibble clima_rs_tbl &lt;- as_tibble(clima_rs) Para restaurar as opções default use: options( tibble.print_max = NULL, tibble.print_min = NULL ) clima_rs_tbl #&gt; # A tibble: 23 x 5 #&gt; codigo estacao uf prec tmax #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 83931 Alegrete RS 1492. 25.4 #&gt; 2 83980 Bagé RS 1300. 24.1 #&gt; 3 83941 Bento Gonçalves RS 1684. 23 #&gt; 4 83919 Bom Jesus RS 1807. 20.3 #&gt; 5 83963 Cachoeira do Sul RS 1477. 25.1 #&gt; 6 83942 Caxias do Sul RS 1823 21.8 #&gt; 7 83912 Cruz Alta RS 1631. 24.5 #&gt; 8 83964 Encruzilhada do Sul RS 1511. 22.5 #&gt; 9 83915 Guaporé RS 1759. 24.7 #&gt; 10 83881 Iraí RS 1807. 27.1 #&gt; # ... with 13 more rows Uma alternativa útil para inspecionar mais detalhadamente os dados é a função tibble::glimpse(). glimpse(clima_rs) #&gt; Observations: 23 #&gt; Variables: 5 #&gt; $ codigo &lt;chr&gt; &quot;83931&quot;, &quot;83980&quot;, &quot;83941&quot;, &quot;83919&quot;, &quot;83963&quot;, &quot;83942&quot;, ... #&gt; $ estacao &lt;chr&gt; &quot;Alegrete&quot;, &quot;Bagé&quot;, &quot;Bento Gonçalves&quot;, &quot;Bom Jesus&quot;, &quot;C... #&gt; $ uf &lt;chr&gt; &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, &quot;RS&quot;, ... #&gt; $ prec &lt;dbl&gt; 1492.2, 1299.9, 1683.7, 1807.3, 1477.1, 1823.0, 1630.7... #&gt; $ tmax &lt;dbl&gt; 25.4, 24.1, 23.0, 20.3, 25.1, 21.8, 24.5, 22.5, 24.7, ... Lembre-se também, da função utils::View() para visualizar os dados no RStudio. View(clima_rs) Outros aspectos diferencias do tibble podem consultados na vinheta do referido pacote (vignette(&quot;tibble&quot;)). "],
["restruturacao-de-dados-retangulares.html", "9.3 Restruturação de dados retangulares", " 9.3 Restruturação de dados retangulares Até 80% do tempo da análise dados é dedicada ao processo de limpeza e preparação dos dados (Dasu and Johnson 2003, New York Times 2014/08/18). 9.3.1 Dados arrumados O conceito &quot;dados arrumados&quot; foi estabelecido por Wickham (2014) e representa uma forma padronizada de conectar a estrutura (formato) de um conjunto de dados a sua semântica (significado). Dados bem estruturados servem para: fornecer dados propícios para o processamento e análise de dados por softwares; revelar informações e facilitar a percepção de padrões Dados no &quot;formato arrumado&quot; atendem as seguintes regras para dados retangulares: cada variável está em uma coluna cada observação corresponde a uma linha cada valor corresponde a uma célula cada tipo de unidade observacional deve compor uma tabela Como sinônimo de observações você pode encontrar os termos: registros, casos, exemplos, instâncias ou amostras dependendo da área de aplicação. Estrutura de dados padronizados Um exemplo de dados no formato arrumado é o tibble prec_anual_tbl mostrado abaixo: site ano prec intensidade A001 2000 1800 4.928131 A001 2001 1400 3.832991 A002 2000 1750 4.791239 A002 2001 1470 4.024641 A002 2002 1630 4.462697 A003 2004 1300 3.559206 A803 2005 1950 5.338809 A803 2006 1100 3.011636 Os dados acima tem duas variáveis: precipitação (prec) e intensidade da precipitação (intensidade). As unidades observacionais são as colunas site e ano. A primeira unidade observacional informa o ponto de amostragem espacial e a segunda o ponto de amostragem temporal. Uma variável contém todos valores que medem um mesmo atributo ao longo das unidades observacionais. Uma observação contém todos valores medidos na mesma unidade observacional ao longo dos atributos. Cada valor (número ou caractere) pertence a uma variável e uma observação. Exemplo de diferentes tipos de unidades observacionais são a tabela com a séries temporais dos elementos meteorológicos (exemplo acima) e a tabela com os metadados das estações de superfície que contém atributos das estações meteorológicas (site no exemplo acima), tais como: longitude, latitude, altitude, nome, município, estado e etc. A estrutura de dados &quot;arrumados&quot; parece óbvia, mas na prática, dados neste formatos são raros de serem encontrados. As razões para isso incluem: quem projeta a coleta e o registro de dados nem sempre é aquele que gasta tempo trabalhando sobre os dados; a organização dos dados busca tornar o registro de dados o mais fácil possível; Consequente, dados reais sempre precisarão ser arrumados. O primeiro passo é identifição das variáveis e das observações. O passo seguinte é resolver os seguintes problemas mais comuns (Wickham and Grolemund 2017): uma variável deve ser distribuída ao longo das colunas uma observação deve ser distribuída ao longo das linhas Essas duas operações são realizadas com as principais funções do pacote tidyr: gather(), que pode ser traduzida como reunir (nas linhas); spread() que pode ser traduzida como espalhar (nas colunas) 9.3.2 Formatos de dados mais comuns O pacote tidyr é a extensão do que fornece funcionalidades para reestruturar os dados entre diferentes formatos. Os principais formatos de dados são: dados longos, são tabelas com mais valores ao longo das linhas; geralmente mistura variáveis com observações; dados amplos, são tabelas com valores mais dstribuínos nas colunas, geralmente contém pelo menos uma unidade observacional misturada com variáveis; 9.3.2.1 Formato de dados longo Para exemplificar o formato de dados longo vamos partir dos &quot;dados arrumados&quot; do exemplo, prec_anual_tbl. Primeiro vamos renomear a variável int prec para intensidade para seguir um o padrão de nome das variáveis mais conveniente para o seu processamento no R. prec_anual_tbl &lt;- rename( prec_anual_tbl, &quot;intensidade&quot; = `int prec` ) prec_anual_tbl #&gt; # A tibble: 8 x 4 #&gt; site ano prec intensidade #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2000 1800 4.93 #&gt; 2 A001 2001 1400 3.83 #&gt; 3 A002 2000 1750 4.79 #&gt; 4 A002 2001 1470 4.02 #&gt; 5 A002 2002 1630 4.46 #&gt; 6 A003 2004 1300 3.56 #&gt; 7 A803 2005 1950 5.34 #&gt; 8 A803 2006 1100 3.01 Vamos usar a função gather() para reestruturar os dados prec_anual_tbl em uma nova tabela de dados que chamaremos prec_anual_long. Na nova tabela, manteremos as colunas site, ano e teremos dois novos pares de variáveis: variavel e valor. Na coluna variavel será distribuído o nome das variáveis prec e intensidade. A coluna valorreunirá os valores das variáveis prec e intensidade. prec_anual_long &lt;- gather( data = prec_anual_tbl, key = variavel, value = medida, prec, intensidade ) prec_anual_long #&gt; # A tibble: 16 x 4 #&gt; site ano variavel medida #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A001 2000 prec 1800 #&gt; 2 A001 2001 prec 1400 #&gt; 3 A002 2000 prec 1750 #&gt; 4 A002 2001 prec 1470 #&gt; 5 A002 2002 prec 1630 #&gt; 6 A003 2004 prec 1300 #&gt; 7 A803 2005 prec 1950 #&gt; 8 A803 2006 prec 1100 #&gt; 9 A001 2000 intensidade 4.93 #&gt; 10 A001 2001 intensidade 3.83 #&gt; 11 A002 2000 intensidade 4.79 #&gt; 12 A002 2001 intensidade 4.02 #&gt; 13 A002 2002 intensidade 4.46 #&gt; 14 A003 2004 intensidade 3.56 #&gt; 15 A803 2005 intensidade 5.34 #&gt; 16 A803 2006 intensidade 3.01 O código acima demonstra os principais argumentos requeridos pela função gather: data = prec_anual_tbl, o data frame ou tibble que será reestruturado; key = variavel, nome que nós escolhemos para dar à nova coluna que distribuirá os nomes das variáveis dos dados de entrada. value = medida, nome que nós escolhemos para dar à nova coluna que reunirá os valores das variáveis dos dados de entrada; ..., lista com o nome das variáveis, no código acima corresponde à prec, intensidade; As demais colunas dos dados (site e ano) serão mantidas inalteradas e seus valores serão repetidos quando necessário. Como em outras funções dos pacotes do tidyverse você perceberá que os argumentos não são especificados como caracteres e sim como nomes (ou seja o nome da variável sem aspas), como aqueles usados quando definimos variáveis (p.ex.: nome_var &lt;- 10). Os argumentos key e value podem ser especificados à gosto do usuário e não precisam ter relação com os dados existentes. Se nós desejássemos que todas colunas do data frame fossem reunidas em uma nova coluna atributo e os seus valores em uma nova coluna valor, isso poderia ser feito simplesmente sem especificar variáveis de interesse (prec, intensidade) no trecho de código anterior. A tabela de dados resultante conterá todos os 32 pares de valores, formados pelas 4 colunas por 8 linhas, dos dados originais: prec_anual_longo &lt;- gather( prec_anual_tbl, key = atributo, value = valor ) prec_anual_longo #&gt; # A tibble: 32 x 2 #&gt; atributo valor #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 site A001 #&gt; 2 site A001 #&gt; 3 site A002 #&gt; 4 site A002 #&gt; 5 site A002 #&gt; 6 site A003 #&gt; 7 site A803 #&gt; 8 site A803 #&gt; 9 ano 2000 #&gt; 10 ano 2001 #&gt; # ... with 22 more rows Se não forem especificados nomes para os argumentos key e value na chamada da função gather, serão atribuídos os valores default: key e value. gather(prec_anual_tbl) #&gt; # A tibble: 32 x 2 #&gt; key value #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 site A001 #&gt; 2 site A001 #&gt; 3 site A002 #&gt; 4 site A002 #&gt; 5 site A002 #&gt; 6 site A003 #&gt; 7 site A803 #&gt; 8 site A803 #&gt; 9 ano 2000 #&gt; 10 ano 2001 #&gt; # ... with 22 more rows 9.3.2.2 Formato de dados amplo Utilizando os dados meteo_long, vamos reestruturá-lo no formato amplo para demostrar a funcionalidade da função spread(). Esta função é complementar à gather(). prec_anual_long #&gt; # A tibble: 16 x 4 #&gt; site ano variavel medida #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A001 2000 prec 1800 #&gt; 2 A001 2001 prec 1400 #&gt; 3 A002 2000 prec 1750 #&gt; 4 A002 2001 prec 1470 #&gt; 5 A002 2002 prec 1630 #&gt; 6 A003 2004 prec 1300 #&gt; 7 A803 2005 prec 1950 #&gt; 8 A803 2006 prec 1100 #&gt; 9 A001 2000 intensidade 4.93 #&gt; 10 A001 2001 intensidade 3.83 #&gt; 11 A002 2000 intensidade 4.79 #&gt; 12 A002 2001 intensidade 4.02 #&gt; 13 A002 2002 intensidade 4.46 #&gt; 14 A003 2004 intensidade 3.56 #&gt; 15 A803 2005 intensidade 5.34 #&gt; 16 A803 2006 intensidade 3.01 Nosso objetivo é então gerar uma nova tabela de dados reestruturada, de forma que os nomes das variáveis (contidos na coluna variavel) sejam distribuídos em duas colunas. Estas colunas receberão os nomes prec e intensidade e serão preenchidas com os valores armazenados na coluna medida. Para fazer isso usamos o seguinte código: prec_anual_amplo &lt;- spread( data = prec_anual_long, key = variavel, value = medida ) prec_anual_amplo #&gt; # A tibble: 8 x 4 #&gt; site ano intensidade prec #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2000 4.93 1800 #&gt; 2 A001 2001 3.83 1400 #&gt; 3 A002 2000 4.79 1750 #&gt; 4 A002 2001 4.02 1470 #&gt; 5 A002 2002 4.46 1630 #&gt; 6 A003 2004 3.56 1300 #&gt; 7 A803 2005 5.34 1950 #&gt; 8 A803 2006 3.01 1100 Esta operação serviu para colocar os dados originais (prec_anual_long) no formato &quot;arrumado&quot; (prec_anual_amplo). 9.3.3 Funções adicionais do tidyr Você pode unir duas colunas inserindo um separador entre elas com a função unite(): (prec_anual_long_u &lt;- unite(prec_anual_long, col = site_ano, site, ano, sep = &quot;_&quot;)) #&gt; # A tibble: 16 x 3 #&gt; site_ano variavel medida #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A001_2000 prec 1800 #&gt; 2 A001_2001 prec 1400 #&gt; 3 A002_2000 prec 1750 #&gt; 4 A002_2001 prec 1470 #&gt; 5 A002_2002 prec 1630 #&gt; 6 A003_2004 prec 1300 #&gt; 7 A803_2005 prec 1950 #&gt; 8 A803_2006 prec 1100 #&gt; 9 A001_2000 intensidade 4.93 #&gt; 10 A001_2001 intensidade 3.83 #&gt; 11 A002_2000 intensidade 4.79 #&gt; 12 A002_2001 intensidade 4.02 #&gt; 13 A002_2002 intensidade 4.46 #&gt; 14 A003_2004 intensidade 3.56 #&gt; 15 A803_2005 intensidade 5.34 #&gt; 16 A803_2006 intensidade 3.01 Se ao contrário, você quer separar uma coluna em duas variáveis, utilize a função separate(): separate(prec_anual_long_u, col = site_ano, sep = &quot;_&quot;, into = c(&quot;site&quot;, &quot;ano&quot;)) #&gt; # A tibble: 16 x 4 #&gt; site ano variavel medida #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A001 2000 prec 1800 #&gt; 2 A001 2001 prec 1400 #&gt; 3 A002 2000 prec 1750 #&gt; 4 A002 2001 prec 1470 #&gt; 5 A002 2002 prec 1630 #&gt; 6 A003 2004 prec 1300 #&gt; 7 A803 2005 prec 1950 #&gt; 8 A803 2006 prec 1100 #&gt; 9 A001 2000 intensidade 4.93 #&gt; 10 A001 2001 intensidade 3.83 #&gt; 11 A002 2000 intensidade 4.79 #&gt; 12 A002 2001 intensidade 4.02 #&gt; 13 A002 2002 intensidade 4.46 #&gt; 14 A003 2004 intensidade 3.56 #&gt; 15 A803 2005 intensidade 5.34 #&gt; 16 A803 2006 intensidade 3.01 Para completar valores das variáveis para unidades observacionais faltantes podemos utilizar a função complete(): prec_anual #&gt; site ano prec #&gt; 1 A001 2000 1800 #&gt; 2 A001 2001 1400 #&gt; 3 A002 2000 1750 #&gt; 4 A002 2001 1470 #&gt; 5 A002 2002 1630 #&gt; 6 A003 2004 1300 #&gt; 7 A803 2005 1950 #&gt; 8 A803 2006 1100 prec_anual_comp &lt;- complete( prec_anual, site, ano ) prec_anual_comp #&gt; # A tibble: 24 x 3 #&gt; site ano prec #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A001 2000 1800 #&gt; 2 A001 2001 1400 #&gt; 3 A001 2002 NA #&gt; 4 A001 2004 NA #&gt; 5 A001 2005 NA #&gt; 6 A001 2006 NA #&gt; 7 A002 2000 1750 #&gt; 8 A002 2001 1470 #&gt; 9 A002 2002 1630 #&gt; 10 A002 2004 NA #&gt; # ... with 14 more rows References "],
["manipulacao-de-dados.html", "9.4 Manipulação de dados", " 9.4 Manipulação de dados Com os dados arrumados, a próxima etapa é a manipulação dos dados. O pacote dplyr oferece um conjunto de funções que facilita as operações mais comuns para lidar com dados retangulares de uma forma bem pensada. Os verbos fundamentais desta gramática de manipulação de dados são: select(), para selecionar variáveis; filter(), para filtrar observações; arrange(), para classificar variáveis; mutate(), para criar e transformar variáveis; group_by(), para agrupar observações; summarise(), para resumir os dados com medidas estatísticas descritivas; Estes verbos possuem uma sintaxe consistente com uma sentença gramatical: verbo(sujeito, complemento) traduzindo de outra forma: função(dados, z = x + y) o verbo é a função do dplyr; o sujeito (dados) é quem sofre a ação e é sempre o primeiro argumento, nomeado (.data); o complemento são expressões que podem ser usadas como argumentos (o que é representado pela reticência ... no segundo argumento); isso ficará mais claro nos exemplos mais a frente; Os verbos listados anteriormente possuem versões equivalentes na base do r rblue. Então, por que usar o dplyr ? é muito mais rápido de se aprender, com poucas funções (ou verbos) nomeadas intuitivamente; as funções do dplyr são mais rápidas (parte dos códigos são programados em C++); trabalha bem com dados arrumados e também com sistemas de banco de dados as funções foram projetadas para trabalharem juntas na solução diversos problemas de processamento de dados; 9.4.1 Seleção de variáveis Para selecionar somente variáveis de interesse em uma tabela de dados podemos usar a função dplyr::select(). Nos dados clima_rs_tbl se desejamos selecionar apenas as colunas estacao e tmax aplicamos a select() da seguinte forma: select(clima_rs_tbl, estacao, tmax) #&gt; # A tibble: 23 x 2 #&gt; estacao tmax #&gt; * &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alegrete 25.4 #&gt; 2 Bagé 24.1 #&gt; 3 Bento Gonçalves 23 #&gt; 4 Bom Jesus 20.3 #&gt; 5 Cachoeira do Sul 25.1 #&gt; 6 Caxias do Sul 21.8 #&gt; 7 Cruz Alta 24.5 #&gt; 8 Encruzilhada do Sul 22.5 #&gt; 9 Guaporé 24.7 #&gt; 10 Iraí 27.1 #&gt; # ... with 13 more rows O resultado é um subconjunto dos dados originais contendo apenas as colunas nomeadas nos argumentos seguintes aos dados de entrada. 9.4.2 Seleção de observações filter() slice() 9.4.3 Reordenando dados arrange(desc()) 9.4.4 Criando e renomeando variáveis mutate() rename() 9.4.5 Agregando observações 9.4.6 Agrupando observações 9.4.7 Códigos como fluxogramas A manipulação de dados requer uma organização apropriada do código. A medida que novas etapas do fluxo de trabalho vão sendo implementadas o código expande-se. As etapas vão sendo implementadas de forma sequencial, combinando funções que geram saídas que servirão de entrada para outras funções na cadeia de processamento. Para manter o código simplificado, legível, claro e exlícito utilizaremos o operador pipe %&gt;%, que vem do pacote magrittr. os pacotes tidyr e dplyr integram-se muito bem com o %&gt;%, por isso ele é automaticamente carregado com o tidyverse. Isso leva a uma dificuldade de ler funções aninhadas e um código desordenado. # exemplo simples para aplicar uma função quadrado &lt;- function(x) x ^ 2 a &lt;- 1:4 quadrado(a) #&gt; [1] 1 4 9 16 a %&gt;% quadrado() #&gt; [1] 1 4 9 16 Este operador irá transmitir um valor, ou o resultado de uma expressão, como primeiro argumento da próxima função/expressão chamada. c(1, 10, 100, 1000) %&gt;% cumsum() %&gt;% mean() #&gt; [1] 308.5 Por exemplo, uma função para filtrar os dados pode ser escrito como: # exemplo com um dataframe data(airquality) subset(airquality, Ozone == 23) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 7 23 299 8.6 65 5 7 #&gt; 28 23 13 12.0 67 5 28 #&gt; 44 23 148 8.0 82 6 13 #&gt; 110 23 115 7.4 76 8 18 #&gt; 131 23 220 10.3 78 9 8 #&gt; 145 23 14 9.2 71 9 22 # ou airquality %&gt;% subset(Ozone == 23) %&gt;% `[[`(., &quot;Wind&quot;) %&gt;% mean() #&gt; [1] 9.25 Ambas funções realizam a mesma tarefa e o benefício de usar %&gt;% fica mais evidente. Dessa forma, quando precisamos aplicar várias funções o fluxograma das operações fica mais claro e o código mais legível. Vamos utilizar o conjunto de dados airquality do R, para selecionar algumas variáveis, filtrar algum dados e obter a média da temperatura do ar: # opção aninhada res_anin &lt;- summarize(filter(select(airquality, Ozone, Temp), Ozone &gt; 23), tmed = mean(Temp)) res_anin #&gt; tmed #&gt; 1 82.72059 # opção por etapas etapa1 &lt;- select(airquality, Ozone, Temp) etapa2 &lt;- filter(etapa1, Ozone &gt; 23) res_etapas &lt;- summarise(etapa2, tmed = mean(Temp)) # opção usando pipe res_pipe &lt;- airquality %&gt;% select(Ozone, Temp) %&gt;% filter(Ozone &gt; 23) %&gt;% summarise(tmed = mean(Temp)) res_pipe #&gt; tmed #&gt; 1 82.72059 Quando as suas tarefas aumentam o operador pipe %&gt;% torna-se mais útil e o seu código fica mais legível. 9.4.8 Combinação de dados &lt;tipo&gt;_join, para combinar dados usando variáveis em comum a dois data frames; "],
["exercicios-3.html", "9.5 Exercícios", " 9.5 Exercícios Vamos alterar a estrutura dos dados: ao invés dos dados serem distribuídos ao longo das colunas, vamos estruturá-los como série temporal, ou seja cada valor mensal corresponderá a uma linha. # converte a matriz de dados para um vetor (em sequencia cronológica) soi_v &lt;- c(t(soi[, -1])) # criando um dataframe com valores de SOI, mes e ano soi_df &lt;- data.frame( ano = rep(soi$YEAR, each = 12), mes = rep(1:12, length(soi[, 1])), soi = soi_v ) head(soi_df) "],
["exemplo-de-manipulacao-de-dados.html", "9.6 Exemplo de manipulação de dados", " 9.6 Exemplo de manipulação de dados Nesta seção vamos fazer um estudo de caso para demostrar diversas funções do tidyverse aplicadas ao conjunto de dados de precipitação horária de Santa Maria-RS. Objetivos: determinar a quantidade de dados de chuva horária faltantes em termos absolutos (número de casos) e relativos (% do total); visualizar por meio de um gráfico a variação temporal da chuva horária com a identificação das falhas determinar o número de dados faltantes por ano e verifique se o seu resultado confere com aquele da inspeção visual do gráfico; determinar o valor da chuva máxima horária e a data de ocorrência do evento; determinar a chuva máxima diária e a data de ocorrência do evento; fazer o pluviograma mensal climatológico (médias dos totais mensais de precipitação); plotar os totais anuais de chuva para cada ano; determinar a frequência de ocorrência da chuva para cada ano; determinar a intensidade média da chuva (em mm/dia) em Santa Maria; determinar a frequência de ocorrência de chuva (ou seja, o número de casos em que choveu) para cada hora do dia (das 0 às 23 h) determinar a frequência de ocorrência (%) de precipitação para cada dia da semana; Dados # definindo os horários como UTC para essa sessão do R Sys.setenv(TZ = &quot;UTC&quot;) hprec_url &lt;- &quot;https://github.com/lhmet/adar-ufsm/blob/master/data/hprec_sm.RDS?raw=true&quot; # importa dados, hprec: precipitação horária da EMA de SM hprec &lt;- rio::import( file = hprec_url, format = &quot;RDS&quot; ) str(hprec) #&gt; &#39;data.frame&#39;: 96428 obs. of 3 variables: #&gt; $ site: chr &quot;A803&quot; &quot;A803&quot; &quot;A803&quot; &quot;A803&quot; ... #&gt; $ date: chr &quot;2004-01-01 00:00:00&quot; &quot;2004-01-01 01:00:00&quot; &quot;2004-01-01 02:00:00&quot; &quot;2004-01-01 03:00:00&quot; ... #&gt; $ prec: num 0 0 0 0 0 0 0 0 0 0 ... summary(hprec) #&gt; site date prec #&gt; Length:96428 Length:96428 Min. :-9999.0 #&gt; Class :character Class :character 1st Qu.: 0.0 #&gt; Mode :character Mode :character Median : 0.0 #&gt; Mean : -425.8 #&gt; 3rd Qu.: 0.0 #&gt; Max. : 48.0 Conversão para tibble e atribuição de dados faltantes: hprec &lt;- as_tibble(hprec) %&gt;% mutate(prec = ifelse(prec &lt; 0, NA, prec)) hprec #&gt; # A tibble: 96,428 x 3 #&gt; site date prec #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A803 2004-01-01 00:00:00 0 #&gt; 2 A803 2004-01-01 01:00:00 0 #&gt; 3 A803 2004-01-01 02:00:00 0 #&gt; 4 A803 2004-01-01 03:00:00 0 #&gt; 5 A803 2004-01-01 04:00:00 0 #&gt; 6 A803 2004-01-01 05:00:00 0 #&gt; 7 A803 2004-01-01 06:00:00 0 #&gt; 8 A803 2004-01-01 07:00:00 0 #&gt; 9 A803 2004-01-01 08:00:00 0 #&gt; 10 A803 2004-01-01 09:00:00 0 #&gt; # ... with 96,418 more rows summary(hprec) #&gt; site date prec #&gt; Length:96428 Length:96428 Min. : 0.000 #&gt; Class :character Class :character 1st Qu.: 0.000 #&gt; Mode :character Mode :character Median : 0.000 #&gt; Mean : 0.192 #&gt; 3rd Qu.: 0.000 #&gt; Max. :48.000 #&gt; NA&#39;s :4108 1. Disponibilidade de dados. Determine a quantidade de dados de chuva horária faltantes em termos absolutos (número de casos) e relativos (% do total). # converte data e horas para POSIX hprec &lt;- mutate(hprec, date = as.POSIXct(date)) # número de casos faltantes sum(is.na(hprec$prec)) #&gt; [1] 4108 # porcentagem de casos faltantes sum(is.na(hprec$prec)) / nrow(hprec) * 100 #&gt; [1] 4.260173 Faça um gráfico da chuva horária no tempo que permita identificar os períodos de falhas e que os anos sejam visíveis no eixo x. O gráfico deve ter aspecto similar ao mostrado na Figura abaixo. # dados para plot; adiciona uma prec modificada, para mostrar dados faltantes hprec_plot &lt;- mutate( hprec , faltante = ifelse(is.na(prec), -2, NA) ) hprec_plot &lt;- as.data.frame(hprec_plot) # plot da chuva no tempo # tp &lt;- timePlot(selectByDate(hprec_plot, year = 2014) tp &lt;- timePlot( hprec_plot , c(&quot;prec&quot;, &quot;faltante&quot;) , group = TRUE , plot.type = &quot;h&quot; , lty = 1 , col = c(1, 2) , ylab = &quot;Prec (mm/h)&quot; , date.format = &quot;%Y\\n%b&quot; ) Baseado na inspeção visual do seu gráfico qual o ano que tem mais falhas? Calcule o número de dados faltantes por ano e verifique se o seu resultado confere com aquele da inspeção visual do gráfico. Apresente esses resultados em uma tabela. ###### # R: por inpeção visual sugere o ano de 2005 devido a sequência de falhas consecutivas # Por meio do calculo verifica-se que foi 2011, uma falha longa contínua ###### tab_falt &lt;- hprec %&gt;% # agrupa os dados por anos group_by(year = lubridate::year(date)) %&gt;% # resumo estatístico (soma, porcentagem) da prec para cada componente do grupo summarise( n_falt = sum(is.na(prec)) , perc_falt = round(sum(is.na(prec)) / n() * 100, 1) ) tab_falt #&gt; # A tibble: 11 x 3 #&gt; year n_falt perc_falt #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2004 155 1.8 #&gt; 2 2005 816 9.3 #&gt; 3 2006 427 4.9 #&gt; 4 2007 290 3.3 #&gt; 5 2008 50 0.6 #&gt; 6 2009 42 0.5 #&gt; 7 2010 62 0.7 #&gt; 8 2011 1120 12.8 #&gt; 9 2012 313 3.6 #&gt; 10 2013 15 0.2 #&gt; 11 2014 818 9.3 2. Estatísticas básicas. Desconsidere os registros faltantes em seus cálculos. Qual o valor da chuva máxima horária? Em que data ocorreu o evento? ###### # (2a) ###### max(hprec$prec, na.rm = TRUE) #&gt; [1] 48 hprec %&gt;% slice(which.max(prec)) %&gt;% select(date) #&gt; # A tibble: 1 x 1 #&gt; date #&gt; &lt;dttm&gt; #&gt; 1 2004-03-13 22:00:00 Qual a chuva máxima diária? Em que data ocorreu o evento? ###### # (2b) ###### dprec &lt;- # agrupando os dados por data (dias) group_by(hprec, date = as.character(as.Date(date))) %&gt;% # resumo estatístico (soma) da prec para cada componente do grupo dplyr::summarise(prec = sum(prec, na.rm = TRUE)) %&gt;% # seleciona do resultado somente as colunas date e prec dplyr::select(date, prec) %&gt;% # converte date para classe POSIX mutate(date = as.POSIXct(date)) # calcula máximo diário max(dprec$prec) #&gt; [1] 130.4 # timePlot(dprec, &quot;prec&quot;, plot.type = &quot;h&quot;) # encontra quando ocorreu o máximo posicao &lt;- which.max(dprec$prec) dprec$date[posicao] #&gt; [1] &quot;2010-01-16 UTC&quot; 3. Pluviograma mensal climatológico. ###### # (3a) e (3b) ###### (n_anos &lt;- length(unique(year(hprec$date)))) #&gt; [1] 11 # tabela com médias dos totais mensais, média do num. horas com prec # usando os dados HORÁRIOS tab_mon_h &lt;- # agrupa dados por mês group_by(hprec, month = lubridate::month(date)) %&gt;% # reumo estatístico para cada componente do grupo summarise(prec_med = sum(prec, na.rm = TRUE)/n_anos # total de horas com prec ,n_horas_tot = sum(prec &gt; 0, na.rm = TRUE) # num. horas médio mensal (horas) ,n_horas_med = sum(prec &gt; 0, na.rm = TRUE)/n_anos # num. horas médio mensal (dias) ,n_horas_med_d = (sum(prec &gt; 0, na.rm = TRUE)/n_anos)/24) #tab_mon_h Faça um gráfico com as médias dos totais mensais de chuva. g0 &lt;- ggplot(tab_mon_h, aes(x = factor(month), y = prec_med)) ggp1 &lt;- g0 + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Prec(mm/mês)&quot;) + xlab(&quot;mês&quot;)+ scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0)) ggp1 Utilizando a série horária de chuva, determine o número médio de horas com chuva para cada mês. Converta a número de horas em dias para melhor comparação com o item (c). tab_mon_h #&gt; # A tibble: 12 x 5 #&gt; month prec_med n_horas_tot n_horas_med n_horas_med_d #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 145. 474 43.1 1.80 #&gt; 2 2 124 570 51.8 2.16 #&gt; 3 3 115. 469 42.6 1.78 #&gt; 4 4 128. 617 56.1 2.34 #&gt; 5 5 106. 679 61.7 2.57 #&gt; 6 6 121. 833 75.7 3.16 #&gt; 7 7 116. 740 67.3 2.80 #&gt; 8 8 106. 785 71.4 2.97 #&gt; 9 9 179. 947 86.1 3.59 #&gt; 10 10 173. 683 62.1 2.59 #&gt; 11 11 141. 543 49.4 2.06 #&gt; 12 12 156. 475 43.2 1.80 Utilizando a série de totais diários de chuva, determine o número médio de dias com chuva para cada mês. Compare com os resultados do item (b) e discuta os resultados. ###### # (3c) ###### # tabela com médias dos totais mensais, média do num. horas com prec # usando os dados DIÁRIOS tab_mon_d &lt;- # agrupa dados por mês group_by(dprec, month = lubridate::month(date)) %&gt;% # resumo estatístico para cada componente do grupo summarise(prec_med = sum(prec, na.rm = TRUE)/n_anos ,n_dias = sum(prec &gt; 0, na.rm = TRUE) ,n_dias_med = (sum(prec &gt; 0, na.rm = TRUE)/n_anos)) tab_mon_d #&gt; # A tibble: 12 x 4 #&gt; month prec_med n_dias n_dias_med #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 145. 125 11.4 #&gt; 2 2 124 131 11.9 #&gt; 3 3 115. 133 12.1 #&gt; 4 4 128. 185 16.8 #&gt; 5 5 106. 203 18.5 #&gt; 6 6 121. 220 20 #&gt; 7 7 116. 168 15.3 #&gt; 8 8 106. 182 16.5 #&gt; 9 9 179. 166 15.1 #&gt; 10 10 173. 140 12.7 #&gt; 11 11 141. 110 10 #&gt; 12 12 156. 115 10.5 Compare a intensidade média da chuva para cada mês do ano obtida nos dois itens. Qual a importância das medidas horárias? ###### # (3d) ###### # insere coluna com intensidade baseada nos dados horários e diários tab_mon_h &lt;- mutate(tab_mon_h, intens_d = prec_med/n_horas_med_d) tab_mon_d &lt;- mutate(tab_mon_d, intens_d = prec_med/n_dias_med) tab_intens &lt;- data.frame(month = tab_mon_h$month, #prec = tab_mon_h$prec_mon, #nh_d = tab_mon_h$n_d, #n_d = tab_mon_d$n_d, intens_d = tab_mon_d$intens_d, intens_h = tab_mon_h$intens_d ) tab_intens #&gt; month intens_d intens_h #&gt; 1 1 12.798400 81.00253 #&gt; 2 2 10.412214 57.43158 #&gt; 3 3 9.476692 64.49808 #&gt; 4 4 7.591351 54.62820 #&gt; 5 5 5.734975 41.14993 #&gt; 6 6 6.050909 38.35390 #&gt; 7 7 7.605952 41.44216 #&gt; 8 8 6.412088 35.67898 #&gt; 9 9 11.881928 49.98691 #&gt; 10 10 13.620000 67.00322 #&gt; 11 11 14.081818 68.46409 #&gt; 12 12 14.923478 86.71326 4. Pluviograma anual. Faça um gráfico com os totais anuais de chuva para cada ano. ###### # Solução geral (4a-c) ###### # tabela de resultados anuais tab_year_h &lt;- # agrupa dados por ano group_by(hprec, year = lubridate::year(date)) %&gt;% summarise(prec_tot = sum(prec, na.rm = TRUE) # num. total de horas com chuva por ano (em horas) ,n_horas_tot = sum(prec &gt; 0, na.rm = TRUE)) %&gt;% # num. total de horas com chuva por ano (em dias) mutate(n_horas_tot_d = round(n_horas_tot/24, 2) # intensidade por ano ,intens = prec_tot/n_horas_tot * 24 # num. médio de &quot;dias&quot; (convertidos das horas) com chuva ,n_d_med = mean(n_horas_tot_d) # chuva total média anual ,prec_tot_med = mean(prec_tot) # instensidade média anual ,intens_med_d = prec_tot_med/n_d_med) select(tab_year_h, year, prec_tot) #&gt; # A tibble: 11 x 2 #&gt; year prec_tot #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2004 1083. #&gt; 2 2005 1353. #&gt; 3 2006 1244. #&gt; 4 2007 1660 #&gt; 5 2008 1508. #&gt; 6 2009 2187. #&gt; 7 2010 1921. #&gt; 8 2011 1148 #&gt; 9 2012 1656. #&gt; 10 2013 1680 #&gt; 11 2014 2274 ###### # (4a) ###### # pluviograma anual g4a &lt;- ggplot(tab_year_h, aes(x = factor(year), y = prec_tot)) g4a + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Prec (mm)&quot;) + xlab(&quot;Ano&quot;)+ geom_hline(yintercept = mean(tab_year_h$prec_tot)) + geom_hline(yintercept = 1100, colour = &quot;red&quot;) + scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0))+ annotate(&quot;text&quot;, x = 9, y = 1100-50, label = &quot;Prec. média global (continentes)&quot;, colour = &quot;red&quot;, size = 4) Determine a frequência de ocorrência da chuva para cada ano. O gráfico deve apresentar a frequência de ocorrência em dias. Para determinar a frequência de ocorrência de chuva para cada ano, devem ser contados o número horas de chuva (prec &gt; 0) (n_horas_tot) e então multiplicar por 24 h para obtê-la a em dias (n_horas_tot_d). select(tab_year_h, year, n_horas_tot, n_horas_tot_d, n_d_med) #&gt; # A tibble: 11 x 4 #&gt; year n_horas_tot n_horas_tot_d n_d_med #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2004 550 22.9 29.6 #&gt; 2 2005 715 29.8 29.6 #&gt; 3 2006 561 23.4 29.6 #&gt; 4 2007 797 33.2 29.6 #&gt; 5 2008 764 31.8 29.6 #&gt; 6 2009 831 34.6 29.6 #&gt; 7 2010 839 35.0 29.6 #&gt; 8 2011 569 23.7 29.6 #&gt; 9 2012 595 24.8 29.6 #&gt; 10 2013 715 29.8 29.6 #&gt; 11 2014 879 36.6 29.6 # freq ocorrência g4b &lt;- ggplot(tab_year_h, aes(x = factor(year), y = n_horas_tot_d)) g4b + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Freq. ocorrência (dias)&quot;) + xlab(&quot;Anos&quot;)+ geom_hline(yintercept = mean(tab_year_h$n_d_med)) + geom_hline(yintercept = 27, colour = &quot;red&quot;) + scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0))+ annotate(&quot;text&quot;, x = 10, y = 28, label = &quot;Trenberth et al. (2003)&quot;, colour = &quot;red&quot;, size = 4) Para fins de comparação, abaixo mostra-se o resultado obtido a partir da série de totais de precipitação. Note que a frequência de ocorrência é superestimada em relação a frequência obtida com a série horária e tais valores são imcomparáveis ao valor de Trenberth et al. 2003 (~27 dias por ano) # tabela de resultados anuais com dados diarios tab_year_d &lt;- # agrupa dados por ano group_by(dprec, year = lubridate::year(date)) %&gt;% summarise(prec_tot = sum(prec, na.rm = TRUE) # num. total de horas com chuva por ano (em horas) ,n_tot_d = sum(prec &gt; 0, na.rm = TRUE)) %&gt;% # num. total de horas com chuva por ano (em dias) mutate( # intensidade por ano intens = prec_tot/n_tot_d # num. médio de &quot;dias&quot; (convertidos das horas) com chuva ,n_d_med = mean(n_tot_d) # chuva total média anual ,prec_tot_med = mean(prec_tot) # instensidade média anual ,intens_med_d = mean(intens)) select(tab_year_d, year, n_tot_d, n_d_med) #&gt; # A tibble: 11 x 3 #&gt; year n_tot_d n_d_med #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2004 135 171. #&gt; 2 2005 159 171. #&gt; 3 2006 162 171. #&gt; 4 2007 184 171. #&gt; 5 2008 180 171. #&gt; 6 2009 183 171. #&gt; 7 2010 174 171. #&gt; 8 2011 149 171. #&gt; 9 2012 149 171. #&gt; 10 2013 195 171. #&gt; 11 2014 208 171. Qual a intensidade média da chuva (em mm/dia) em Santa Maria? Faça a média das frequências de ocorrência e das intensidade obtidas para cada ano. select(tab_year_h, year, prec_tot, n_horas_tot_d, intens, intens_med_d) #&gt; # A tibble: 11 x 5 #&gt; year prec_tot n_horas_tot_d intens intens_med_d #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2004 1083. 22.9 47.3 54.4 #&gt; 2 2005 1353. 29.8 45.4 54.4 #&gt; 3 2006 1244. 23.4 53.2 54.4 #&gt; 4 2007 1660 33.2 50.0 54.4 #&gt; 5 2008 1508. 31.8 47.4 54.4 #&gt; 6 2009 2187. 34.6 63.2 54.4 #&gt; 7 2010 1921. 35.0 54.9 54.4 #&gt; 8 2011 1148 23.7 48.4 54.4 #&gt; 9 2012 1656. 24.8 66.8 54.4 #&gt; 10 2013 1680 29.8 56.4 54.4 #&gt; 11 2014 2274 36.6 62.1 54.4 # intensdade anual g4c &lt;- ggplot(tab_year_h, aes(x = factor(year), y = intens)) g4c + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Intensidade (mm/dia)&quot;) + xlab(&quot;Ano&quot;)+ geom_hline(yintercept = mean(tab_year_h$intens_med_d)) + geom_hline(yintercept = 45, colour = &quot;red&quot;) + scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0)) + annotate(&quot;text&quot;, x = 10, y = 47, label = &quot;Trenberth et al. (2003)&quot;, colour = &quot;red&quot;, size = 4) 5. Frequência de ocorrência de chuva horária. Determine a frequência de ocorrência de chuva (ou seja, o número de casos em que choveu) para cada hora do dia (das 0 às 23 h). Apresente os resultados na forma de um gráfico de barras com a frequência de ocorrência de chuva (eixo y, em %) em cada hora (eixo x). Descreva se há algum padrão no gráfico? Chove mais de dia ou à noite? tab_h &lt;- group_by(filter(hprec, !is.na(prec)), hour = lubridate::hour(date)) %&gt;% summarise(n_h = sum(prec &gt; 0) #N = n() ) %&gt;% mutate(n_h_perc = round(n_h/sum(n_h) * 100, 2) #n_h_perc_all = round((n_h/sum(N)) * 100, 2) ) tab_h #&gt; # A tibble: 24 x 3 #&gt; hour n_h n_h_perc #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 0 304 3.89 #&gt; 2 1 290 3.71 #&gt; 3 2 319 4.08 #&gt; 4 3 334 4.27 #&gt; 5 4 365 4.67 #&gt; 6 5 399 5.11 #&gt; 7 6 400 5.12 #&gt; 8 7 405 5.18 #&gt; 9 8 370 4.73 #&gt; 10 9 340 4.35 #&gt; # ... with 14 more rows # gráfico g2 &lt;- ggplot(tab_h, aes(x = factor(hour), y = n_h_perc)) g2 + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Freq. ocorrência (%)&quot;) + xlab(&quot;Hora&quot;)+ scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0)) 6. Frequência de ocorrência semanal. Determine a frequência de ocorrência (%) de precipitação para cada dia da semana. Qual o dia da semana é mais provável de ocorra precipitação? tab_week &lt;- group_by(filter(hprec, !is.na(prec)), dia = lubridate::wday(date, label = TRUE)) %&gt;% summarise(n_prec = sum(prec &gt; 0), N = n()) %&gt;% mutate(n_prec_perc = round(n_prec/sum(n_prec) * 100, 2), n_all = round((n_prec/sum(N)) * 100, 2)) tab_week #&gt; # A tibble: 7 x 5 #&gt; dia n_prec N n_prec_perc n_all #&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Dom 1129 13163 14.4 1.22 #&gt; 2 Seg 1109 13154 14.2 1.2 #&gt; 3 Ter 1088 13183 13.9 1.18 #&gt; 4 Qua 1014 13215 13.0 1.1 #&gt; 5 Qui 980 13220 12.5 1.06 #&gt; 6 Sex 1170 13182 15.0 1.27 #&gt; 7 Sáb 1325 13203 17.0 1.44 # gráfico g3 &lt;- ggplot(tab_week, aes(x = factor(dia), y = n_prec_perc)) g3 + geom_bar(stat = &quot;identity&quot;) + ylab(&quot;Freq. ocorrência (%)&quot;) + xlab(&quot;dia da semana&quot;) + scale_y_continuous(expand = c(0.01, 0.01), breaks = pretty_breaks(10)) + theme(text = element_text(size=15), axis.text.x = element_text(angle=0)) 7. A Prefeitura Municipal de Santa Maria precisa definir uma data (mês, dia da semana e horário) para realização de um grande evento de entretenimento que requer um período de 3 horas sem chuva, independente do turno. Com base nos seus resultados que data você recomendaria? Em março, numa quinta-feira, entre 21 e 23 horas. "]
]
