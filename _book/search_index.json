[
["io.html", "8 Entrada e saída de dados", " 8 Entrada e saída de dados O é capaz de importar dados de uma diversidade de fontes, formatos e tamanhos. Neste capítulo será visto como importar dados nos formatos mais comuns em aplicações ambientais, como: dados tabulares armazenados em arquivos texto (ASCII) arquivos de dados meteorológicos de agências brasileiras dados binários e netCDF dados espaciais em formato GIS Serão utilizados diversos pacotes para lidar com os diferentes formatos de dados. Iremos começar com o pacote rio que permite importar com facilidade uma diversidade de tipos de dados. Arquivos CSV serão tratados com os pacotes readr e data.table. Formatos binários diminuem substancialmente o tamanho, o tempo de leitura e escrita de arquivos. Entre os formatos binários, veremos funções nativas do R (readRDS(), load()) e funções de pacotes específicos para importar arquivos no formato netCDF. "],
["pre-requisitos.html", "8.1 Pré-requisitos", " 8.1 Pré-requisitos Para reproduzir os códigos deste capítulo você precisará dos seguintes pacotes: pacotes &lt;- c(&quot;easypackages&quot;,&quot;rio&quot;, &quot;readr&quot;, &quot;feather&quot;) Para instalá-los já com as dependências utilize a instrução abaixo: install.packages( pacotes, dependencies = TRUE ) Agora você pode carregar os pacotes. library(&quot;easypackages&quot;) library(&quot;rio&quot;) library(&quot;readr&quot;) Para carregar diversos pacotes de uma vez só, você pode usar a função libraries() do pacote easypackages. Então o trecho de código anterior poderia ser substituído por: library(easypackages) libraries(pacotes) ou simplesmente easypackages::libraries(pacotes) "],
["diretorio-de-trabalho.html", "8.2 Diretório de trabalho", " 8.2 Diretório de trabalho Antes de lidar com arquivos, você precisa conhecer o seu diretório de trabalho; o local para o qual sua sessão do R importará ou exportará dados por default. O possui uma variedade de funções para se obter informações do sistema, como arquivos, diretórios, e etc. Uma informação importante é diretório de trabalho atual. Importar ou exportar dados é mais fácil quando você não precisa digitar caminhos longos de diretórios para os arquivos. Por isso, quando abrimos uma sessão no , ela é vinculada a um diretório de trabalho (working directory, wd). A função getwd() retorna o diretório de trabalho da sua sessão do . getwd() O local default geralmente é o home do usuário &quot;/home/usuario&quot; no linux e &quot;C:\\Usuarios\\usuario\\&quot; no Windows. Você obtém essa informação com a instrução abaixo: Sys.getenv(&quot;HOME&quot;) É neste local onde o e o RStudio irão salvar gráficos, documentos, ler e escrever dados, quando você não especificar o caminho completo para o arquivo de saída. Ocasionalmente pode ser conveniente alterar seu wd e para isso você pode usar a função setwd(). wd &lt;- getwd() # define o wd em &quot;/home/user&quot; setwd(&quot;~/Documents&quot;) getwd() # volta para o wd original setwd(wd) getwd() Você pode configurar o diretório de trabalho pelo menu do Rstudio Session &gt; Set Working Directory. Você terá as opções: To Source File Location: definirá o diretório de trabalho como o mesmo do arquivo atualmente aberto no RStudio To Files Pane Location: definirá o diretório de trabalho como aquele atualmente aberto no painel de arquivos To Files Pane Location: definirá o diretório de trabalho como o mesmo do projeto atualmente aberto no RStudio Choose Directory: permite você navegar até o diretório de interesse O conteúdo de um diretório pode ser listado com a função dir(), ou se estiver usando o Rstudio você pode clicar na aba Files do painel de direito inferior e depois em More &gt; Go To Working Directory. "],
["arquivos-texto.html", "8.3 Arquivos texto", " 8.3 Arquivos texto Dados armazenados em um arquivo texto (do tipo ASCII) podem ser facilmente importados no R. O formato mais comum de armazenar dados é o retangular, ou seja, uma tabela de dados com as observações ao longo das linhas e as variáveis ao longo das colunas. Os valores de cada coluna de uma linha são separados por um caractere separador: vírgula, espaço, tab e etc; as linhas são separadas por quebras de linha (\\n no Linux ou \\r\\n no Windows). "],
["arquivos-binarios.html", "8.4 Arquivos binários", " 8.4 Arquivos binários Existem diversas funções nativas do R para ler este formato de dados. versão completa da tabela na vinheta do pacote rio Formato Extensão Pacote de importação Pacote de exportação Instalado por default Valores separados por vírgula .csv data.table data.table Sim dados separados por tab .tsv data.table data.table Sim Excel .xls readxl Sim Excel .xlsx readxl openxlsx Sim script R .R base base Sim objetos salvos no R .RData, .rda base base Sim objetos do R serializados .rds base base Sim dados Fortran Sem extensão reconhecida utils Sim Formato de dados com largura fixa .fwf utils utils Sim dados separados por vírgula compactados com gzip .csv.gz utils utils Sim Feather R/Python interchange format .feather feather feather Não Armazenamento rápido (Fast Storage) .fst fst fst Não JSON .json jsonlite jsonlite Não Matlab .mat rmatio rmatio Não Planilha OpenDocument .ods readODS readODS Não tabelas HTML .html xml2 xml2 Não documentos XML .xml xml2 xml2 Não YAML .yml yaml yaml Não Área de transferência default é tsv clipr clipr Não planilhas Google como valores separados por vírgula A função mais importante para leitura de dados de um arquivo texto é a read.table() que armazena os dados no formato de uma dataframe. Essa função possui diversos parâmetros para ajustar a importação de acordo com as peculiaridades do formato de dados do arquivo. O valor default do parâmetro sep é um ou mais caracteres de espaço e tabs. Devido as diversas opções de separadores existem outras funções essencialmente iguais a read.table() com a diferença no separador, por exemplo as funções: read.csv(), read.csv2(), read.delim() usam como o argumento separador ,, ; e \\t . Para detalhes sobre essas funções o help de cada uma. Uma vez que essas funções aceitam qualquer argumento da read.table() elas são mais convenientes que usar a read.table() e configurar os argumentos apropriados manualmente. Alguns argumentos da função read.table() são: file nome do arquivo header lógico (TRUE ou FALSE) indicando se o arquivo tem ou não linha de cabeçalho sep um caractere indicando como as colunas são separadas colClasses, um vetor caractere indicando as classes de cada coluna no conjunto de dados nrows, número de linhas no conjunto de dados comment.char, um caractere indicando o caractere usado como comentário (para ignorar essas linhas) skip, o número de linhas que devem ser “puladas” desde o início do arquivo stringsAsFactors, lógico, as variáveis do tipo character devem ser codificadas como factor? Esse último argumento pode ser definido também através da configuração global de opções no R pelo comando: options(stringsAsFactors=FALSE). Quando se faz a leitura de dados com read.table(&quot;nome_do_arquivo&quot;) o R automaticamente: pula linhas que começam com ‘#’ descobre quantas linhas tem o arquivo e quanta memória precisa ser alocada descobre qual o tipo de variável em cada coluna Para arquivos de tamanho moderado a pequeno essa forma de especificar os argumentos funciona satisfatoriamente. Vamos ver alguns exemplos de leitura de dados hidrometeorológicos no formato texto amplamente usados em aplicações da Meteorologia. 8.4.1 Arquivos textos de bases de dados hidrometeorológicos brasileiras 8.4.1.1 hidroweb-ANA # arquivo de exemplo disponível no GitHub file_hidroweb &lt;- &quot;https://raw.github.com/lhmet/adar-ufsm/master/data/CHUVAS.TXT&quot; # definindo interpretação de caracteres: caracteres não devem ser tratados como fatores options(stringsAsFactors = FALSE) # leitura de dados pluviométricos diários da ANA dprec &lt;- read.csv2(file = file_hidroweb, skip = 15, head = TRUE, fill = TRUE) # primeiras linhas head(dprec) # últimas linhas tail(dprec) # corrigindo nome da primeira coluna names(dprec)[1] &lt;- &quot;EstacaoCodigo&quot; # removendo última coluna que só tem NAs dprec &lt;- dprec[ , -ncol(dprec)] # estrutura dos dados str(dprec) # Fazendo a mesma leitura com read.table dprec2 &lt;- read.table(file = &quot;data/CHUVAS.TXT&quot;, skip = 15, head = T, stringsAsFactors = FALSE, fill = T, sep = &quot;;&quot;, dec = &quot;,&quot;) head(dprec2) 8.4.2 BDMEP-INMET x &lt;- read.csv2(file = &quot;data/83004.txt&quot;, header = FALSE, skip = 16, stringsAsFactors = FALSE, na.strings = &quot;&quot; ) head(x) str(x) Os dados lidos não incluíram a linha de cabeçalho com os nomes das variáveis. Nós pulamos essa linha porque o nome das variáveis está de acordo como número de colunas do arquivo. Então se tentarmos ler um arquivo de dados que contém linhas com número de registros diferentes ocorrerá um erro pois os dados não são tabulares. Outro aspecto nos dados lidos é que aparecem vários &lt;NA&gt;, que é o símbolo para dados do tipo character faltantes. A razão dos terem sido interpretados dessa forma deve-se a um caractere (&lt;/pre&gt;) encontrado na última linha do arquivo. Digite na linha de um terminal linux o comando: tail data/83004.txt para imprimir na tela apenas a parte final do arquivo. Para que os dados numéricos não sejam interpretados como caractere nós poderíamos executar a função read.table(..., nrows = 5878), que ignoraria a última linha do arquivo e os dados seriam interpretados como numeric. x1 &lt;- read.csv2(file=&quot;data/83004.txt&quot;, header = FALSE, skip = 16, stringsAsFactors = FALSE, dec = &quot;.&quot;, na.strings = &quot;&quot;, nrows = 5878 ) head(x1) str(x1) Outra alternativa seria converter as colunas de interesse (todas exceto as de 1 a 3) para numeric através da função as.numeric() usando a função apply ao longo das colunas: # corrigindo classe dos dados # convertendo de character para numeric x[, -c(1:3)] &lt;- apply(x[,-c(1:3)], 2, as.numeric) str(x) # razão dos avisos as.numeric(&quot;NA&quot;) Mas e o nome das variáveis? Nós ignoramos a linha de cabeçalho por que nos dados do INMET ocorre uma variável denominada VelocidadeVentoInsolacao. Essa string deveria ser separada em duas. # lendo somente o nome das variaveis vnames &lt;- read.csv2(file=&quot;data/83004.txt&quot;, header = FALSE, skip = 15, stringsAsFactors = FALSE, dec = &quot;.&quot;, na.strings = &quot;&quot;, nrows = 1) vnames # convertendo de dataframe para vetor vnames &lt;- c(t(vnames)) # número de variáveis é diferente do número de colunas do arquivo length(vnames) == ncol(x) # corrigindo nomes das variaveis # substitui &quot;VelocidadeVentoInsolacao&quot; por &quot;VelocidadeVento&quot; vnames[13] &lt;- &quot;VelocidadeVento&quot; # acresenta na 14a posição dos nomes a variável &quot;insolacao&quot; e # desloca os elementos orginais do vetor vnames &lt;- c(vnames[1:13], &quot;insolacao&quot;, vnames[14:length(vnames)]) length(vnames) ncol(x) names(x) &lt;- vnames head(x) Finalmente vamos escrever os dados do INMET corretamente organizados. write.csv2(x, file = &quot;data/83004_clean.txt&quot;, na = &quot;-9999&quot;, row.names = FALSE) 8.4.3 Arquivos formatados com largura fixa Alguns arquivos texto com dados tabulares podem não conter separadores (para p.ex. economizar espaço de disco). Outros arquivos podem ser formatados usando largura fixa para reservar o espaço de cada variável, o que facilita a legibilidade dos dados. Nesses casos usamos a função read.fwf(). Vamos usar como exemplo o arquivo de dados do Índice de Oscilação Sul (SOI) obtido no site do National Weather Service - Climate Prediction Center (NWS-CPC). # link para os dados do SOI link &lt;- &quot;http://www.cpc.ncep.noaa.gov/data/indices/soi&quot; Abrindo o link dos dados no navegador para visualização do formato. browseURL(url = link) Leitura dos dados: #soi &lt;- read.fwf(file = link, # nome do arquivo ou link soi &lt;- read.fwf(file = &quot;data/SOI.txt&quot;, # sem internet, usar esse arquivo skip = 4, # pula 4 linhas header = FALSE, # sem cabeçalho nrows = 70, # num. de linhas widths = c(4, rep(6,12)), # largura dos campos das variáveis na.strings = &quot;-999.9&quot;, # string para dados faltantes col.names = scan(&quot;data/SOI.txt&quot;, # varredura do arquivo #col.names = scan(link, # varredura do arquivo what = &quot;character&quot;, # tipo dos dados a serem lidos skip = 3, # pula 3 linhas nmax = 13) # num. max de registros a serem lidos ) Vamos alterar a estrutura dos dados: ao invés dos dados serem distribuídos ao longo das colunas, vamos estruturá-los como série temporal, ou seja cada valor mensal corresponderá a uma linha. # converte a matriz de dados para um vetor (em sequencia cronológica) soi_v &lt;- c(t(soi[, -1])) # criando um dataframe com valores de SOI, mes e ano soi_df &lt;- data.frame(ano = rep(soi$YEAR, each = 12), mes = rep(1:12, length(soi[,1])), soi = soi_v) # escrevendo dados SOI em um arquivo CSV write.csv(x = soi_df, file = &quot;data/SOI.csv&quot;, na = &quot;-999.9&quot;, row.names = FALSE) Vamos ler os dados reestruturados que foram salvos no formato csv usando uma função que permite a escolha do arquivo de forma iterativa. # leitura de dados com escolha interativa do arquivo soi.df &lt;- read.csv(file = file.choose(), # file.choose só é válido em sistema *unix # no windows é choose.file() header = TRUE, na.strings = &quot;-999.9&quot;) Clique duas vezes sobre o arquivo SOI.csv. soi.df &lt;- read.csv(file = &quot;data/SOI.csv&quot;, header = TRUE, na.strings = &quot;-999.9&quot;) head(soi.df) str(soi.df) A função read.fortran() é uma função similar à read.fwf() e permite usar especificações de colunas no estilo Fortran. "],
["para-saber-mais.html", "8.5 Para saber mais", " 8.5 Para saber mais Para uma descrição mais abrangente sobre importação e exportação de dados no consulte o manual R Data Import/Export e a documentação de ajuda das funções citadas naquele documento. "]
]
