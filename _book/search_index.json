[
["manip-vectors.html", "Capítulo 7 Manipulação de Vetores", " Capítulo 7 Manipulação de Vetores Neste capítulo veremos como manipular vetores, incluindo: como nomear vetores realizar cálculos entre vetores gerar sequências entender a indexação de vetores lidar com dados faltantes, nulos e duplicados usar as funções para cálculos móveis Em algumas seções deste capítulos usaremos funções dos pacotes do grupo tidyverse, como o ggplot2 e dplyr. Para carregá-los basta digitar: library(tidyverse) "],
["propriedades.html", "7.1 Propriedades", " 7.1 Propriedades typeof() para descobrir o tipo de dado length() para descobrir o tamanho de um tipo de dado attributes (informações acionais específicas do dado), entre eles o atributo mais comum está o names(). 7.1.1 Nomeando vetores As 3 formas equivalentes mais comuns de criar vetores com nomes são demostradas abaixo com um exemplo de dados mensais de precipitação. Durante a criação, com a função c() incluindo os nomes nos argumentos # vetor de chuva mensal para um dado ano prec &lt;- c( jan = 300, fev = 150, mar = 210, abr = 12, mai = 0, jun = 0, jul = 12, ago = 22, set = 100, out = 120, nov = 10, dez = 280 ) Modificando um vetor com a função names()&lt;- prec &lt;- c(300, 200, 210, 12, 0, 0, 12, 22, 100, 120, 10, 280) meses &lt;- c(&quot;jan&quot;, &quot;fev&quot;, &quot;mar&quot;, &quot;abr&quot;, &quot;mai&quot;, &quot;jun&quot;, &quot;jul&quot;, &quot;ago&quot;, &quot;set&quot;, &quot;out&quot;, &quot;nov&quot;, &quot;dez&quot;) names(prec) &lt;- meses prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 Criando um vetor modificado prec &lt;- setNames( object = c(300, 200, 210, 12, 0, 0, 12, 22, 100, 120, 10, 280), nm = c(&quot;jan&quot;, &quot;fev&quot;, &quot;mar&quot;, &quot;abr&quot;, &quot;mai&quot;, &quot;jun&quot;, &quot;jul&quot;, &quot;ago&quot;, &quot;set&quot;, &quot;out&quot;, &quot;nov&quot;, &quot;dez&quot;) ) prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 Nomes não podem ser repetidos entre os elementos, porque a seleção de um subconjunto do vetor baseada nos nomes retornará somente o primeiro elemento que tiver nome repetido. Embora não faça muito sentido, nem todos elementos precisam ter nomes. A saída da função names() retornará um vetor caractere vazio (\"\") para aqueles elementos sem nomes especificados. (meses &lt;- c(jan = 1, fev = 2, 3:12)) #&gt; jan fev #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 names(meses) #&gt; [1] &quot;jan&quot; &quot;fev&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Quando nenhum nome é especificado, names() retornará NULL1. names(1:12) #&gt; NULL Para remover os nomes de um vetor, podemos usar a função unname() ou names() &lt;- NULL. prec_clim &lt;- c(230, 205, 160, 100, 60, 30, 40, 60, 110, 165, 200, 220) names(prec_clim) &lt;- names(prec) prec_clim #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 230 205 160 100 60 30 40 60 110 165 200 220 unname(prec_clim) #&gt; [1] 230 205 160 100 60 30 40 60 110 165 200 220 names(prec_clim) &lt;- NULL prec_clim #&gt; [1] 230 205 160 100 60 30 40 60 110 165 200 220 Nas próximas seções frequentemente usaremos os vetores prec e prec_clim. É importante então contextualizar essas variáveis. A variável prec consiste na precipitação mensal observada em um ano qualquer em um dado local. A variável prec_clim refere-se aos valores esperados de precipitação mensal2 (médias de pelo menos 30 anos) do mesmo local. Nós conheceremos mais detalhes sobre o NULL na sessão 7.8.↩ Também conhecidos como normais climatológicas de precipitação de um local.↩ "],
["atributos.html", "7.2 Atributos", " 7.2 Atributos Nós podemos adicionar atributos a um vetor, como por exemplo alguma informação sobre os valores daquela variável. A variável prec possui um atributo (names). A função attributes() lista qualquer atributo de uma variável. Vamos criar uma variável para mostrar como podemos adicionar um atributo a um vetor. temp &lt;- c(27, 23, 21, 18, 19, 28) attributes(temp) #&gt; NULL Podemos adicionar um atributo chamado metadados à temp e fornecer um vetor caractere com a função de atribuição de atributo attr()&lt;- attr(temp, &quot;metadados&quot;) &lt;- &quot;dados obtidos em www.inmet.gov.br, acesso em 10/10/2010&quot; temp #&gt; [1] 27 23 21 18 19 28 #&gt; attr(,&quot;metadados&quot;) #&gt; [1] &quot;dados obtidos em www.inmet.gov.br, acesso em 10/10/2010&quot; Algumas funções carregarão este atributo adiante, mas outras não, conforme exemplo a seguir. (temp_inc &lt;- temp + 1) #&gt; [1] 28 24 22 19 20 29 #&gt; attr(,&quot;metadados&quot;) #&gt; [1] &quot;dados obtidos em www.inmet.gov.br, acesso em 10/10/2010&quot; (temp_inc &lt;- c(temp_inc, 18)) #&gt; [1] 28 24 22 19 20 29 18 Há situações de uso válido deste recurso, mas inicialmente é melhor não confiar nele. "],
["oper-vect.html", "7.3 Operações com vetores", " 7.3 Operações com vetores Como o R é uma linguagem vetorizada, as operações são aplicadas a cada elemento do vetor automaticamente, sem a necessidade de laços (ou loopings) ao longo do vetor. Esta é uma das grandes vantagens do . Operações aritméticas podem ser aplicadas diretamente entre vetores. # desvios da prec em relação a média climatológica prec - prec_clim #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 70 -5 50 -88 -60 -30 -28 -38 -10 -45 -190 60 # anomalia em % relativa prec/prec_clim * 100 #&gt; jan fev mar abr mai jun jul ago #&gt; 130.43478 97.56098 131.25000 12.00000 0.00000 0.00000 30.00000 36.66667 #&gt; set out nov dez #&gt; 90.90909 72.72727 5.00000 127.27273 # transformação boxcox da prec com alpha = 0.335 ((prec^0.335 - 1)/0.335) #&gt; jan fev mar abr mai jun jul ago #&gt; 17.188869 14.626583 14.916806 3.877403 -2.985075 -2.985075 3.877403 5.422424 #&gt; set out nov dez #&gt; 10.977168 11.856532 3.470802 16.727944 # cte^intervalo mean(prec)^(1/2:5) #&gt; [1] 10.271319 4.725171 3.204890 2.538929 Uma peculiaridade do é o tratamento de operações com vetores de tamanhos diferentes. O vetor menor é reciclado, de forma que seus elementos sejam repetidos em ordem até atingirem o tamanho do vetor mais longo envolvido na operação. # velocidades em m s-1 (vel_ms &lt;- c(1.5, 0.3, 1.4, 2.0)) #&gt; [1] 1.5 0.3 1.4 2.0 # fator de conversão para km h-1 fator_conv &lt;- 3.6 vel_ms * fator_conv #&gt; [1] 5.40 1.08 5.04 7.20 # equivalência fator_conv &lt;- c(3.6, 3.6, 3.6, 3.6) vel_ms * fator_conv #&gt; [1] 5.40 1.08 5.04 7.20 A constante fator_conv = 3.6 nesse caso é reciclada 4 vezes (tamanho do vetor vel_ms) e então multiplicada por cada elemento de vetor_dbl. Por isso os resultados no código acima são idênticos. Essa funcionalidade de fazer um vetor do mesmo tamanho de outro é conhecida como reciclagem. Se o vetor mais longo não tem tamanho múltiplo do mais curto, o realiza a operação com uma mensagem de aviso. 1:10 * 1:2 #&gt; [1] 1 4 3 8 5 12 7 16 9 20 1:10 * 1:3 #&gt; Warning in 1:10 * 1:3: comprimento do objeto maior não é múltiplo do comprimento #&gt; do objeto menor #&gt; [1] 1 4 9 4 10 18 7 16 27 10 A reciclagem é um recurso útil, mas também perigoso. Seu código pode ficar mais elegante ou gerar resultados inesperados. Operações aritméticas podem ser feitas com vetores lógicos, como nos exemplos abaixo: FALSE - TRUE #&gt; [1] -1 prec_clim &gt;= 100 #&gt; [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE (prec_clim &gt;= 100) * 1:12 #&gt; [1] 1 2 3 4 0 0 0 0 9 10 11 12 7.3.1 Comparações Vetores lógicos resultam da comparação de números ou caracteres. A Tabela 7.1 apresenta os principais operadores lógicos para comparações. Tabela 7.1: Operadores Lógicos Operador Descrição &lt; menor que &lt;= menor ou igual a &gt; maior que &gt;= maior ou igual == idêntico != diferente !x não é x (negação) x | y x ou y x &amp; y x e y isTRUE(x) teste se x é verdadeiro %in% está contido em Este conjunto de operadores permite diversas comparações entre vetores, por exemplo: quais meses de prec foram abaixo do normal? prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 prec_clim #&gt; [1] 230 205 160 100 60 30 40 60 110 165 200 220 prec - prec_clim &lt; 0 #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; FALSE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE O operador %in% serve para verificar se um vetor está contido parcial ou totalmente em outro vetor. # operador está contido em c(200, 150, 100) %in% prec #&gt; [1] TRUE FALSE TRUE # 2:4 são elementos de x? is.element(c(200, 150, 100), prec) #&gt; [1] TRUE FALSE TRUE Nos exemplos acima, vimos como buscar os os elementos de um vetor para apenas uma condição. Entretanto, frequentemente precisamos testar mais condições, ou seja, combinar comparações. Por exemplo, para condições do tipo: \\(0 &lt; prec \\leq 100\\) \\(prec &lt; 50\\) ou \\(prec \\geq 150\\) precisamos usar os operadores relacionais: &amp; e &amp;&amp; (\"e\") | e || (\"ou\") # prec entre 0 e 100 mm prec &gt; 0 &amp; prec &lt;= 100 #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE # prec abaixo de 50 e acima de 150 mm prec &lt; 50 | prec &gt;= 150 #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE TRUE TRUE A ordem das operações pode ser controlada por parênteses. Os operadores &amp; e | são vetorizados (retornam vetores de mesmo tamanho que os vetores testados). A forma dupla (&amp;&amp; ou ||) compara somente um elemento de cada lado, enquanto a forma normal (&amp; e |), compara cada elemento dos vetores em cada lado. a &lt;- c(1, 1, 0, 1) b &lt;- c(2, 1, 0, 1) # forma normal verifica cada elemento de a e cada elemento de b a == 1 &amp; b == 1 #&gt; [1] FALSE TRUE FALSE TRUE # forma dupla verifica somente o primeiro elemento de a e o primeiro elemento de b # retornando somente um resultado a == 1 &amp;&amp; b == 1 #&gt; [1] FALSE Demonstração da diferença entre &amp; e &amp;&amp;. a b a==1 b==1 a == 1 &amp; b == 1 a == 1 &amp;&amp; b == 1 1 2 TRUE FALSE FALSE FALSE 1 1 TRUE TRUE TRUE 0 0 FALSE FALSE FALSE 1 1 TRUE TRUE TRUE Podem haver mais que duas condições a serem testadas. As condições podem ser combinadas usando múltiplos &amp; ou |. As diferentes condições podem ser agrupadas por parênteses assim como feito nas operações matemáticas. 7.3.1.1 Testes de igualdade A comparação de igualdade no pode ser meio confusa devido as forma de armazenamento diferentes dos números. 0.6 - 0.3 #&gt; [1] 0.3 0.9 - 0.6 #&gt; [1] 0.3 0.3 == 0.3 #&gt; [1] TRUE Tudo normal, mas ao comparar operações com valores decimais, você pode se surpreender: (0.6 - 0.3) == (0.9 - 0.6) #&gt; [1] FALSE Isso ocorre por imprecisão no final da parte decimal que pode ser arrendondada incorretamente. Isso não acarreta problema na maioria dos cálculos. Para evitar esse problema é melhor comparar os resultados usando a função all.equal(). all.equal( target = 0.6 - 0.3, current = 0.9 - 0.6 ) #&gt; [1] TRUE A all.equal() inclui uma tolerância na comparação (\\(1,5\\times10^{-8}\\)) fazendo com aquela imprecisão seja ignorada. Para mais detalhes consulte ?all.equal. 7.3.2 Funções any e all Estas funções fornecem um único valor (vetor lógico de tamanho 1) para resumir ou descrever o resultado da condição aplicada ao vetor. vetor &lt;- c(0, 1, -1, -2, 3, 5, -5) all(vetor &lt; 0) # todas as posições são maiores que 0 ? #&gt; [1] FALSE any(vetor &gt; 0) # alguma posição é maior que 0? #&gt; [1] TRUE all() verifica se a condição avaliada é válida para todos elementos de um vetor; any() verifica se a condição avaliada é válida para pelo menos um dos elementos de um vetor; "],
["sequências.html", "7.4 Sequências", " 7.4 Sequências Vimos nas seções anteriores que é muito simples criar sequências de números inteiros com o operador :. Nesta seção veremos outras formas de gerar sequências, como uma sequência de números reais e sequências de números repetidos. 7.4.1 Sequências de números inteiros Os dois pontos (:) são uma maneira muito fácil de gerar uma sequência de números igualmente espaçados por 1. Você especifica um número inicial e um número final e o R produzirá todos os números inteiros entre eles, incluindo os dois números. Isso funciona mesmo para números negativos ou para valores decrescentes. (ddm &lt;- 1:31) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #&gt; [26] 26 27 28 29 30 31 typeof(ddm) #&gt; [1] &quot;integer&quot; # sequencia de inteiros decrescente (si_dec &lt;- 10:-10) #&gt; [1] 10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 #&gt; [20] -9 -10 typeof(si_dec) #&gt; [1] &quot;integer&quot; 7.4.2 Sequências de números reais A função seq()pode ser usada para gerar sequências tanto de números reais como inteiros. No código abaixo são geradas uma sequência crescente e uma decrescente, ambas igualmente espaçadas por 3. seq(from = 1, to = 10, by = 3) #&gt; [1] 1 4 7 10 seq(from = 10, to = 1, by = -3) #&gt; [1] 10 7 4 1 Para sequências decrescentes o argumento by (\"por\") deve ser negativo. A saída da seq() vai sempre incluir o n° inicial (passado no argumento from - \"de\"), mas nem sempre incluirá o n° final (passado no argumento to - \"até\"). Se sua sequência está aumentando por um argumento by que é par (ímpar) e o argumento to também é par (ímpar), não incluirá o valor do argumento to no resultado (Tabela 7.2). Quando to e by diferem o valor de to fará parte da sequência de saída. Tabela 7.2: Sequências com argumentos ímpares e pares. ‘from’ ‘to’ ‘to’ é par? ‘by’ ‘by’ é par? sequência resultado inclui ‘to’ 1 10 TRUE 2 TRUE c(1, 3, 5, 7, 9) FALSE 1 10 TRUE 3 FALSE c(1, 4, 7, 10) TRUE 1 11 FALSE 2 TRUE c(1, 3, 5, 7, 9, 11) TRUE 1 11 FALSE 3 FALSE c(1, 4, 7, 10) FALSE Ao invés de usar o argumento by, podemos especificar um valor para o argumento length.out (\"tamanho de saída\") para produzir um vetor com tantos números, igualmente espaçados, entre os valores from e to. seq(from = 1, to = 10, length.out = 20) #&gt; [1] 1.000000 1.473684 1.947368 2.421053 2.894737 3.368421 3.842105 #&gt; [8] 4.315789 4.789474 5.263158 5.736842 6.210526 6.684211 7.157895 #&gt; [15] 7.631579 8.105263 8.578947 9.052632 9.526316 10.000000 O length.out = 20 no código acima permite gerar 20 números igualmente espaçados entre 1 e 10. 7.4.3 Repetições Algumas vezes precisamos repetir certos valores, o que pode ser feito com a função rep(). O argumento times especifica o número de vezes para repetir o x. rep(x = 1:2, times = 4) #&gt; [1] 1 2 1 2 1 2 1 2 O argumento each especifica o número de vezes para repetir cada elemento de x. rep(x = 1:2, each = 3) #&gt; [1] 1 1 1 2 2 2 Os argumentos podem ser combinados. rep(x = 1:2, times = 4, each = 3) #&gt; [1] 1 1 1 2 2 2 1 1 1 2 2 2 1 1 1 2 2 2 1 1 1 2 2 2 No caso acima, x primeiro foi repetido 4 vezes e depois cada elemento foi repetido 3 vezes. Quando argumento times é um vetor de mesmo tamanho que x, cada um de seus valores será usado para repetir tantas vezes o respectivo elemento de x. rep(x = 1:2, times = 4:3) #&gt; [1] 1 1 1 1 2 2 2 "],
["index-vetores.html", "7.5 Indexação de vetores", " 7.5 Indexação de vetores Os elementos de um vetor são indexados e para acessá-los usamos a notação de índices do . Para extrair ou filtrar elementos de um vetor usamos o operador colchetes [ ], seguindo a sintaxe: vetor[indices] onde indices representa o vetor com os índices dos elementos da variável vetor a serem selecionados. O operador [ quando aplicado a um vetor retornará sempre um vetor. Para acessar partes um elemento de um vetor o vetor indices dentro dos colchetes pode ser especificado de diferentes formas: por posições (vetor numérico) por nomes (vetor de caracteres) por comparações, testes ou condições (vetor lógico) 7.5.1 Indexação por vetores numéricos 7.5.1.1 Positivos Para extrairmos a precipitação de janeiro e dezembro do vetor prec podemos usar o seguinte código: # vetor com as posições dos meses de janeiro e dezembro c(1, length(prec)) #&gt; [1] 1 12 # acesso aos valores localizados nas posições 1 e 12 prec[c(1, length(prec))] #&gt; jan dez #&gt; 300 280 Passando um vetor numérico entre os colchetes retorna a parte do vetor contendo os elementos daquelas posições. Similarmente a precipitação dos meses de inverno (Junho, Julho e Agosto) podem ser selecionadas usando um vetor definido com os índices das posições daqueles meses: inds_jja &lt;- 6:8 # vetor de chuva JJA prec[inds_jja] #&gt; jun jul ago #&gt; 0 12 22 O reposicionamento dos elementos de um vetor pode ser feito pela especificação da ordem dos índices. Par ordenar os elementos na ordem dezembro, Janeiro e Fevereiro indexamos da seguinte maneira: prec[c(12, 1, 2)] A inversão da ordem dos elementos pode ser feita com a indexação: prec[length(prec):1] A função rev() economiza tempo de digitação de código para realizar esta mesma ação: rev(prec) 7.5.1.2 Negativos O acesso aos dados de precipitação de janeiro e dezembro do vetor prec poderia ser feita uma lógica complementar. Poderíamos selecionar todos elementos de prec exceto aqueles entre Fevereiro (posição 2) e Novembro (posição 11). Esta frase poderia ser transcrita em código R, simplesmente como -(2:11). O sinal - precedendo o vetor numérico, exclui o acesso aquelas posições quando usado entre o operador [. prec[-(2:11)] #&gt; jan dez #&gt; 300 280 Analogamente, os meses de inverno poderiam ser selecionados com: prec[-c(1:5, 9:12)] #&gt; jun jul ago #&gt; 0 12 22 7.5.2 Indexação por nomes A seleção de partes e um vetor pode ser feita também usando os nomes de seus elementos. As precipitações de janeiro e dezembro poderiam ser extraídas usando os nomes daqueles elementos: prec[c(&quot;jan&quot;, &quot;dez&quot;)] #&gt; jan dez #&gt; 300 280 Assim como as precipitações de inverno. prec[c(&quot;jun&quot;, &quot;jul&quot;, &quot;ago&quot;)] #&gt; jun jul ago #&gt; 0 12 22 7.5.3 Indexação por vetores lógicos Vamos criar um vetor lógico e usá-lo para a seleção com um vetor lógico dos elementos de prec para Janeiro e Dezembro. inds_log &lt;- c( TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE ) prec[inds_log] #&gt; jan dez #&gt; 300 280 Somente os elementos de inds_log correspondentes a TRUE foram selecionados. Vetores lógicos são muito úteis quando aproveitamos a funcionalidade de coerção. Imagine que você queira extrair de prec o primeiro elemento, mas o segundo não, o terceiro elemento sim, o quarto não e assim sucessivamente. Essa seleção intercalada pode ser simplesmente feita com: inds_log &lt;- c(TRUE, FALSE) prec[inds_log] #&gt; jan mar mai jul set nov #&gt; 300 210 0 12 100 10 Uma forma mais prática de filtrar vetores é por comparações. Por exemplo, quais valores de precipitação foram acima de 80 mm? inds_prec_alta &lt;- prec &gt; 80 prec[inds_prec_alta] #&gt; jan fev mar set out dez #&gt; 300 200 210 100 120 280 Vimos que a filtragem consiste em extrair elementos de um vetor que satisfaça uma ou várias condições. Entretanto, em alguns casos, o interesse está nas posições do vetor que atendem a condição (onde ela é verdadeira). Nós podemos localizar essas ocorrências usando a função which(). Por exemplo, qual a posição dos elementos do vetor inds_prec_alta que são verdadeiros? which(inds_prec_alta) #&gt; jan fev mar set out dez #&gt; 1 2 3 9 10 12 A função which() converte um vetor lógico em numérico, somente os índices em que a condição é TRUE. A utilidade da which() é mais evidente quando usada para, por exemplo, sabermos qual o mês do 4° caso mais chuvoso. which(inds_prec_alta)[4] #&gt; set #&gt; 9 names(which(inds_prec_alta)[4]) #&gt; [1] &quot;set&quot; # ou names(prec)[which(inds_prec_alta)[4]] #&gt; [1] &quot;set&quot; A resultado da which() é um vetor numérico e portanto equivale a indexação numérica. Então a seleções abaixo são equivalentes: prec[which(inds_prec_alta)] prec[inds_prec_alta] Quando é melhor usar uma ou outra opção? Note que o resultado de which(inds_prec_alta) armazena somente os índices que satisfazem a condição, enquanto que o resultado de inds_prec_alta é um vetor lógico de mesmo tamanho que prec. Então, se estiver trabalhando com big data (p.ex.: um vetor com milhões de elementos) em termos de eficiência de uso da memória a which() é melhor opção. Para localizar valores extremos em um vetor podemos usar as funções which.max() e which.min() que fornecem respectivamente, a posição do valor máximo e mínimo no vetor. Elas são versões eficientes dos códigos which(x == max(x)) e which(x == min(x)). Contudo, há uma diferença entre elas que pode ser verificada pela comparação dos resultados das instruções: which.min(prec) which(prec == min(prec)) A primeira seleciona o primeiro índice para o qual prec tem seu mínimo (5° elemento), enquanto a segunda retorna todos os índices correspondentes ao mínimo (5° e 6° elemento). "],
["replace-vect.html", "7.6 Substituição de elementos de um vetor", " 7.6 Substituição de elementos de um vetor Podemos substituir os valores de um vetor usando os mesmos esquemas de indexação vistos na seção anterior. A sintaxe geral para substituir elementos de um vetor por novos valores é: vetor[indices] &lt;- novos_valores Vamos fazer uma cópia do vetor prec para então alterá-lo, fazendo substituição de seus elementos usando as diferentes formas de indexação. (prec_alt &lt;- prec) #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 7.6.0.1 Por posições suponha que você precisa substituir os valores de precipitação dos meses de inverno por valores corrigidos. inds_jja #&gt; [1] 6 7 8 prec_alt[inds_jja] &lt;- c(NA, 21, 42) prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 prec_alt #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 NA 21 42 100 120 10 280 7.6.0.2 Por nomes Suponha que os valores de precipitação de janeiro e dezembro foram atualizados para 250 e 208, respectivamente. Esta alteração pode ser com o código abaixo. prec_jd_corr &lt;- c(250, 208) prec_alt[c(&quot;jan&quot;, &quot;dez&quot;)] &lt;- prec_jd_corr prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 200 210 12 0 0 12 22 100 120 10 280 prec_alt #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 250 200 210 12 0 NA 21 42 100 120 10 208 7.6.0.3 Por comparação Imagine que você precisa substituir os valores de prec que ficaram em torno de \\(\\pm10 \\%\\) da média mensal climatológica pelos valores climatológicos. Vamos primeiro determinar os desvios relativos (em %) em relação as médias climatológicas: # limiar em % da normal climatológica limiar &lt;- 10 desvios &lt;- prec - prec_clim # anomalias relativas em % (anom_perc &lt;- abs(desvios)/prec_clim * 100) #&gt; jan fev mar abr mai jun jul #&gt; 30.434783 2.439024 31.250000 88.000000 100.000000 100.000000 70.000000 #&gt; ago set out nov dez #&gt; 63.333333 9.090909 27.272727 95.000000 27.272727 Então substituímos os casos com baixo desvio pela precipitação climatológica. # meses com prec em torno de +-10% da média climatol. prec[anom_perc &lt;= 10] #&gt; fev set #&gt; 200 100 # substituição pela prec mensal climatol. prec[anom_perc &lt;= 10] &lt;- prec_clim[anom_perc &lt;= 10] prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 205 210 12 0 0 12 22 110 120 10 280 A função abs() determina o valor absoluto ou módulo de um vetor. Uma alternativa bastante útil para substituir valores de um vetor usando comparações é a função vetorizada ifelse(). A mesma operação realizada no trecho de código anterior poderia ser feita com ifelse() da seguinte forma: prec &lt;- ifelse(ano_perc &lt;= 10, prec_clim, prec) prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 205 210 12 0 0 12 22 110 120 10 280 "],
["lidando-com-dados-faltantes.html", "7.7 Lidando com dados faltantes", " 7.7 Lidando com dados faltantes Dados faltantes (NAs) são inevitáveis e em qualquer processamento de dados reais nós precisamos determinar se existem dados faltantes e a quantidade de observações válidas. É importante também, saber o efeito que eles tem nos cálculos, as funcionalidades para identificá-los e substituí-los se necessários. Vamos substituir alguns valores da prec_alt por NA para poder tratar de dados faltantes usando as diferentes funcionalidades que o oferece para isso. prec_alt[c(3, 4, 11)] &lt;- NA prec_alt #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 250 200 NA NA 0 NA 21 42 100 120 NA 208 7.7.1 Identificação e remoção de NAs Para identificar NAs em um vetor, a função específica para isso é a is.na(). is.na(prec_alt) #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; FALSE FALSE TRUE TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE Também podemos usá-la aninhada com a função which() para obter os índices dos elementos faltantes. which(is.na(prec_alt)) #&gt; mar abr jun nov #&gt; 3 4 6 11 Novos usuários do R tentam identificar dados faltantes com a expressão: prec_alt == NA #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; NA NA NA NA NA NA NA NA NA NA NA NA O que produzirá somente NAs mesmo que o vetor testado possua algum NA. Isso ocorre pela regra de qualquer operação com NAs resulta em NAs. Para verificar se há algum dado faltante em um vetor usamos a função anyNA() e para quantificar o total de observações faltantes combinamos as expressões sum() e is.na(): anyNA(prec_alt) #&gt; [1] TRUE sum(is.na(prec_alt)) #&gt; [1] 4 A remoção dos elementos faltantes de um vetor é moleza. É só combinar o operador negação ! e is.na() por indexação lógica: prec_alt[!is.na(prec_alt)] #&gt; jan fev mai jul ago set out dez #&gt; 250 200 0 21 42 100 120 208 # outra forma equivalente #prec_alt[-which(is.na(prec_alt))] Uma alternativa mais sofisticada é a função na.omit(). Ela não só remove os valores faltantes, mas como também guarda a localização dos dados faltantes. Esta informação é armazenada na lista de atributos do vetor. prec_alt_sem_falt &lt;- na.omit(prec_alt) attributes(prec_alt_sem_falt) #&gt; $names #&gt; [1] &quot;jan&quot; &quot;fev&quot; &quot;mai&quot; &quot;jul&quot; &quot;ago&quot; &quot;set&quot; &quot;out&quot; &quot;dez&quot; #&gt; #&gt; $na.action #&gt; mar abr jun nov #&gt; 3 4 6 11 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;omit&quot; As posições originais dos dados faltantes descartados podem ser obtidas com: attr( x = prec_alt_sem_falt, which = &quot;na.action&quot; ) #&gt; mar abr jun nov #&gt; 3 4 6 11 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;omit&quot; Quando trabalhamos com vetores grandes que contenham várias falhas é útil saber a posição da sequência de dados consecutivos válidos mais longa. A função na.contiguous() retornará somente elementos daquela sequência. prec_alt_val_long &lt;- na.contiguous(prec_alt) prec_alt_val_long #&gt; jul ago set out #&gt; 21 42 100 120 #&gt; attr(,&quot;na.action&quot;) #&gt; [1] 1 2 3 4 5 6 11 12 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;omit&quot; #&gt; attr(,&quot;tsp&quot;) #&gt; [1] 7 10 1 7.7.2 Indexação com NAs Suponha que queremos extrair um conjunto de elementos de prec_clim baseado em inds_na. prec_alt &gt; 220 #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; TRUE FALSE NA NA FALSE NA FALSE FALSE FALSE FALSE NA FALSE O interesse é extrair os valores de prec_clim quando a prec_alt superou 220 mm. A expressão para essa seleção é: prec_clim[prec_alt &gt; 220] #&gt; [1] 230 NA NA NA NA o resultado da filtragem foi um vetor com o resultado da condição de prec_clim para qual prec_alt &gt; 220 e também NAs. Isto é um resultado que provavelmente ninguém deseja. Se nós queremos extrair os valores de prec_clim para os quais prec_alt não é faltante e também superior a 220 nós devemos usar a seguinte expressão: prec_clim[!is.na(prec_alt) &amp; prec_alt &gt; 220] #&gt; [1] 230 A moral da história aqui é que na prática quando você tem NAs em índices (ou seja, nos valores de qualquer vetor dentro do colchetes) o pode retornar algo diferente do que era esperado. Uma função para filtragem de dados que é capaz de dar conta disso mais prontamente é função subset() (que pode ser traduzida como subconjunto) que recebe os dados no primeiro argumento (x) e a expressão lógica no segundo (argumento subset de mesmo nome da função). subset( x = prec_clim, subset = prec_alt &gt; 220 ) #&gt; [1] 230 7.7.3 Efeito de NAs em funções Na seção 5.2.3 vimos que qualquer operação com NA resulta em NA. Algumas funções úteis merecem ser enfatizadas quando usadas em vetores com dados faltantes. A função range() retorna a amplitude de variação dos valores em um vetor. range(prec_alt) #&gt; [1] NA NA Como prec_alt possui dados faltantes ela retornará NA. Assim como várias outras funções matemáticas básicas no a função range() permite especificar o argumento na.rm = TRUE para calcular o resultado após omitir os valores faltantes. range(prec_alt, na.rm = TRUE) #&gt; [1] 0 250 Logo, prec_alt varia de um mínimo 0 a um máximo de 250. Diversas funções tem essa funcionalidade, entre elas as mais usadas para estatísticas descritivas, como: # prec máx. mensal max(prec_alt, na.rm = TRUE) #&gt; [1] 250 # pŕec min mensal min(prec_alt, na.rm = TRUE) #&gt; [1] 0 # prec total anual sum(prec_alt, na.rm = TRUE) #&gt; [1] 941 # prec média mean(prec_alt, na.rm = TRUE) #&gt; [1] 117.625 # mediana da prec median(prec_alt, na.rm = TRUE) #&gt; [1] 110 # desvio padrão sd(prec_alt, na.rm = TRUE) #&gt; [1] 93.87216 # variância var(prec_alt, na.rm = TRUE) #&gt; [1] 8811.982 A função summary() fornece um resumo estatístico de uma variável, incluindo: mínimo, 1° quartil, mediana, média, 3° quartil, máximo e o número de casos faltantes (se aplicável). summary(prec_alt) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 0.00 36.75 110.00 117.62 202.00 250.00 4 "],
["dados-nulos.html", "7.8 Dados Nulos (NULL)", " 7.8 Dados Nulos (NULL) O NULL é um tipo especial de dado no . Ele é um vetor de tamanho zero. vetor_nulo1 &lt;- NULL vetor_nulo1 #&gt; NULL length(vetor_nulo1) #&gt; [1] 0 Um vetor nulo também pode ser definido com: vetor_nulo2 &lt;- c() vetor_nulo2 #&gt; NULL Note que um vetor ser nulo não significa que ele não exista. Ou seja, a atribuição de NULL a uma variável não apaga a variável de seu ambiente de trabalho. A existência de uma variável pode ser verificada com a função exists(), na qual o argumento x deve ser passado como caractere. exists(x = &quot;vetor_nulo1&quot;) #&gt; [1] TRUE Como o NULL é um vetor vazio, seu uso explícito dentro de um vetor não conta. Assim, qualquer operação com NULL resulta em um vetor vazio. (vetor_elem_nulo &lt;- c(1, 2, NULL, 4)) #&gt; [1] 1 2 4 length(vetor_elem_nulo) #&gt; [1] 3 vetor_elem_nulo + NULL #&gt; numeric(0) Em algumas situações você pode querer anular um atributo de um vetor, como os nomes. Eventualmente até mesmo o próprio vetor. prec #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 300 205 210 12 0 0 12 22 110 120 10 280 names(prec) &lt;- NULL prec #&gt; [1] 300 205 210 12 0 0 12 22 110 120 10 280 prec &lt;- NULL prec #&gt; NULL "],
["dados-duplicados.html", "7.9 Dados duplicados", " 7.9 Dados duplicados Dados frequentemente pode ter valores duplicados ou repetidos e dependendo da aplicação isso pode causar problemas nos resultados. Portanto é importante detectar e remover essas ocorrências. O oferece algumas funções convenientes para detectar dados duplicados. Mas antes, vamos criar um vetor de datas com alguns dias repetidos para então mostrar as funcionalidades disponíveis. datas &lt;- seq( from = as.Date(&quot;2017-01-10&quot;), to = as.Date(&quot;2017-01-10&quot;) + 10, by = &quot;day&quot; ) datas &lt;- c( datas[1:6], NA, datas[7:length(datas)], datas[length(datas)], datas[5:6] ) datas #&gt; [1] &quot;2017-01-10&quot; &quot;2017-01-11&quot; &quot;2017-01-12&quot; &quot;2017-01-13&quot; &quot;2017-01-14&quot; #&gt; [6] &quot;2017-01-15&quot; NA &quot;2017-01-16&quot; &quot;2017-01-17&quot; &quot;2017-01-18&quot; #&gt; [11] &quot;2017-01-19&quot; &quot;2017-01-20&quot; &quot;2017-01-20&quot; &quot;2017-01-14&quot; &quot;2017-01-15&quot; A função duplicated() detecta onde ocorrem valores repetidos. duplicated(datas) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [13] TRUE TRUE TRUE Ela retorna um vetor lógico mostrando quais elementos são duplicados. Neste exemplo os últimos 3 elementos. Este resultado pode ser usado para remover os valores repetidos: # datas únicas: sem valores duplicados datas[!duplicated(datas)] #&gt; [1] &quot;2017-01-10&quot; &quot;2017-01-11&quot; &quot;2017-01-12&quot; &quot;2017-01-13&quot; &quot;2017-01-14&quot; #&gt; [6] &quot;2017-01-15&quot; NA &quot;2017-01-16&quot; &quot;2017-01-17&quot; &quot;2017-01-18&quot; #&gt; [11] &quot;2017-01-19&quot; &quot;2017-01-20&quot; Alternativamente, há função unique() para remover valores repetidos de um vetor: unique(datas) #&gt; [1] &quot;2017-01-10&quot; &quot;2017-01-11&quot; &quot;2017-01-12&quot; &quot;2017-01-13&quot; &quot;2017-01-14&quot; #&gt; [6] &quot;2017-01-15&quot; NA &quot;2017-01-16&quot; &quot;2017-01-17&quot; &quot;2017-01-18&quot; #&gt; [11] &quot;2017-01-19&quot; &quot;2017-01-20&quot; "],
["dados-ordenados.html", "7.10 Dados ordenados", " 7.10 Dados ordenados Duas operações comuns em análise de dados são a ordenação e a classificação dados de um vetor. A função sort() arranja os dados de um vetor numérico em ordem crescente ou descrescente (se argumento for especificado como decreasing = TRUE). Se o vetor for de caracteres, o arranjo segue a ordem alfabética dando precedência às letras em minúsculo. sort(prec_alt) #&gt; mai jul ago set out fev dez jan #&gt; 0 21 42 100 120 200 208 250 sort(prec_alt, decreasing = TRUE) #&gt; jan dez fev out set ago jul mai #&gt; 250 208 200 120 100 42 21 0 sort(names(prec_alt)) #&gt; [1] &quot;abr&quot; &quot;ago&quot; &quot;dez&quot; &quot;fev&quot; &quot;jan&quot; &quot;jul&quot; &quot;jun&quot; &quot;mai&quot; &quot;mar&quot; &quot;nov&quot; &quot;out&quot; &quot;set&quot; A ordem de classificação de cada elemento de um vetor numérico é obtida com a função order(): prec_alt #&gt; jan fev mar abr mai jun jul ago set out nov dez #&gt; 250 200 NA NA 0 NA 21 42 100 120 NA 208 order(prec_alt) #&gt; [1] 5 7 8 9 10 2 12 1 3 4 6 11 O resultado indica que o 5º lemento de prec_alt é o menor valor e o 1º elemeno é o de maior valor. Isso pode ser facilmente verificado passando este resultado na indexação da prec_alt. # equivalente a sort() prec_alt[order(prec_alt)] #&gt; mai jul ago set out fev dez jan mar abr jun nov #&gt; 0 21 42 100 120 200 208 250 NA NA NA NA Nota-se então, que por padrão na saída da order() os elementos faltantes são colocados nas últimas posições (no exemplo: 3, 4, 6, 11). Para remover os casos faltantes especificamos o argumento na.last = NA. order(prec_alt, na.last = NA) #&gt; [1] 5 7 8 9 10 2 12 1 "],
["funções-móveis-úteis.html", "7.11 Funções móveis úteis", " 7.11 Funções móveis úteis Se queremos obter um valor que leve em consideração todos os valores anteriores e o valor atual, podemos usar funções da família cum{fun}(), como a cumsum() para somar valores à medida que avançamos na sequência. Esta operação é conhecida como soma cumulativa, total móvel ou soma móvel. Vamos obter a soma cumulativa da série da precipitação mensal abaixo. # serie de com 2 anos de prec mensal prec &lt;- c( 230, 205, 160, 100, 60, 30, 40, 60, 110, 165, 200, 220, 250,200, 210, 12, 0, 30, 21, 42, 100, 120, 10, 208 ) prec #&gt; [1] 230 205 160 100 60 30 40 60 110 165 200 220 250 200 210 12 0 30 21 #&gt; [20] 42 100 120 10 208 # meses de prec como datas dts &lt;- seq( from = as.Date(&quot;2010-01-01&quot;), by = &quot;month&quot;, length.out = length(prec) ) dts #&gt; [1] &quot;2010-01-01&quot; &quot;2010-02-01&quot; &quot;2010-03-01&quot; &quot;2010-04-01&quot; &quot;2010-05-01&quot; #&gt; [6] &quot;2010-06-01&quot; &quot;2010-07-01&quot; &quot;2010-08-01&quot; &quot;2010-09-01&quot; &quot;2010-10-01&quot; #&gt; [11] &quot;2010-11-01&quot; &quot;2010-12-01&quot; &quot;2011-01-01&quot; &quot;2011-02-01&quot; &quot;2011-03-01&quot; #&gt; [16] &quot;2011-04-01&quot; &quot;2011-05-01&quot; &quot;2011-06-01&quot; &quot;2011-07-01&quot; &quot;2011-08-01&quot; #&gt; [21] &quot;2011-09-01&quot; &quot;2011-10-01&quot; &quot;2011-11-01&quot; &quot;2011-12-01&quot; prec_ac &lt;- cumsum(prec) prec_ac #&gt; [1] 230 435 595 695 755 785 825 885 995 1160 1360 1580 1830 2030 2240 #&gt; [16] 2252 2252 2282 2303 2345 2445 2565 2575 2783 Para melhor compreensão vamos visualizar as duas variáveis na mesma escala. A precipitação será representada por barras e a precipitação acumulada até o mês decorrido como linha. Nós abordaremos os recursos para visualização gráfica na seção Visualização de dados. #library(ggplot2) # gráfico graf &lt;- qplot( x = dts, y = prec, geom = c(&quot;col&quot;), ylim = range(c(prec, prec_ac)) ) + # ajuste dos labels das datas (eixo x) scale_x_date( name = &quot;meses&quot;, date_breaks = &quot;2 months&quot;, date_labels = &quot;%b\\n%Y&quot; ) + # camada com prec acumulado layer( map = aes( x = dts, y = prec_ac, ), geom = &quot;line&quot;, params = list( colour = &quot;green&quot;, size = 1 ), stat = &quot;identity&quot;, position = &quot;identity&quot; ) graf # (y_cmx &lt;- cummax(y)) # (y_cmn &lt;- cummin(y)) As funções cummax() e cummin() fornecem os valores mínimo e máximo entre o início do vetor e a posição de cada elemento. Para enfatizar a utilidade destas funções, vamos considerar o vetor y abaixo, representando uma onda com amplitude que aumenta no tempo. (x &lt;- seq(from = 0, to = 2.75*pi, length.out = 20)) #&gt; [1] 0.0000000 0.4547042 0.9094084 1.3641126 1.8188168 2.2735210 2.7282252 #&gt; [8] 3.1829294 3.6376336 4.0923378 4.5470420 5.0017462 5.4564504 5.9111546 #&gt; [15] 6.3658588 6.8205630 7.2752672 7.7299714 8.1846756 8.6393798 (y &lt;- round(-x*cos(2*x), 2)) #&gt; [1] 0.00 -0.28 0.22 1.25 1.60 0.37 -1.85 -3.17 -1.99 1.33 4.30 4.19 #&gt; [13] 0.45 -4.35 -6.28 -3.25 2.92 7.49 6.46 0.00 # maximos e minimos móveis de y (y_env_sup &lt;- cummax(y)) #&gt; [1] 0.00 0.00 0.22 1.25 1.60 1.60 1.60 1.60 1.60 1.60 4.30 4.30 4.30 4.30 4.30 #&gt; [16] 4.30 4.30 7.49 7.49 7.49 (y_env_inf &lt;- cummin(y)) #&gt; [1] 0.00 -0.28 -0.28 -0.28 -0.28 -0.28 -1.85 -3.17 -3.17 -3.17 -3.17 -3.17 #&gt; [13] -3.17 -4.35 -6.28 -6.28 -6.28 -6.28 -6.28 -6.28 A visualização gráfica mostra que estas funções fornecem os envelopes superiore e inferior de variação de um vetor. graf &lt;- qplot( x = x, y = y, geom = c(&quot;line&quot;, &quot;point&quot;), ylim = range(c(y, y_env_sup, y_env_inf)) ) + # linha do envelope superior layer( map = aes( x = x, y = y_env_sup, ), geom = &quot;line&quot;, params = list( colour = &quot;red&quot;, size = 1 ), stat = &quot;identity&quot;, position = &quot;identity&quot; ) + # linha do envelope inferior layer( map = aes( x = x, y = y_env_inf ), geom = &quot;line&quot;, params = list( colour = &quot;blue&quot;, size = 1 ), stat = &quot;identity&quot;, position = &quot;identity&quot; ) graf Em alguns casos precisamos comparar os valores em relação a valores antes ou depois de um elemento do vetor. Para este tipo de operação podemos usar as funções: diff(x): diferencial ou primeira diferença, calcula para cada elemento de x a diferença x[i] - x[i-1] para i de 2 até length(x). Resulta em um vetor com um elemento a menos que o vetor de entrada. lag(x, n) do pacote dplyr3: atrasa os valores de um vetor x por n observações; lead(x, n) do pacote dplyr4: adianta os valores de um vetor x por n observações; Vamos comparar o resultado da diff() aplicada ao vetor de prec acumulado (prec_ac) com os valores prec. diff(prec_ac) #&gt; [1] 205 160 100 60 30 40 60 110 165 200 220 250 200 210 12 0 30 21 42 #&gt; [20] 100 120 10 208 #length(diff(prec_ac)) prec #&gt; [1] 230 205 160 100 60 30 40 60 110 165 200 220 250 200 210 12 0 30 21 #&gt; [20] 42 100 120 10 208 #length(prec) # vetor prec deslocado para frente (atrasado) lag(prec) #&gt; [1] NA 230 205 160 100 60 30 40 60 110 165 200 220 250 200 210 12 0 30 #&gt; [20] 21 42 100 120 10 # vetor prec deslocado para trás (adiantados) lead(prec) #&gt; [1] 205 160 100 60 30 40 60 110 165 200 220 250 200 210 12 0 30 21 42 #&gt; [20] 100 120 10 208 NA table() frequência de ocorrência, contagens, porcentagem e proporção prop.table()*100 # operação com dados lógicos prec_2anos &lt;- c( 230, 205, 160, 100, 60, 30, 40, 60, 110, 165, 200, 220, 250, 200, 210, 12, 0, 30, 21, 42, 100, 120, 10, 208 ) # suponha que a estação de uma região seja definida por um limiar # de 100 mm/mes # como identificar estes períodos? v &lt;- prec_2anos limiar &lt;- 100 # definição de evento (condição) eventos &lt;- v &gt; limiar # eventos &lt;- !eventos acum_eventos &lt;- cumsum(eventos) # mantém valores de cumsum qdo não é evento # e zera qdo é evento entre_eventos &lt;- acum_eventos * as.integer((!eventos)) # sequencia das ocorrência dentro de um evento (seq_eventos &lt;- acum_eventos - cummax(entre_eventos)) #&gt; [1] 1 2 3 0 0 0 0 0 1 2 3 4 5 6 7 0 0 0 0 0 0 1 0 1 # ordem de cada evento (ordem_eventos &lt;- cumsum(seq_eventos == 1) * eventos) #&gt; [1] 1 1 1 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 3 0 4 cumsum(eventos) * eventos #&gt; [1] 1 2 3 0 0 0 0 0 4 5 6 7 8 9 10 0 0 0 0 0 0 11 0 12 # duração dos eventos freq &lt;- table(ordem_eventos[ordem_eventos &gt; 0]) duracao &lt;- unname(rep(freq, times = freq)) dur &lt;- ordem_eventos dur[ordem_eventos != 0] &lt;- duracao #sequence(freq) tibble::tibble( prec_2anos, eventos, seq_eventos, ordem_eventos, dur ) #&gt; # A tibble: 24 x 5 #&gt; prec_2anos eventos seq_eventos ordem_eventos dur #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 230 TRUE 1 1 3 #&gt; 2 205 TRUE 2 1 3 #&gt; 3 160 TRUE 3 1 3 #&gt; 4 100 FALSE 0 0 0 #&gt; 5 60 FALSE 0 0 0 #&gt; 6 30 FALSE 0 0 0 #&gt; 7 40 FALSE 0 0 0 #&gt; 8 60 FALSE 0 0 0 #&gt; 9 110 TRUE 1 2 7 #&gt; 10 165 TRUE 2 2 7 #&gt; # ... with 14 more rows Encontrando os índices de início e fim dos eventos: #(cs &lt;- cumsum(eventos) * eventos) inicio &lt;- which(seq_eventos == 1) fim &lt;- which(((seq_eventos == dur) * eventos) == 1) # identificador do evento unique(ordem_eventos[ordem_eventos &gt; 0]) #&gt; [1] 1 2 3 4 # indice do inicio do evento inicio #&gt; [1] 1 9 22 24 # indice do fim do evento fim #&gt; [1] 3 15 22 24 # duracao de cada evento dur[inicio] # ou dur[fim] #&gt; [1] 3 7 1 1 as.integer(eventos) #&gt; [1] 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 1 faz parte da coleção de pacotes para ciência de dados chamada tidyverse.↩ faz parte da coleção de pacotes para ciência de dados chamada tidyverse.↩ "],
["exercícios-1.html", "7.12 Exercícios", " 7.12 Exercícios Crie um vetor com os valores de \\(e^{x}cos{x}\\) para os valores de \\(x = (3, 3.1, 3.2, ..., 6\\)). Crie os seguintes vetores. \\((0.1^{3}\\times0.2^{1}, 0.1^{6}\\times0.2^{4}, ..., 0.1^{36}\\times0.2^{34})\\) \\((2, \\frac{2^{2}}{2}, \\frac{2^{3}}{3}, ..., \\frac{2^{25}}{25})\\) Reproduza a criação do vetor dias da semana (dds) mostrado abaixo. Escreva os códigos necessários para determinar: o vetor lógico indicando quais números são pares na sequência de valores 85, 79, 70, 6, 32, 8, 17, 93, 81, 76. Calcule o total de números ímpares. Se um ano é bissexto. Verifique os resultados de seu código para os anos 1974, 1968, 1959, 1895, 1921, 1897, 1906, 1982, 1970, 1965. Calcule o total de anos com 365 dias. Quais códigos para gerar os seguintes dados: [1] -30 0 5 10 15 20 30 [1] 1.0 0.8 0.6 0.4 0.2 0.0 [1] 3.141593 3.141593 3.141593 3.141593 3.141593 3.141593 3.141593 3.141593 [9] 3.141593 3.141593 3.141593 3.141593 [1] -1 -1 0 0 0 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 [26] 4 4 5 5 5 5 5 5 5 5 [1] 5 5 5 5 5 4 4 4 4 3 3 3 2 2 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 Dica: lembre da função rep() e seus argumentos each e times. Experimente usar vetores nesses argumentos. Como a partir da matriz gerada na letra f você pode obter a matriz abaixo? Qual o código para converter a matriz gerada na letra g no vetor abaixo? Como obter as seguintes sequências a partir dos vetores fornecidos usando a mesma solução para todos casos? v3 = (10, 0.5, 8, 4) [1] 1 2 3 4 v2 = (10, 0.5) [1] 1 2 v1 = (10) [1] 1 v0 = () integer(0) Calcule a soma cumulativa dos números 2, 3, 4, 5, 6. Dica: ver a função cumsum(). (b) Calcule a soma cumulativa destes números mas na ordem reversa. Dica: ver a função rev(). Os dados abaixo são de precipitação horária de um evento severo ocorrido em 03/12/2012 em Santa Maria-RS. hora prec 9 0.0 10 0.0 11 0.0 12 0.0 13 0.0 14 0.0 15 0.0 16 21.4 17 41.2 18 2.6 19 1.0 20 0.4 21 0.0 Como seria o código para determinar a soma cumulativa da precipitação horária? Salve seu resultado em um vetor chamado prec_acum. Interprete o resultado c(NA, diff(prec_acum)). Mostre o código para encontrar o horário de ocorrência da precipitação máxima? Mostre o código para obter a hora de início e fim do evento de precipitação severa. Qual foi a duração do evento? Qual foi a precipitação total do evento? Quanto da precipitação total do evento, em %, ocorreu até às 17 h? EXERCÍCIO RESOLVIDO. Considere o vetor x definido pelos números descritos abaixo. Mostre como encontrar o primeiro número positivo localizado após o último número negativo. Por exemplo, seja o vetor z definido pelos valores (11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14). Os valores selecionados seriam 5 e 30. Um possível código para chegar a esse resultado seria: x &lt;- c( 11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14 ) # x1 &lt;- ifelse(x &gt; 0, 1, 0) # cópia de x x01 &lt;- x # substituo x positivo por 1 e x negativo por 0 x01[x &gt; 0] &lt;- 1 x01[!x &gt; 0] &lt;- 0 res &lt;- x[which(diff(x01) == 1) + 1] res #&gt; [1] 5 30 Mostre o código para resolver as seguintes tarefas. Considere o vetor prec com valores de precipitação diária indicado abaixo. prec &lt;- c( 0, 0, 0, 0.8, 0, 0.01, 0.75, 0, 0, 0, 0, 0.35, 0.08, 0, 0, 0, 0, 0.31, 0, 3.57, 12.17, 0, 0, 0, 0.04, 3.16, 0, 0.95, 0.79, 0, 0, 0, 0, 0, 3.51, 0, 0, 0.16, 0, 0, 8.16, 0.54, 4.39, 1.24, 0, 0, 0, 0, 0, 2.43, 0, 0, 0, 0, 0, 7.18, 0, 0, 0.26, 0, 0, 0.28, 0, 0, 0.09, 0.38, 0, 0, 0, 0, 0, 0, 0.51, 0, 0, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0.15, 0, 0.82, 0, 0, 0, 0, 0, 0, 0, 0, 0.37, 0, 0.58, 4.95, 0, 0, 0, 0, 0, 7.68, 0, 0, 0.37, 0, 1.56, 0, 0, 0, 0.34, 0.48, 0, 4.21, 2.28, 4.3, 0, 3.38, 0, 0, 0, 0, 7.28, 0, 4.89, 3.91, 0, 0, 0, 0, 0, 0, 2.93, 0, 2.49, 0.77, 0, 2.9, 3.53, 0.83, 0, 0, 0, 0.94, 0.59, 0, 0, 0, 0, 0.04, 0, 0.65, 0, 0, 0, 6.23, 0.09, 0, 0.66, 0, 0, 0, 4.42, 0, 0, 0, 0.84, 0, 0, 0, 0, 0, 0.09, 0, 0, 0.08, 0, 0.66, 0, 0, 0, 0.06, 0, 0, 0, 3.28, 0, 0.8, 5.69, 0.8, 0 ) Quantos dias ocorreram no intervalo 0 &lt; prec &lt; 0.25? Substitua os valores de chuva registrados no intervalo 0 &lt; prec &lt; 0.25 por 0. Crie um vetor denominado prec01 indicando o estado da precipitação (chuvoso = 1, seco = 0) baseado no limiar de 0.25 mm para detecção de chuva pelo pluviômetro. Qual a probabilidade de chuva dessa série de precipitação diária? Qual a probabilidade de chover dois dias consecutivos (p11)? Calcule a probabilidade de chover em qualquer um de dois dias consecutivos (p01 + p10)? Determine a duração de cada evento chuvoso (número de dias consecutivos). Dica: comece encontrando a posição do início do evento e depois a posição final do evento. A diferença entre as posições fornece a duração do evento. O exercício resolvido (9) é análogo a esse exercício. O resultado esperado é um vetor que identifique o evento e sua duração. duracao &lt;- c(evento1 = 1, evento2 = 1, evento3 = 1, evento4 = 1, evento5 = 2, evento6 = 1, evento7 = 2, evento8 = 1, evento9 = 4, evento10 = 1, evento11 = 1, evento12 = 1, evento13 = 1, evento14 = 1, evento15 = 1, evento16 = 1, evento17 = 1, evento18 = 1, evento19 = 2, evento20 = 1, evento21 = 1, evento22 = 1, evento23 = 2, evento24 = 3, evento25 = 1, evento26 = 1, evento27 = 2, evento28 = 1, evento29 = 2, evento30 = 3, evento31 = 2, evento32 = 1, evento33 = 1, evento34 = 1, evento35 = 1, evento36 = 1, evento37 = 1, evento38 = 1, evento39 = 3) duracao #&gt; evento1 evento2 evento3 evento4 evento5 evento6 evento7 evento8 #&gt; 1 1 1 1 2 1 2 1 #&gt; evento9 evento10 evento11 evento12 evento13 evento14 evento15 evento16 #&gt; 4 1 1 1 1 1 1 1 #&gt; evento17 evento18 evento19 evento20 evento21 evento22 evento23 evento24 #&gt; 1 1 2 1 1 1 2 3 #&gt; evento25 evento26 evento27 evento28 evento29 evento30 evento31 evento32 #&gt; 1 1 2 1 2 3 2 1 #&gt; evento33 evento34 evento35 evento36 evento37 evento38 evento39 #&gt; 1 1 1 1 1 1 3 EXERCÍCIO RESOLVIDO. Dado o vetor temp mostrado abaixo. temp &lt;- c( NA, NA, 27L, 7L, 4L, 0L, 26L, 15L, 25L, NA, NA, NA, NA, 6L, 29L, 18L, 17L, 23L, 20L, 1L, 30L, 13L, NA, NA, NA, NA, NA, NA, NA, 19L ) Como você pode codificar a obtenção de um vetor com zeros nos valores válidos e com números sequenciais dentro das falhas? # vetor lógico de falhas eh_falha &lt;- is.na(temp) # soma cumulativa de falhas acum_falhas &lt;- cumsum(eh_falha) # calculando soma a partir do início da falha seq_falhas &lt;- acum_falhas - cummax((!eh_falha) * acum_falhas) seq_falhas #&gt; [1] 1 2 0 0 0 0 0 0 0 1 2 3 4 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 0 Como a partir do vetor resultante em 11.b obter um vetor cujo os valores dentro das falhas indique a ordem de ocorrência da falha. (ordem_falhas &lt;- cumsum(seq_falhas == 1) * as.integer(eh_falha &gt; 0)) #&gt; [1] 1 1 0 0 0 0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 0 Qual o tamanho de cada falha. pos_fim_falha &lt;- which(c(NA, diff(ordem_falhas)) &lt; 0) - 1 (tamanho_falhas &lt;- seq_falhas[pos_fim_falha]) #&gt; [1] 2 4 7 # names(tamanho_falhas) &lt;- paste0(&quot;falha&quot;, unique(ordem_falhas[ordem_falhas &gt; 0])) names(tamanho_falhas) &lt;- paste0(&quot;falha&quot;, seq_along(tamanho_falhas)) tamanho_falhas #&gt; falha1 falha2 falha3 #&gt; 2 4 7 Determine o tamanho da maior falha? (max_falha &lt;- max(tamanho_falhas)) #&gt; [1] 7 Para os valores de velocidade (\\(V_h\\)) e a direção do vento (\\(\\theta\\)) (na convenção meteorológica): \\(V_h\\) = (10, 10, 10, 10, 14.142, 14.142, 14.142, 14.142, 0) \\(\\theta\\) = (270, 180, 360, 90, 225, 315, 135, 45, 0) Determine as componentes zonal e meridional do vento. \\[u = -V_{h} \\cdot sin(\\theta_{rad})\\] \\[v = -V_{h} \\cdot cos(\\theta_{rad})\\] Faça os cálculos necessários para reconstruir \\(V_h\\) e \\(\\theta\\) a partir de \\(u\\) e \\(v\\) determinados no item a. Por convenção, a direção do vento \\(\\theta\\) em condições calmas (\\(V_h\\) &lt; 0.5 m s-1) é assumida como 0°. \\[V_{h} = \\sqrt{(u^2 + v^2)}\\] \\[\\theta_{mat} = {\\rm atan2}(-u, -v)\\cdot\\frac{180}{\\pi}\\] \\[ \\theta = \\left\\{\\begin{matrix} \\theta_{mat} + 360 &amp; se &amp; \\theta_{mat} &lt; 0 \\\\ 0 &amp; se &amp; u = 0,\\: v = 0 \\: \\: ou \\: \\: V_{h} &lt; 0.5\\\\ \\end{matrix}\\right. \\] Como resultado monte um data frame com todas variáveis derivadas. u v ws wd wd_uv dir 10 0 10.000 270 270 Oeste 0 10 10.000 180 180 Sul 0 -10 10.000 360 360 Norte -10 0 10.000 90 90 Leste 10 10 14.142 225 225 Sudoeste 10 -10 14.142 315 315 Noroeste -10 10 14.142 135 135 Sudeste -10 -10 14.142 45 45 Nordeste 0 0 0.000 0 0 Calmo Dica: ver figura abaixo. Para as séries de prec_obs e prec_sim calcule: a proporção corretamente prevista \\(PC = \\frac{wc+dc}{n}\\) o índice de sucesso crítico \\(CSI=\\frac{wc}{wc+wi+di}\\). Onde \\(wc\\) e \\(dc\\) são as previsões corretas de dias úmidos (\\(prec &gt; 0.25\\) mm dia-1) e secos respectivamente, \\(wi\\) e \\(di\\) são as previsões incorretas de dias úmidos e secos respectivamente. \\(n\\) é o n° total de previsões. prec_obs &lt;- c( 0, 0, 0, 0.5, 1, 6, 9, 0.2, 1, 0, 0, 0.25, 10, 15, 8, 3, 0, 0, 0, 0, 0, 0, 0.25, 0, 0, 0, 1, 5, 0, 20, 0, 0, 0, 0, 1, 1, 0, 2, 12, 1, 0, 0, 0, 0, 0, 0, 5, 5 ) prec_sim &lt;- c( 0, 0.2, 0.1, 0, 0, 3, 1, 1, 1, 1, 0, 3, 0, 10, 4, 1, 0.3, 0.5, 0.5, 0.5, 0.5, 0, 0.25, 0.25, 0.25, 0, 0.5, 3, 0, 5, 0, 0, 0, 0, 0.5, 0, 0.25, 0.2, 0, 0.2, 0, 0, 0, 0, 1, 2, 1, 0 ) Escreva o código para calcular o coeficiente de correlação de Pearson (r) entre os vetores obs e prev. Confira seu resultado com a saída da função cor(obs, prev). obs &lt;- c( -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16, 0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73, -0.49, -0.04, -0.11, 0.46, 2.02, -1.05 ) prev &lt;- c( NA, -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16, 0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73, -0.49, -0.04, -0.11, 0.46, 2.02 ) Construa uma função para converter valores de temperatura em K para °C e outra para converter ângulos de radianos para graus. Utilize dois exemplos para mostrar que suas funções funcionam corretamente. "]
]
